<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaSE(三)类的设计和继承 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本节讲述了Java中的一个重要特性：继承。并以此来衍生了很多的概念和使用方法：  继承（类、父类、子类） Object类 泛型数组列表 对象包装器（自动装箱和拆箱） 可变参数的方法 枚举类 反射特性 继承的设计技巧"><meta property="og:type" content="blog"><meta property="og:title" content="JavaSE(三)类的设计和继承"><meta property="og:url" content="http://example.com/2021/08/02/JavaSE-%E4%B8%89-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BB%A7%E6%89%BF/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="本节讲述了Java中的一个重要特性：继承。并以此来衍生了很多的概念和使用方法：  继承（类、父类、子类） Object类 泛型数组列表 对象包装器（自动装箱和拆箱） 可变参数的方法 枚举类 反射特性 继承的设计技巧"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/JavaSE3.jpeg"><meta property="article:published_time" content="2021-08-02T07:46:15.000Z"><meta property="article:modified_time" content="2021-08-03T06:37:34.574Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="JavaSE"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/JavaSE3.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/08/02/JavaSE-%E4%B8%89-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BB%A7%E6%89%BF/"},"headline":"JavaSE(三)类的设计和继承","image":[],"datePublished":"2021-08-02T07:46:15.000Z","dateModified":"2021-08-03T06:37:34.574Z","author":{"@type":"Person","name":"binshow"},"description":"本节讲述了Java中的一个重要特性：继承。并以此来衍生了很多的概念和使用方法：  继承（类、父类、子类） Object类 泛型数组列表 对象包装器（自动装箱和拆箱） 可变参数的方法 枚举类 反射特性 继承的设计技巧"}</script><link rel="canonical" href="http://example.com/2021/08/02/JavaSE-%E4%B8%89-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BB%A7%E6%89%BF/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/JavaSE3.jpeg" alt="JavaSE(三)类的设计和继承"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-02T07:46:15.000Z" title="2021/8/2下午3:46:15">2021-08-02</time>发表</span><span class="level-item"><time dateTime="2021-08-03T06:37:34.574Z" title="2021/8/3下午2:37:34">2021-08-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">43 分钟读完 (大约6454个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaSE(三)类的设计和继承</h1><div class="content"><p>本节讲述了Java中的一个重要特性：继承。并以此来衍生了很多的概念和使用方法：</p>
<ol>
<li>继承（类、父类、子类）</li>
<li>Object类</li>
<li>泛型数组列表</li>
<li>对象包装器（自动装箱和拆箱）</li>
<li>可变参数的方法</li>
<li>枚举类</li>
<li>反射特性</li>
<li>继承的设计技巧</li>
</ol>
<span id="more"></span>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承的意思是：</p>
<p>可以基于已存在的类构造一个新类。继承已存在的类就是复用(继承)这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。</p>
<p>比如Manager类继承了Employee类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// instance fields</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year , <span class="keyword">int</span> mouth , <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">      <span class="keyword">this</span>.hireDay = LocalDate.of(year,mouth,day);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(LocalDate hireDay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.salary += raise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, o.getSalary());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengbinbin</span></span><br><span class="line"><span class="comment"> * 经理类继承了员工类，获得了员工类的实例域和方法</span></span><br><span class="line"><span class="comment"> * 1. 在子类中可以增加域、增加方法、覆盖父类的方法。但是绝不能删除继承的任何域或方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus; <span class="comment">// 经理有自己的一个存储奖金信息的域</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 子类构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> mouth, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, mouth, day); <span class="comment">// 通过super实现对超类构造器的调用，必须是子类构造器的第一个语句</span></span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">   <span class="comment">// 覆盖父类中的返回薪水的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary =  <span class="keyword">super</span>.getSalary(); <span class="comment">// super关键字代表的是父类</span></span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        bonus = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">				Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;binshow&quot;</span>,<span class="number">80000</span>,<span class="number">1997</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        boss.setBonus(<span class="number">5000</span>); <span class="comment">//奖金5000</span></span><br><span class="line"></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>] = boss;</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;zkd&quot;</span>,<span class="number">30000</span>,<span class="number">1996</span>,<span class="number">10</span>,<span class="number">22</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;aaa&quot;</span>,<span class="number">10000</span>,<span class="number">1997</span>,<span class="number">7</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name= &quot;</span> + e.getName() + <span class="string">&quot;, salary= &quot;</span> + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a” 规则</p>
<p>它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。</p>
<p>多态的意思是： 可以将一个子类的对象赋给超类变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个Employee变量即可以引用一个Employee类对象，也可以引用任何一个Employee的子类的对象</span></span><br><span class="line">      Employee e;</span><br><span class="line">      e = <span class="keyword">new</span> Employee(<span class="string">&quot;zkd&quot;</span>,<span class="number">30000</span>,<span class="number">1996</span>,<span class="number">10</span>,<span class="number">22</span>);</span><br><span class="line">      e = <span class="keyword">new</span> Manager(<span class="string">&quot;binshow&quot;</span>,<span class="number">20000</span>,<span class="number">1996</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;binshow&quot;</span>,<span class="number">80000</span>,<span class="number">1997</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">      Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">      staff[<span class="number">0</span>] = boss; <span class="comment">//  staff[0] 和 boss 引用的是同一个对象，但是编译器认为 staff[0] 是一个 Employee对象</span></span><br><span class="line">      boss.setBonus(<span class="number">5000</span>); <span class="comment">// 可以</span></span><br><span class="line">     <span class="comment">// staff[0].setBonus(); // Error， 父类对象不能调用子类的方法。</span></span><br></pre></td></tr></table></figure>





<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>下面假设要调用x.f(args),隐式参数x声明为类C的一个对象。下面是调用过程的详细过程:</p>
<ol>
<li>编译器查看对象的声明类型和方法名。假设调用x.f(param)， 且隐式参数x声明为C类的对象。需要注意的是:有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int) 和方法f(String)。 编译器将会一一列举 所有C类中名为f的方法和其超类中访问属性为public且名为f的方法(超类的私有方法不可访问)。至此，<strong>编译器已获得所有可能被调用的候选方法</strong>。</li>
<li>**接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析( overloadingresolution)**。例如，对于调用x.f(“Hello” )来说，编译器将会挑选f(String), 而不是f(int)。由于允许类型转换，这个过程可能很复杂。如果找到和参数类型相匹配的方法，编译器就获得了需要调用的方法名字和参数类型。</li>
<li>如果是private方法、static 方法、final方法(有关final修饰符的含义将在下一节讲述)或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为<strong>静态绑定( static binding)<strong>。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现</strong>动态绑定</strong>。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。</li>
<li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它;否则，将在D类的超类中寻找f(String)，以此类推。</li>
</ol>
<blockquote>
<p>ps:</p>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，**虚拟机预先为每个类创建了一个方法表( method table)**，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候只需要查找这个表就行了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line">				Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;binshow&quot;</span>,<span class="number">80000</span>,<span class="number">1997</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        boss.setBonus(<span class="number">5000</span>); <span class="comment">//奖金5000</span></span><br><span class="line"></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>] = boss;</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;zkd&quot;</span>,<span class="number">30000</span>,<span class="number">1996</span>,<span class="number">10</span>,<span class="number">22</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;aaa&quot;</span>,<span class="number">10000</span>,<span class="number">1997</span>,<span class="number">7</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name= &quot;</span> + e.getName() + <span class="string">&quot;, salary= &quot;</span> + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以这里的e.getSalary() 为例：</span></span><br><span class="line"><span class="number">1.</span> e是一个 Employee 类型，这个类只有一个getSalary方法且没有参数。所以不会有重载的解析。</span><br><span class="line"><span class="number">2.</span> getSalary 不是 <span class="keyword">private</span>、<span class="keyword">static</span>、<span class="keyword">final</span>方法，所以会采用动态绑定</span><br><span class="line"><span class="number">3.</span> 虚拟机为 Employee类和Manager类 生成方法表:(省略了Object方法)</span><br><span class="line">		Employee:</span><br><span class="line">            getName() -&gt; Employee . getName()</span><br><span class="line">            getSalary() -&gt; Employee . getSalary()</span><br><span class="line">            getHireDay() -&gt; Employee . getHireDay()</span><br><span class="line">            raiseSalary(<span class="keyword">double</span>) -&gt; Emp1oyee. raiseSalary(doub1e)</span><br><span class="line">    </span><br><span class="line">    Manager:</span><br><span class="line">            getName() -&gt; Employee.getName()</span><br><span class="line">            getSalary() -&gt; Manager . <span class="function">getSalaryO</span></span><br><span class="line"><span class="function">            <span class="title">getHireDay</span><span class="params">()</span> -&gt; Emp1oyee.getHi <span class="title">reDay</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            raiseSalary(<span class="keyword">double</span>)</span> -&gt; Employee. <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span>)</span> -&gt; Manager . <span class="title">setBonus</span> <span class="params">(doub1e)</span>          </span></span><br><span class="line"><span class="function">              </span></span><br><span class="line"><span class="function">4. 虚拟机提取e的实际类型的方法表，有可能是Employee、Manager的方法表，也可能是Employee的其他子类的方法表</span></span><br><span class="line"><span class="function">5. 最后搜索定义了getSalary 的类，调用该方法</span></span><br></pre></td></tr></table></figure>



<h2 id="如何阻止继承：final类和方法"><a href="#如何阻止继承：final类和方法" class="headerlink" title="如何阻止继承：final类和方法"></a>如何阻止继承：final类和方法</h2><p><strong>将类修饰成final表示该类不允许继承。同理将方法修饰成final表示在该类的子类中不允许重写该方法。</strong></p>
<p>在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final 关键字。如果-一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联( inlining)。例如，内联调用e.getName( )将被替换为访问e.name域。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果getName在另外-一个类中被覆盖，那么编译器就无法:知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p>
<p>幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢?优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>进行类型转换的 唯一原因是：暂时忽略对象的实际类型之后使用对象的全部功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">3.14</span>;</span><br><span class="line">   <span class="keyword">int</span> n = (<span class="keyword">int</span>) x; <span class="comment">// 强制类型转换，将x的值转换成整数类型，舍弃了小数部分。</span></span><br><span class="line"></span><br><span class="line">   Manager manager = (Manager) staff[<span class="number">0</span>]; <span class="comment">// 将Employee对象 强制转换成 Manager对象。</span></span><br><span class="line">   <span class="comment">// staff[0].setBonus(); // Error</span></span><br><span class="line">   manager.setBonus(<span class="number">2000</span>); <span class="comment">// 暂时忽略对象的实际类型之后使用对象的全部功能</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将一个值存入变量时，编译器将会检查是否允许这个操作。</span></span><br><span class="line"><span class="comment">    * 1. 如果是将子类的引用赋给一个超类变量（前面所说的多态），编译器是运行的。</span></span><br><span class="line"><span class="comment">    * 2. 但是如果是将一个超类的引用赋给一个子类的变量，就必须进行类型转换了，这样会进行运行时的检查</span></span><br><span class="line"><span class="comment">    * 3. 最好在将超类转换成子类之前，使用instanceOf进行检查</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">   Employee a = <span class="keyword">new</span> Employee(<span class="string">&quot;zkd&quot;</span>,<span class="number">30000</span>,<span class="number">1996</span>,<span class="number">10</span>,<span class="number">22</span>);</span><br><span class="line">   Manager b = <span class="keyword">new</span> Manager(<span class="string">&quot;binshow&quot;</span>,<span class="number">20000</span>,<span class="number">1996</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">   a = b; <span class="comment">//将子类的引用赋给一个超类变量</span></span><br><span class="line">   b = (Manager) a; <span class="comment">//将一个超类的引用赋给一个子类的变量</span></span><br><span class="line">   </span><br><span class="line">   a.getSalary();</span><br><span class="line">   b.getSalary(); <span class="comment">//两个类的对象都可以正确的调用 getSalary方法。由于动态绑定</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 只有在使用Manager 类中的特有方法才需要进行类型转换。</span></span><br><span class="line">   b.setBonus(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>





<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在继承层次中，位于上层的类更具有通用性和抽象性。比如一个Employee、一个Student都是一个Person类。都有一个name域，就可以将这个name放在Person这个继承层次较高的通用超类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengbinbin</span></span><br><span class="line"><span class="comment"> * 抽象类Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例域</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供的域访问器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法，提供给子类去扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// instance fields</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year , <span class="keyword">int</span> mouth , <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">      <span class="keyword">this</span>.hireDay = LocalDate.of(year,mouth,day);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="comment">// 必须要重写抽象父类中的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;an employee with a salary of $%.2f&quot;</span>,salary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(LocalDate hireDay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.salary += raise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, o.getSalary());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name , String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a student majoring in &quot;</span> + major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">      Person[] people = <span class="keyword">new</span> Person[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      people[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;binshow&quot;</span>,<span class="number">2000</span>,<span class="number">1995</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">      people[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;zkd&quot;</span> , <span class="string">&quot;math&quot;</span>);</span><br><span class="line">			</span><br><span class="line">    	<span class="comment">// 由于不能构造Person类的对象，所有变量P肯定指的是Person的子类</span></span><br><span class="line">      <span class="keyword">for</span> (Person p : people)&#123;</span><br><span class="line">        System.out.println(p.getName() + <span class="string">&quot; , &quot;</span> + p.getDescription());</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// binshow , an employee with a salary of $2000.00</span></span><br><span class="line">        <span class="comment">// zkd , a student majoring in math</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h1><p><strong>Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 可以用Object类型的变量仅作为任意类型的指代符</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">// 2. 但是如果要用到具体某个类型自身的方法，还是需要强制类型转换</span></span><br><span class="line">        Employee e = (Employee) obj;</span><br><span class="line">        <span class="comment">//3. 在Java中只有原始数据类型（数字，字母，boolean值）不能用object指代。数组对象无论是对象数组，还是原始数据类型数组都是Object的子类</span></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">        obj = staff;    <span class="comment">//对象数组</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//原始数据类型数组</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ul>
<li><strong>如果两个对象引用相等，这两个对象就相等。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object#equals</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较的是两个对象的引用是否一致。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在实际使用中经常需要基于状态来比较两个对象是否相等:比如下面比较两个员工对象是否相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//1. 如果两个对象所属的类不同，肯定也不相等</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee employee = (Employee) o; <span class="comment">//到这时o是一个不为空的 Employee 对象了</span></span><br><span class="line">        <span class="comment">//2. 只有满足两个员工对象的姓名、薪水和入职日期是一样的，才能认为是同一个对象</span></span><br><span class="line">        <span class="comment">// PS: 在这里防止 name 和 hireDay 为null，所以需要用equals方法进行比较。equals方法中如果两个参数都为null返回true。其中一个为null返回false</span></span><br><span class="line">        <span class="comment">//return name.equals(employee.name) &amp;&amp; salary == employee.salary &amp;&amp; hireDay.equals(employee.hireDay);</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name , employee.name)</span><br><span class="line">                &amp;&amp; salary == employee.salary</span><br><span class="line">                &amp;&amp; Objects.equals(hireDay,employee.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(salary, hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>在子类中如果定义equals方法，则首先调用父类的equals方法比较引用地址，如果检测失败，则两个对象肯定不相等。如果父类中的字段都相等，再比较子类中的实例字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//1. 首先调用父类中的equals方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(o)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manager manager = (Manager) o;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(manager.bonus, bonus) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(<span class="keyword">super</span>.hashCode(), bonus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Java语言规范要求equals方法具有一下特性：</p>
<ul>
<li>自反性：</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>对于任意非空引用x，x.equals(null)肯定返回false</li>
</ul>
</li>
</ul>
<h4 id="equals方法中继承关系的处理"><a href="#equals方法中继承关系的处理" class="headerlink" title="equals方法中继承关系的处理"></a>equals方法中继承关系的处理</h4><p>前面的例子中，如果发现两个对象所属的类不匹配，就返回false。但有的情况会这么编写equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     				<span class="comment">//这种方式就允许了o属于它的子类，但是这样编写会有一些问题</span></span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Employee)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Employee employee = (Employee) o; </span><br><span class="line">            <span class="keyword">return</span> Objects.equals(name , employee.name)</span><br><span class="line">                    &amp;&amp; salary == employee.salary</span><br><span class="line">                    &amp;&amp; Objects.equals(hireDay,employee.hireDay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题： e.equals(m) <span class="comment">//其中 e是Employee对象。而 m是 Manager对象。两个对象有相同的姓名，薪水和雇佣日期，此时这个equals方法返回true</span></span><br><span class="line">  		但是根据对称性原则 m.equals(e) 必须也要返回<span class="keyword">true</span>，这样的话就忽略了Manager独有的字段比较</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>java.util.AbstractSet#equals</strong>,有两个子类TreeSet和HashSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> containsAll(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>结论：<ul>
<li><strong>如果子类可以有自己的相等性概念，则对称性需求将强制使用getClass检测</strong></li>
<li><strong>如果由父类决定相等性概念，那么可以使用instanceOf来检测，可以在不同的子类对象中进行相等性比较</strong>。</li>
</ul>
</li>
</ul>
<p>编写equals方法的正确步骤：</p>
<ol>
<li>显示参数为otherObject</li>
<li>检查this和otherObject是否相等。（比较地址比比较字段开销要小很多）</li>
<li>如果otherObject为null，直接返回false</li>
<li>比较this和otherObject的两个类，如果equals的语义可以在子类中改变。则使用getClass进行检测；如果所有的子类都有相同的相等性语义，则使用instanceOf检测。</li>
<li>将otherObject强制转换成this的类</li>
<li>进行字段比较，基础数据类型用==，其他字段使用equals。<strong>如果在子类中重新定义equals，则需要包含一个super.equals（other）的调用。</strong></li>
</ol>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p><strong>Object默认的hashCode方法会根据对象的存储地址来计算出散列码。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        String s = <span class="string">&quot;Ok&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;s的哈希码是：&quot;</span> + s.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sb的哈希码是：&quot;</span> + sb.hashCode());</span><br><span class="line">        String t = <span class="keyword">new</span> String(<span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">        StringBuilder tb = <span class="keyword">new</span> StringBuilder(t);</span><br><span class="line">        System.out.println(<span class="string">&quot;t的哈希码是：&quot;</span> + t.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;tb的哈希码是：&quot;</span> + tb.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        s的哈希码是：2556</span></span><br><span class="line"><span class="comment">//        sb的哈希码是：685325104</span></span><br><span class="line"><span class="comment">//        t的哈希码是：2556</span></span><br><span class="line"><span class="comment">//        tb的哈希码是：460141958</span></span><br><span class="line">        <span class="comment">// s 和 t 的哈希码是一样的，是因为String的hashCode是从字符串内容导出的</span></span><br><span class="line">        <span class="comment">// sb 和 tb 的哈希码是不一样的，是因为 StringBuilder 的hashCode 是默认的Object的hashCode,也就是从内存地址导出的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String#<span class="function">hashCode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>如果重新定义了hashCode方法，也必须要重写equals方法。因为如果x.equals(y)为true，那么x.hashcode()和y.hashcode()必须也要相同</strong></p>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>toString方法用来返回表示对象值的字符串。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, salary=&quot;</span> + salary +</span><br><span class="line">                    <span class="string">&quot;, hireDay=&quot;</span> + hireDay +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设计子类的toString方法需要加入子类的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Manager&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;bonus=&quot;</span> + bonus +</span><br><span class="line">               <span class="string">&quot;&#125; &quot;</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果x是一个任意对象，那么调用<code>System.out.println(x);</code> 就会调用x的toString方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组继承了Object类的toString方法				</span></span><br><span class="line">				.<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(nums); <span class="comment">// [I@4554617c(前缀[I表示是一个数组)</span></span><br><span class="line">        String numsString = <span class="string">&quot;&quot;</span> + nums;</span><br><span class="line">        System.out.println(numsString); <span class="comment">//[I@4554617c</span></span><br><span class="line">        System.out.println(Arrays.toString(nums));<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型数组列表ArrayList"><a href="#泛型数组列表ArrayList" class="headerlink" title="泛型数组列表ArrayList"></a>泛型数组列表ArrayList</h2><p>在C/C++中，必须在编译的时候就要确定整个数组的大小。而在Java中提供了动态数组ArrayList，如果调用add方法而内部数组已经满了，数组就会自动创建一个更大的数组，并将所有对象从较小的数组拷贝到较大的数组中。</p>
<p><strong>ArrayList是一个采用类型参数的泛型类</strong>。为了指定数组中保存的元素类型，使用尖括号&lt;&gt;来指定存储的元素类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 构造了一个保存Employee对象的数组列表</span></span><br><span class="line">      ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//1. 使用add方法将元素加入到数组列表中</span></span><br><span class="line">      staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;binshow&quot;</span>,<span class="number">10000</span>,<span class="number">1997</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">      <span class="comment">//2. 如果调用add方法且内部数组已经满了，list将自动创建一个更大的数组</span></span><br><span class="line">      <span class="comment">//3. 如果已经清楚list数组中可能存储的元素数量，可以在填充数组之前用下面的 方法：</span></span><br><span class="line">      staff.ensureCapacity(<span class="number">100</span>); <span class="comment">// 直接分配一个可以包含100个对象的内部数组，不用重新分配空间</span></span><br><span class="line">      <span class="comment">// ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100); 或者构造的时候就传递容量进去</span></span><br><span class="line">  	  <span class="comment">//4. 获取list中第一个位置的元素</span></span><br><span class="line">      Employee employee = staff.get(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">//5. 移除list中第一个位置的元素</span></span><br><span class="line">      Employee remove = staff.remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>







<h2 id="对象包装器和自动装箱"><a href="#对象包装器和自动装箱" class="headerlink" title="对象包装器和自动装箱"></a>对象包装器和自动装箱</h2><ul>
<li><p>背景：有时候需要将基本类型转换成对象，所以所有的基本对象都有一个与之对应的类，比如int对应于Integer。</p>
</li>
<li><p>定义一个整型数组列表，尖括号的类型参数不允许是基本数据类型，所有就要用到包装类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//会发生编译错误</span></span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 这样才可以</span></span><br></pre></td></tr></table></figure></li>
<li><p>自动装箱和拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">3</span>); <span class="comment">// 等价于  list.add(Integer.valueOf(3)); 自动将基本数据类型转换成包装类型</span></span><br><span class="line">    <span class="keyword">int</span> n = list.get(<span class="number">0</span>); <span class="comment">// 等价于 int i = list.get(0).intValue(); 自动将包装类型转换成基本数据类型</span></span><br><span class="line">  </span><br><span class="line">    Integer n = <span class="number">3</span>;</span><br><span class="line">     n++; <span class="comment">//编译器会自动插入一个对象拆箱的指令再进行自增运算</span></span><br></pre></td></tr></table></figure></li>
<li><p>包装类型对象有一个<strong>常量缓冲池</strong>，比如Integer的缓冲范围为 -128 到 127</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer a = -<span class="number">129</span>;</span><br><span class="line">   Integer b = -<span class="number">129</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line">Integer a = -<span class="number">128</span>;</span><br><span class="line">   Integer b = -<span class="number">128</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">//true ，都是指向常量池中的对象</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">   Integer b = <span class="number">100</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">   Integer b = <span class="number">127</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">   Integer b = <span class="number">128</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>包装类型引用可以为null，所有自动拆箱可能会爆空指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">null</span>;</span><br><span class="line">   System.out.println(<span class="number">2</span> * n); <span class="comment">//NullPointerException</span></span><br></pre></td></tr></table></figure></li>
<li><p>自动装箱和拆箱是编译器认可的，也就是说<strong>编译器在生成类的字节码时会插入必要的方法调用</strong>。虚拟机只是执行这些字节码。</p>
</li>
</ul>
<h2 id="变参方法"><a href="#变参方法" class="headerlink" title="变参方法"></a>变参方法</h2><p>现在的Java支持用可变的参数数量调用的方法。</p>
<ul>
<li><p>print方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略号表示这个方法可以接受任意数量的对象</span></span><br><span class="line"><span class="comment">// 这里接受的是Object数组，来保存所有的参数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ul>
<li><p>举例: Size枚举类只有4个实例。不可能构造新的对象了，因此在比较两个枚举类型的值时，并不需要equals方法，直接用==就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE,</span><br><span class="line">    EXTRE_LARGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>枚举类可以增加构造器、方法和字段。构造器只是在构造枚举常量的时候调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>),</span><br><span class="line">    MEDIUM(<span class="string">&quot;M&quot;</span>),</span><br><span class="line">    LARGE(<span class="string">&quot;L&quot;</span>),</span><br><span class="line">    EXTRE_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation; <span class="comment">//缩写</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//枚举类的构造器总是私有的，因为不可能再构造新的对象了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每个枚举类型都有一个静态values方法，可以返回包含全部枚举值的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(Size.values())); <span class="comment">//[SMALL, MEDIUM, LARGE, EXTRE_LARGE]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;enter a size:(SMALL , MEDIUM , LARGE , EXTRE_LARGE)&quot;</span>);</span><br><span class="line">        String input = scanner.next().toUpperCase();</span><br><span class="line">        Size size = Enum.valueOf(Size.class, input); <span class="comment">//反向，通过字符串返回枚举类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;size = &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;abbreviation =:&quot;</span> + size.getAbbreviation());</span><br><span class="line">        <span class="keyword">if</span> (size == Size.EXTRE_LARGE) System.out.println(<span class="string">&quot;Good Job!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>可以利用反射编写能动态操作Java代码的程序。</p>
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象。</li>
</ol>
<p>Class类：在程序运行期间，java运行时系统始终为所有的对象维护一个运行时的类型标识。这个信息跟踪着每个对象所属的类，虚拟机可以利用运行时的类型信息选择相应的方法去执行。保存这些信息的类成为Class。Object类中的getClass对象就会返回一个Class类型的实例。</p>
<ul>
<li><p>获取Class类对象的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java运行时系统始终为每个对象维护一个运行时类型标识 ，这个信息保存为Class类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;binshow&quot;</span>,<span class="number">27000</span>,<span class="number">1997</span>,<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//1. 通过getClass() 获得 Class 对象会描述一个特定类的属性</span></span><br><span class="line">        Class&lt;? extends Employee&gt; cl = e.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;cl = &quot;</span> + cl.getName()); <span class="comment">//cl = chapter5.Employee</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 通过Class.forName 来获取类名对于的Class对象</span></span><br><span class="line">        String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        System.out.println(<span class="string">&quot;aClass = &quot;</span> + aClass.getName()); <span class="comment">//aClass = java.util.Random</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 直接通过后缀名获取</span></span><br><span class="line">        Class&lt;Random&gt; randomClass = Random.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;randomClass = &quot;</span> + randomClass.getName()); <span class="comment">//randomClass = java.util.Random</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;integerClass = &quot;</span> + integerClass.getName()); <span class="comment">// integerClass = int</span></span><br><span class="line">        Class&lt;<span class="keyword">int</span>[]&gt; aClass1 = <span class="keyword">int</span>[].class;</span><br><span class="line">        System.out.println(<span class="string">&quot;aClass1 = &quot;</span> + aClass1.getName()); <span class="comment">//aClass1 = [I 数组类型</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过Class类对象获取新的 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">   Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">   Object o = aClass.getConstructor().newInstance(); <span class="comment">//获取Class类的无参构造，再创建一个新的实例。如果没有无参构造则报错</span></span><br><span class="line">   System.out.println(o); <span class="comment">//java.util.Random@1b6d3586</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过放射来分析类的能力：Field、Method、Constructors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射来分析类的能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//java.lang.Double</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;enter the class name:&quot;</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(name);</span><br><span class="line">            Class&lt;?&gt; sc = cl.getSuperclass();</span><br><span class="line"></span><br><span class="line">            String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;className = &quot;</span> + cl.getName());</span><br><span class="line">            <span class="keyword">if</span> (sc != <span class="keyword">null</span> &amp;&amp; sc != Object.class) System.out.print(<span class="string">&quot; extends &quot;</span> + sc.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&#123;\n&quot;</span>);</span><br><span class="line">            printConstructor(cl);</span><br><span class="line">            printMethod(cl);</span><br><span class="line">            printFields(cl);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印所有的构造器方法及参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructor</span><span class="params">(Class cl)</span></span>&#123;</span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors(); <span class="comment">//getDeclared 表示所有的，没有的话就返回公有的</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            String name = c.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            String modifiers = Modifier.toString(c.getModifiers());</span><br><span class="line">            System.out.print(name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印参数类型</span></span><br><span class="line">            Class[] parameterTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                System.out.print(parameterTypes[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印类的所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethod</span><span class="params">(Class cl)</span></span>&#123;</span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            Class&lt;?&gt; returnType = m.getReturnType(); <span class="comment">//返回参数类型</span></span><br><span class="line">            String name = m.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line">            String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(returnType.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//打印参数类型</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                System.out.print(parameterTypes[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印类的所有字段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cl)</span></span>&#123;</span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            String modifies = Modifier.toString(f.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifies.length() &gt; <span class="number">0</span>) System.out.print(modifies + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(type.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>调用任意方法:和利用Field类的get方法查看对象域的过程类似，Method类中也有一个invoke方法，可以调用包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-8-继承的设计技巧"><a href="#5-8-继承的设计技巧" class="headerlink" title="5.8 继承的设计技巧"></a>5.8 继承的设计技巧</h2><ol>
<li>将公共操作和字段放在超类里面。比如姓名应该放在Person类中而不是Employee和Student中。</li>
<li>不要使用受保护的字段。</li>
<li>使用继承来实现“is a”的关系。</li>
<li>除非所有继承的方法都有意义，否则就不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。</li>
<li>使用多态而不要使用类型信息。</li>
<li>不要滥用放射。因为编译器无法帮助你查找编程错误，只有在运行时才会发生错误。</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>JavaSE(三)类的设计和继承</p><p><a href="http://example.com/2021/08/02/JavaSE-三-类的设计和继承/">http://example.com/2021/08/02/JavaSE-三-类的设计和继承/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-08-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaSE/">JavaSE</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/02/JavaSE-%E5%9B%9B-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JavaSE-四-接口与内部类</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/01/JavaSE-%E4%BA%8C-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"><span class="level-item">JavaSE(二)对象和类</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#继承"><span class="level-left"><span class="level-item">1</span><span class="level-item">继承</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多态"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">多态</span></span></a></li><li><a class="level is-mobile" href="#理解方法调用"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">理解方法调用</span></span></a></li><li><a class="level is-mobile" href="#如何阻止继承：final类和方法"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">如何阻止继承：final类和方法</span></span></a></li><li><a class="level is-mobile" href="#强制类型转换"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">强制类型转换</span></span></a></li><li><a class="level is-mobile" href="#抽象类"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">抽象类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Object：所有类的超类"><span class="level-left"><span class="level-item">2</span><span class="level-item">Object：所有类的超类</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#equals方法"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">equals方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#equals方法中继承关系的处理"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">equals方法中继承关系的处理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hashCode方法"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">hashCode方法</span></span></a></li><li><a class="level is-mobile" href="#toString方法"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">toString方法</span></span></a></li></ul><li><a class="level is-mobile" href="#泛型数组列表ArrayList"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">泛型数组列表ArrayList</span></span></a></li><li><a class="level is-mobile" href="#对象包装器和自动装箱"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">对象包装器和自动装箱</span></span></a></li><li><a class="level is-mobile" href="#变参方法"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">变参方法</span></span></a></li><li><a class="level is-mobile" href="#枚举类"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">枚举类</span></span></a></li><li><a class="level is-mobile" href="#反射"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">反射</span></span></a></li><li><a class="level is-mobile" href="#5-8-继承的设计技巧"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">5.8 继承的设计技巧</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">57</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-06T05:26:00.000Z">2021-10-06</time></p><p class="title"><a href="/2021/10/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">操作系统（二）进程和线程</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-06T05:23:49.000Z">2021-10-06</time></p><p class="title"><a href="/2021/10/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/">操作系统（一）概述</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-29T13:24:51.000Z">2021-09-29</time></p><p class="title"><a href="/2021/09/29/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%80-%E9%93%BE%E8%A1%A8/">算法题(一)链表</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-06T14:52:13.000Z">2021-09-06</time></p><p class="title"><a href="/2021/09/06/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84/">MySQL（三）文件和表结构</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-28T02:24:14.000Z">2021-08-28</time></p><p class="title"><a href="/2021/08/28/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%94%81/">Java并发（一）内存模型和锁</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>