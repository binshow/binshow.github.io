<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java并发（一）内存模型和锁 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="主要讲述了  并发编程的发展历程 解决可见性和有序性 解决原子性 死锁 等待通知"><meta property="og:type" content="blog"><meta property="og:title" content="Java并发（一）内存模型和锁"><meta property="og:url" content="http://example.com/2021/08/28/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%94%81/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="主要讲述了  并发编程的发展历程 解决可见性和有序性 解决原子性 死锁 等待通知"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/Java%E5%B9%B6%E5%8F%911.jpeg"><meta property="article:published_time" content="2021-08-28T02:24:14.000Z"><meta property="article:modified_time" content="2021-08-31T14:12:25.166Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="Java并发"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/Java%E5%B9%B6%E5%8F%911.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/08/28/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%94%81/"},"headline":"Java并发（一）内存模型和锁","image":[],"datePublished":"2021-08-28T02:24:14.000Z","dateModified":"2021-08-31T14:12:25.166Z","author":{"@type":"Person","name":"binshow"},"description":"主要讲述了  并发编程的发展历程 解决可见性和有序性 解决原子性 死锁 等待通知"}</script><link rel="canonical" href="http://example.com/2021/08/28/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%94%81/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Java%E5%B9%B6%E5%8F%911.jpeg" alt="Java并发（一）内存模型和锁"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-28T02:24:14.000Z" title="2021/8/28上午10:24:14">2021-08-28</time>发表</span><span class="level-item"><time dateTime="2021-08-31T14:12:25.166Z" title="2021/8/31下午10:12:25">2021-08-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约7942个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java并发（一）内存模型和锁</h1><div class="content"><p>主要讲述了</p>
<ul>
<li>并发编程的发展历程</li>
<li>解决可见性和有序性</li>
<li>解决原子性</li>
<li>死锁</li>
<li>等待通知</li>
</ul>
<span id="more"></span>



<h1 id="并发编程的发展历程"><a href="#并发编程的发展历程" class="headerlink" title="并发编程的发展历程"></a>并发编程的发展历程</h1><h2 id="并发编程问题的由来"><a href="#并发编程问题的由来" class="headerlink" title="并发编程问题的由来"></a>并发编程问题的由来</h2><p>随着<strong>CPU 、 内存 、IO设备</strong>的不断发展，三者的速度差异一直是存在的（CPU一天 ， 内存一年 ， IO设备十年）</p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ol>
<li><strong>CPU 增加了缓存</strong>，以均衡与内存的速度差异；</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用</li>
</ol>
<h3 id="1-1-缓存导致的可见性问题"><a href="#1-1-缓存导致的可见性问题" class="headerlink" title="1.1 缓存导致的可见性问题"></a>1.1 缓存导致的可见性问题</h3><blockquote>
<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p>
</blockquote>
<p>单核时代，电脑只有1个CPU，所有的线程操作的是同一个CPU的缓存，也就不存在可见性问题。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210828103413.png" alt="20210828103413"></p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，如下图线程A对变量V的操作线程B就看不到了。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210828103551.png" alt="20210828103551"></p>
<p>比如下面这个代码：两个线程同时对变量count 进行2000次++操作。最后count的值一定&lt;=4000（由于线程操作的不可见性带来的操作覆盖）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx++ &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HelloWorld test = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.add();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test.add();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">        th1.join();</span><br><span class="line">        th2.join();</span><br><span class="line">        <span class="keyword">return</span> test.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> c =calc();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-线程切换带来的原子性问题"><a href="#1-2-线程切换带来的原子性问题" class="headerlink" title="1.2 线程切换带来的原子性问题"></a>1.2 线程切换带来的原子性问题</h3><blockquote>
<p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong></p>
</blockquote>
<p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。</p>
<p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p>
<p>Java并发程序都是基于多线程的，也就会涉及到任务切换。一般来说任务切换的时机大多数都是在一个时间片结束的时候，但是在Java这种高级语言中，一个语句往往需要多个CPU指令来执行。比如上面代码中的<code>count += 1</code>，至少需要三条 CPU 指令。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）</li>
</ul>
<p>操作系统进行任务切换的时候，发生在任何一个<strong>CPU指令</strong>执行完之后，而不是可见的Java语言后。如下这种情况线程A就会把线程B执行的count+=1覆盖了。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210828104809.png" alt="20210828104809"></p>
<h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h3><p>有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会进行指令重排序。</p>
<p>重排序分3种类型。 </p>
<ol>
<li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p>指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p>
</li>
<li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上 去可能是在乱序执行</p>
</li>
</ol>
<p>例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果，但是有时会出现问题。</p>
<p>比如单例模式中的双重检验模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// a</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">                  instance = <span class="keyword">new</span> Singleton(); <span class="comment">//在CPU指令上并不是一步操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解释一下这个双重校验模式：</span></span><br><span class="line"><span class="comment">假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null (同时执行到a处代码) ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">线程 A 会创建一个Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</span></span><br></pre></td></tr></table></figure>

<p>看起来是没问题，但实际上还存在瑕疵，因为new一个新的对象分为如下几步（先在内存中初始化对象再赋值给变量）：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>经过指令重排序变成了下面这种情况（先将内存赋值给变量再进行初始化）：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ol>
<p>不安全的情况：假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210828105933.png" alt="20210828105933"></p>
<h1 id="解决可见性和有序性"><a href="#解决可见性和有序性" class="headerlink" title="解决可见性和有序性"></a>解决可见性和有序性</h1><p>导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>。虽然可以解决问题，但是程序的性能会受到很大影响，因此，最合理的方式应该是<strong>按需禁用缓存以及编译优化</strong>。何谓按需，按照程序的要求来进行禁用。</p>
<h3 id="使用volatile"><a href="#使用volatile" class="headerlink" title="使用volatile"></a>使用volatile</h3><p>volatile在C语言中也存在，它的原始意义就是禁用CPU缓存。</p>
<blockquote>
<p>声明一个 volatile 变量 volatile int x = 0，它表达的是：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。</p>
</blockquote>
<h3 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a><strong>Happens-Before</strong> <strong>规则</strong></h3><p>它想表达的是：<strong>前面一个操作的结果对后续的操作是可见的</strong>。Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 HappensBefore 规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	x = <span class="number">42</span>; <span class="comment">// a</span></span><br><span class="line">	 	v = <span class="keyword">true</span>; <span class="comment">// b</span></span><br><span class="line">	&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123; <span class="comment">// c</span></span><br><span class="line"> 		<span class="comment">// 这里 x 会是多少呢？</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程 A 执行 writer() 方法，按照 volatile 语义，会把变量“v=true” 写入内存；假设线程 B 执行 reader() 方法，同样按照 volatile 语义，线程 B会从内存中读取变量 v，如果线程 B 看到 “v == true” 时，那么线程 B 看到的变量 x 是多少呢？</p>
<h4 id="同一线程的顺序性规则"><a href="#同一线程的顺序性规则" class="headerlink" title="同一线程的顺序性规则"></a>同一线程的顺序性规则</h4><p>指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。比如上面的代码 x = 42  Happens-Before 于代码 “v = true;”.</p>
<h4 id="volatile-变量规则"><a href="#volatile-变量规则" class="headerlink" title="volatile 变量规则"></a><strong>volatile</strong> <strong>变量规则</strong></h4><p>对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</p>
<h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a><strong>传递性</strong></h4><p>指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。将这个规则和上面的volatile规则结合就能得到问题的答案：</p>
<p>a 对b 可见 ， b是对volatile变量的写操作，所有b对c可见。 — 也就是  a 对c可见，所以 读出来是42。</p>
<h4 id="管程中锁的规则"><a href="#管程中锁的规则" class="headerlink" title="管程中锁的规则"></a><strong>管程中锁的规则</strong></h4><p>指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>
<blockquote>
<p><strong>管程</strong>是一种通用的同步原语，在Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p>
</blockquote>
<h4 id="线程-start-规则"><a href="#线程-start-规则" class="headerlink" title="线程 start() 规则"></a><strong>线程</strong> <strong>start()</strong> <strong>规则</strong></h4><p>主线程A启动子线程B后，子线程B可以看到主线程在启动子线程B之前的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> <span class="comment">// 主线程调用 B.start() 之前</span></span><br><span class="line"> <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line"> <span class="comment">// 此例中，var==77</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"> <span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"> <span class="comment">// 主线程启动子线程</span></span><br><span class="line"> B.start();</span><br></pre></td></tr></table></figure>



<h4 id="线程Join-规则"><a href="#线程Join-规则" class="headerlink" title="线程Join()规则"></a>线程Join()规则</h4><p>指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p>
<p>换句话说：如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"> <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"> <span class="comment">// 则这个修改结果对线程 B 可见</span></span><br><span class="line"> <span class="comment">// 主线程启动子线程</span></span><br><span class="line"> B.start();</span><br><span class="line"></span><br><span class="line"> B.join()</span><br><span class="line"> <span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"> <span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"> <span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure>



<h3 id="使用final关键字"><a href="#使用final关键字" class="headerlink" title="使用final关键字"></a>使用final关键字</h3><p><strong>final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</strong>Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了。</p>
<h1 id="解决原子性"><a href="#解决原子性" class="headerlink" title="解决原子性"></a>解决原子性</h1><p>原子性问题的源头是<strong>线程切换</strong>，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。在早期单核 CPU 时代，这个方案的确是可行的。但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。</p>
<p><strong>同一时刻只有一个线程执行</strong>”这个条件非常重要，我们称之为<strong>互斥</strong></p>
<p>简易锁模型：</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829103717.png" alt="20210829103717"></p>
<p>改进后：锁是用来保护资源的：</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829103807.png" alt="20210829103807"></p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><p><strong>synchronized</strong>既可以修饰方法，也可以修饰代码块。Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的。</p>
<blockquote>
<p>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；</p>
<p>当修饰非静态方法的时候，锁定的是当前实例对象 this。</p>
<p>修饰代码块：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 修饰非静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 临界区</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 修饰静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 临界区</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 修饰代码块</span></span><br><span class="line">   Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">   <span class="comment">// 临界区</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 synchronized 修饰后，无论是单核CPU 还是多核 CPU，只有一个线程能够执行addOne方法,也就说如果有 1000 个线程执行 addOne() 方法，最终结果一定是 value 的值增加了 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 addOne() 方法后，value 的值对 get() 方法是可见的吗？这个可见性是没法保证的。管程中锁的规则，是只保证后续对这个锁的加锁的可见性，而 get() 方法并没有加锁操作，所以可见性没法保证。那如何解决呢？很简单，就是 get() 方法也 synchronized 一下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话 get 和addone方法也是互斥的。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829104817.png" alt="20210829104817"></p>
<blockquote>
<p>这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是 Java 类里的方法，而门票就是用来保护资源的“锁”，Java 里的检票工作是由 synchronized 解决的。</p>
</blockquote>
<h2 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a><strong>锁和受保护资源的关系</strong></h2><p><strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong>.可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话就是两个锁锁的是同一个资源：两个锁分别是 this 和 SafeCalc.class。由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥</p>
<p>关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829110018.png" alt="20210829110018"></p>
<p><strong>锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁 / 解锁，就属于设计层面的事情了。</strong></p>
<h2 id="如何用一把锁来保护多个资源"><a href="#如何用一把锁来保护多个资源" class="headerlink" title="如何用一把锁来保护多个资源"></a>如何用一把锁来保护多个资源</h2><h3 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a><strong>保护没有关联关系的多个资源</strong></h3><p>例如，银行业务中有针对账户余额（余额是一种资源）的取款操作，也有针对账户密码（密码也是一种资源）的更改操作，我们可以为账户余额和账户密码分配不同的锁来解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengbinbin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 保护没有关联关系的多个资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object balLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//账户余额</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁：保护账户密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 账户密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (balLock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (balLock)&#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更改密码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pwLock)&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = pw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查看密码</span></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pwLock)&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用一把互斥锁来保护多个资源，例如我们可以用 this 这一把锁来管理账户类里所有的资源：账户余额和用户密码.就是性能太差，会导致取款、查看余额、修改密码、查看密码这四个操作都是串行的。</p>
<p>我们用两把锁，取款和修改密码是可以并行的。<strong>用不同的锁对受保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p>
<h3 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a><strong>保护有关联关系的多个资源</strong></h3><p>例如银行业务里面的转账操作，账户 A 减少 100 元，账户 B 增加 100 元。这两个账户就是有关联关系的。那对于像转账这种有关联关系的操作，我们应该怎么去解决呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="comment">//怎么保证转账操作 transfer() 没有并发问题呢</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target , <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果简单的用synchronize来修饰这个方法并不能解决并发问题，为什么呢？</p>
<p>临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this。问题是这把锁可以保护自己的 余额，怎么保护别人的余额呢？</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829112053.png" alt="20210829112053"></p>
<blockquote>
<p>下面我们具体分析一下，假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：</p>
<p>账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，</p>
<p>最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是300元。</p>
<p>我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？</p>
<p>我们期望是，但实际上并不是。</p>
<p>因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？</p>
<p>线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），</p>
<p>可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829112043.png" alt="20210829112043"></p>
</blockquote>
<p>如何解决这个问题呢？</p>
<p>只要我们的<strong>锁能覆盖所有受保护资源</strong>就可以了</p>
<p>this 是对象级别的锁，所以 A 对象和 B 对象都有自己的锁，如何让 A 对象和 B 对象共享一把锁呢？</p>
<p>方案1：把 Account 默认构造函数变为 private，同时增加一个带 Object lock 参数的构造函数，创建 Account 对象时，传入相同的 lock，这样所有的 Account 对象都会共享这个lock 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Object lock； </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">// 创建 Account 时传入同一个 lock 对象</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.lock = lock;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">// 转账</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line"> <span class="comment">// 此处检查所有对象共享的锁</span></span><br><span class="line"> <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line"> <span class="keyword">this</span>.balance -= amt;</span><br><span class="line"> target.balance += amt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它要求在创建 Account 对象的时候必须传入同一个对象，如果创建 Account 对象时，传入的 lock 不是同一个对象，会出现锁自家门来保护他家资产的荒唐事</p>
<p>方案2：<strong>用</strong>Account.class 作为共享的锁。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="comment">//怎么保证转账操作 transfer() 没有并发问题呢</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target , <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (Account.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">                <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                target.balance += amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：会导致所有转账都是串行的。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829112642.png" alt="20210829112642"></p>
<blockquote>
<p>总结：对如何保护多个资源已经很有心得了，关键是要分析多个资源之间的关系。如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。</p>
</blockquote>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在古代的时候，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况：</p>
<ol>
<li><p>文件架上恰好有转出账本和转入账本，那就同时拿走；</p>
</li>
<li><p>如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；</p>
</li>
<li><p>转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</p>
</li>
</ol>
<p>类比到现在的模型，其实就是两把锁：转出账本 和 转入账本。在 transfer() 方法内部，我们首先尝试<strong>锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手）</strong>，只有当两者都成功时，才执行转账操作。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20210829142515.png" alt="转账操作并行示意图"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengbinbin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 转账</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target , <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 先锁定转出账号</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123; <span class="comment">//①</span></span><br><span class="line">            <span class="comment">//2. 再锁定转入的账号</span></span><br><span class="line">            <span class="keyword">synchronized</span> (target)&#123; <span class="comment">//②</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样的话，我们只需要锁定两个账户就行了，而不是锁定Account.class。锁的粒度更小了，并发度更高了。但是我们需要警惕死锁的发生：</p>
<h2 id="出现死锁"><a href="#出现死锁" class="headerlink" title="出现死锁"></a>出现死锁</h2><p>如果有客户找柜员张三做个转账业务：账户 A 转账户 B 100 元</p>
<p>此时另一个客户找柜员李四也做个转账业务：账户 B转账户 A 100 元，</p>
<p>于是张三和李四同时都去文件架上拿账本，这时候有可能凑巧张三拿到了账本 A，李四拿到了账本 B。张三拿到账本 A 后就等着账本 B（账本 B 已经被李四拿走），而李四拿到账本 B 后就等着账本 A（账本 A 已经被张三拿走），他们要等多久呢？</p>
<p>他们会永远等待下去…因为张三不会把账本 A 送回去，李四也不会把账本 B 送回去。这就是死锁。</p>
<p><strong>死锁</strong>的一个比较专业的定义是：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>
<p>比较上面的代码可知：</p>
<p>当 T1 和 T2 同时执行完①处的代码时，T1 获得了账户 A 的锁（对于 T1，this 是账户A），而 T2 获得了账户 B 的锁（对于 T2，this 是账户 B）。之后 T1 和 T2 在执行②处的代码时，T1 试图获取账户 B 的锁时，发现账户 B 已经被锁定（被 T2 锁定），所以 T1 开始等待；T2 则试图获取账户 A 的锁时，发现账户 A 已经被锁定（被 T1 锁定），所以 T2也开始等待。于是 T1 和 T2 会无期限地等待下去，也就是我们所说的死锁了。</p>
<h2 id="死锁的条件及预防"><a href="#死锁的条件及预防" class="headerlink" title="死锁的条件及预防"></a>死锁的条件及预防</h2><p>死锁发生的四个条件：</p>
<ol>
<li><strong>互斥，共享资源 X 和 Y 只能被一个线程占用；</strong></li>
<li><strong>占有且等待</strong>，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li><strong>不可抢占</strong>，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li><strong>循环等待</strong>，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ol>
<p>破坏这4个条件：</p>
<ol>
<li><p>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</p>
</li>
<li><p>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p>
</li>
<li><p>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的</p>
</li>
</ol>
<p>如何实践：</p>
<ol>
<li>可以增加一个账本管理员，只有账本 A 和 B 都在的时候才会给张三，也就是<strong>一次性申请所有的资源</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengbinbin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 账本管理员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/292:39 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性申请所有的资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Object from , Object to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (als.contains(from) || als.contains(to))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            als.add(from);</span><br><span class="line">            als.add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from , Object to)</span></span>&#123;</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="keyword">private</span> Allocator allocator; <span class="comment">// 必须为单例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target , <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!allocator.apply(target,<span class="keyword">this</span>))&#123;</span><br><span class="line">            <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">          	<span class="comment">// 死循环</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先锁定转出账号</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="comment">//2. 再锁定转入的账号</span></span><br><span class="line">                <span class="keyword">synchronized</span> (target)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">                        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            allocator.free(<span class="keyword">this</span>,target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>破坏不可抢占条件: 这一点synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。在java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题的。</li>
<li><strong>破坏循环等待条件</strong>：破坏这个条件，需要对资源进行排序，然后按序申请资源。申请的时候，我们可以按照从小到大的顺序来申请:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target , <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        Account left = <span class="keyword">this</span>;</span><br><span class="line">        Account right = target;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id  &gt; target.id)&#123;</span><br><span class="line">            left = target;</span><br><span class="line">            right = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先锁序号小的账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (left)&#123;</span><br><span class="line">            <span class="comment">// 再锁序号大的账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如上面转账那个例子，我们破坏占用且等待条件的成本就比破坏循环等待条件的成本高，破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环 while(!actr.apply(this, target));方法，不过好在 apply() 这个方法基本不耗时。 在转账这个例子中，破坏循环等待条件就是成本最低的一个方案。</p>
<h1 id="等待通知机制"><a href="#等待通知机制" class="headerlink" title="等待通知机制"></a>等待通知机制</h1><h2 id="现实中的等待通知例子"><a href="#现实中的等待通知例子" class="headerlink" title="现实中的等待通知例子"></a>现实中的等待通知例子</h2><p>去医院就诊：</p>
<ol>
<li>患者先去挂号，然后到就诊门口分诊，等待叫号。这一步就是线程要去获取互斥锁，叫到号意味着线程已经获得锁了。</li>
<li>就诊过程中，大夫可能会让患者去做检查。这一步类似的就是线程的条件没有得到满足。</li>
<li>患者去做检查。这一步就是线程进入等待状态。</li>
<li>大夫叫下一个患者。这一步就是上一个线程释放了互斥锁。</li>
<li>患者做完检查。 这一步就是线程的条件重新满足了。</li>
<li>患者拿到检查报告重新去分诊等待较好。这一步就是这个线程要重新去获取锁。</li>
</ol>
<p>综合一下，就可以得出<strong>一个完整的等待 - 通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件</strong></p>
<p>满足时，通知等待的线程，重新获取互斥锁。 </p>
<h2 id="用synchronized来实现等待通知"><a href="#用synchronized来实现等待通知" class="headerlink" title="用synchronized来实现等待通知"></a>用synchronized来实现等待通知</h2><p><img src="https://raw.githubusercontent.com/binshow/img/master/20210831215727.png" alt="进入等待队列"></p>
<p><strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。</strong></p>
<p>因为<strong>notify() 只能保证在通知时间点，条件是满足的</strong>。而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性申请所有的资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Object from , Object to)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里用while可以避免虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (als.contains(from) || als.contains(to))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        als.add(from);</span><br><span class="line">        als.add(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from , Object to)</span></span>&#123;</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意这里尽量用notifyAll 唤醒线程而不是notify</span></span><br><span class="line"><span class="comment">         * 因为notify会随机的通知等待队列中的一个线程，这样的话会蕴含一些风险：可能导致某些线程永远不会被通知到。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申</span></span><br><span class="line"><span class="comment">         * 请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请</span></span><br><span class="line"><span class="comment">         * CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知</span></span><br><span class="line"><span class="comment">         * 等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还</span></span><br><span class="line"><span class="comment">         * 是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>Java并发（一）内存模型和锁</p><p><a href="http://example.com/2021/08/28/Java并发（一）内存模型和锁/">http://example.com/2021/08/28/Java并发（一）内存模型和锁/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-28</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-08-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/06/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL（三）索引</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AE%A1%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"><span class="level-item">Java并发（二）管程和线程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">89</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#并发编程的发展历程"><span class="level-left"><span class="level-item">1</span><span class="level-item">并发编程的发展历程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并发编程问题的由来"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">并发编程问题的由来</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-缓存导致的可见性问题"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">1.1 缓存导致的可见性问题</span></span></a></li><li><a class="level is-mobile" href="#1-2-线程切换带来的原子性问题"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">1.2 线程切换带来的原子性问题</span></span></a></li><li><a class="level is-mobile" href="#编译优化带来的有序性问题"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">编译优化带来的有序性问题</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#解决可见性和有序性"><span class="level-left"><span class="level-item">2</span><span class="level-item">解决可见性和有序性</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#使用volatile"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">使用volatile</span></span></a></li><li><a class="level is-mobile" href="#Happens-Before-规则"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">Happens-Before 规则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同一线程的顺序性规则"><span class="level-left"><span class="level-item">2.1.2.1</span><span class="level-item">同一线程的顺序性规则</span></span></a></li><li><a class="level is-mobile" href="#volatile-变量规则"><span class="level-left"><span class="level-item">2.1.2.2</span><span class="level-item">volatile 变量规则</span></span></a></li><li><a class="level is-mobile" href="#传递性"><span class="level-left"><span class="level-item">2.1.2.3</span><span class="level-item">传递性</span></span></a></li><li><a class="level is-mobile" href="#管程中锁的规则"><span class="level-left"><span class="level-item">2.1.2.4</span><span class="level-item">管程中锁的规则</span></span></a></li><li><a class="level is-mobile" href="#线程-start-规则"><span class="level-left"><span class="level-item">2.1.2.5</span><span class="level-item">线程 start() 规则</span></span></a></li><li><a class="level is-mobile" href="#线程Join-规则"><span class="level-left"><span class="level-item">2.1.2.6</span><span class="level-item">线程Join()规则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用final关键字"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">使用final关键字</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#解决原子性"><span class="level-left"><span class="level-item">3</span><span class="level-item">解决原子性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#synchronized"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">synchronized</span></span></a></li><li><a class="level is-mobile" href="#锁和受保护资源的关系"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">锁和受保护资源的关系</span></span></a></li><li><a class="level is-mobile" href="#如何用一把锁来保护多个资源"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">如何用一把锁来保护多个资源</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#保护没有关联关系的多个资源"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">保护没有关联关系的多个资源</span></span></a></li><li><a class="level is-mobile" href="#保护有关联关系的多个资源"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">保护有关联关系的多个资源</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#死锁"><span class="level-left"><span class="level-item">4</span><span class="level-item">死锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#出现死锁"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">出现死锁</span></span></a></li><li><a class="level is-mobile" href="#死锁的条件及预防"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">死锁的条件及预防</span></span></a></li></ul></li><li><a class="level is-mobile" href="#等待通知机制"><span class="level-left"><span class="level-item">5</span><span class="level-item">等待通知机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#现实中的等待通知例子"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">现实中的等待通知例子</span></span></a></li><li><a class="level is-mobile" href="#用synchronized来实现等待通知"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">用synchronized来实现等待通知</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">79</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-11T02:36:47.000Z">2021-10-11</time></p><p class="title"><a href="/2021/10/11/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">算法题（九）栈和队列</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T16:43:12.000Z">2021-10-11</time></p><p class="title"><a href="/2021/10/11/Redis%EF%BC%88%E5%85%AB%EF%BC%89%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">Redis（八）缓存问题</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T12:51:32.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">操作系统（四）网络管理</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T12:51:21.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E5%92%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">操作系统（三）文件和设备管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T06:17:47.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E5%85%AB%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">算法题（八）滑动窗口</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>