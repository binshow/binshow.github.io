<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM（一）内存区域和对象详解 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java是一门可以跨平台的语言，主要就是通过Java虚拟机来实现的: 编译器将Java文件编译为Java字节码文件（.class），接下来JVM对字节码文件进行解释，翻译成特定底层平台匹配的机器指令(win&amp;#x2F;linux&amp;#x2F;mac)并运行。"><meta property="og:type" content="blog"><meta property="og:title" content="JVM（一）内存区域和对象详解"><meta property="og:url" content="http://example.com/2021/05/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="Java是一门可以跨平台的语言，主要就是通过Java虚拟机来实现的: 编译器将Java文件编译为Java字节码文件（.class），接下来JVM对字节码文件进行解释，翻译成特定底层平台匹配的机器指令(win&amp;#x2F;linux&amp;#x2F;mac)并运行。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/JVM.png"><meta property="article:published_time" content="2021-05-10T14:41:04.000Z"><meta property="article:modified_time" content="2021-05-10T15:37:34.335Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/JVM.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"},"headline":"JVM（一）内存区域和对象详解","image":["http://example.com/gallery/covers/JVM.png"],"datePublished":"2021-05-10T14:41:04.000Z","dateModified":"2021-05-10T15:37:34.335Z","author":{"@type":"Person","name":"binshow"},"description":"Java是一门可以跨平台的语言，主要就是通过Java虚拟机来实现的: 编译器将Java文件编译为Java字节码文件（.class），接下来JVM对字节码文件进行解释，翻译成特定底层平台匹配的机器指令(win&#x2F;linux&#x2F;mac)并运行。"}</script><link rel="canonical" href="http://example.com/2021/05/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/JVM.png" alt="JVM（一）内存区域和对象详解"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-10T14:41:04.000Z" title="2021/5/10下午10:41:04">2021-05-10</time>发表</span><span class="level-item"><time dateTime="2021-05-10T15:37:34.335Z" title="2021/5/10下午11:37:34">2021-05-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">44 分钟读完 (大约6549个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM（一）内存区域和对象详解</h1><div class="content"><p><strong>Java是一门可以跨平台的语言，主要就是通过Java虚拟机来实现的</strong>:</p>
<p>编译器将Java文件编译为Java字节码文件（.class），接下来JVM对字节码文件进行解释，翻译成特定底层平台匹配的机器指令(win/linux/mac)并运行。</p>
<span id="more"></span>

<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>Java虚拟机定义了若干程序运行时的数据区，分为线程私有和公有的:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2873cf0403e409a96846de9e2d21b58~tplv-k3u1fbpfcp-zoom-1.image" alt="Java虚拟机运行时数据区"></p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。</p>
<ol>
<li><p>可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</li>
<li><p><strong>线程私有的</strong>，在任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法。</p>
<blockquote>
<p>程序计数器是唯一一个在虚拟机规范中没有规定<code>OutOfMemoryError</code>的区域</p>
</blockquote>
</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p>
<ol>
<li>每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
</ol>
<p><strong>局部变量表</strong>存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。</p>
<p>虚拟机栈会发生以下两种异常：</p>
<ol>
<li>如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量时，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p>会发生的异常和虚拟机栈相同</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>Java里“几乎”所有的对象实例都在这里分配内存</strong>。</p>
<p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，需要注意的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cdb3a6f4fc486ea9c007863af48f04~tplv-k3u1fbpfcp-zoom-1.image" alt="Java 堆内存结构"></p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c932ae71e514e4db636eae59d8be13c~tplv-k3u1fbpfcp-zoom-1.image" alt="方法区"></p>
<p>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种<strong>字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p><strong>Class文件经过类加载器加载后，之前Class文件常量池的内容会存放到方法区的运行时常量池，需要注意的是Class文件常量池的符号引用会转变直接引用存入运行时常量池。</strong></p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。</p>
<h2 id="JDK的内存演变"><a href="#JDK的内存演变" class="headerlink" title="JDK的内存演变"></a>JDK的内存演变</h2><ul>
<li><p>JDK1.6时期和我们上面讲的JVM内存区域是一致的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5415f07fc3481ea461cb8135bf2f21~tplv-k3u1fbpfcp-zoom-1.image" alt="JDK 1.6内存区域"></p>
</li>
<li><p>JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121e808843f74abdb5023953cc13f196~tplv-k3u1fbpfcp-zoom-1.image" alt="JDK 1.7内存区域"></p>
<ul>
<li>在JDK1.8时彻底干掉了方法区，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/183ec83c9bbf4816a7070e830d817881~tplv-k3u1fbpfcp-zoom-1.image" alt="JDK 1.8内存区域"></p>
<p>思考一下，为什么使用元空间替换永久代？ </p>
<p>表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。 当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。 更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。</p>
<h2 id="哪些地方会发生OOM"><a href="#哪些地方会发生OOM" class="headerlink" title="哪些地方会发生OOM"></a>哪些地方会发生OOM</h2><ol>
<li><p>堆内存不足是最常见的OOM原因之一，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</p>
</li>
<li><p>对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</p>
</li>
<li><p>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</p>
</li>
<li><p>直接内存不足，也会导致OOM。</p>
</li>
</ol>
<h2 id="对象的创建都是在堆上吗"><a href="#对象的创建都是在堆上吗" class="headerlink" title="对象的创建都是在堆上吗"></a>对象的创建都是在堆上吗</h2><p>我注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<h2 id="字符串常量池的底层原理"><a href="#字符串常量池的底层原理" class="headerlink" title="字符串常量池的底层原理"></a>字符串常量池的底层原理</h2><p>字符串常量池是<strong>全局的，<code>JVM</code> 中独此一份</strong>，因此也称为全局字符串常量池，在 <code>jdk1.7（含）</code>之后是在堆内存之中，<strong>存储的是字符串对象的引用，字符串实例是在堆中；</strong></p>
<p>在<code>HotSpot VM</code>里实现线程池功能的是一个<code>StringTable</code>类，它是一个Hash表，默认值大小长度是1009；这个<code>StringTable</code>在每个<code>HotSpot VM</code>的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了<code>StringTable</code>上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;图解Java&quot;</span>; <span class="comment">//先到常量池中查询有没有`&quot;图解Java&quot;`字符串的引用，如果没有，则会在`Java堆`上创建`&quot;图解Java&quot;`字符串，在常量池中存储字符串的地址，`str1`则指向字符串常量池的地址</span></span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;图解Java&quot;</span>);<span class="comment">//直接在Java堆中创建对象。`str2`指向堆中的地址。</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;图解Java&quot;</span>; <span class="comment">//str3发现字符串常量池中已经有了`&quot;图解Java&quot;`字符串的引用，则直接返回，不会创建新的对象</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/3/6/170af1780d2c7f1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>JVM</code>中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 <code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code> 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。</p>
<h1 id="Java对象详解"><a href="#Java对象详解" class="headerlink" title="Java对象详解"></a>Java对象详解</h1><h2 id="创建对象的4种方式"><a href="#创建对象的4种方式" class="headerlink" title="创建对象的4种方式"></a>创建对象的4种方式</h2><ul>
<li><p>new 关键字：</p>
<ol>
<li>在方法区的常量池中查看是否有new 后面参数（也就是类名）的符号引用，并检查是否有类的加载信息也就是是否被加载解析和初始化过。如果已经加载过了就不在加载，否则执行类的加载全过程。</li>
<li><strong>给实例分配内存</strong>：此内存中存放对象自己的实例变量和从父类继承过来的实例变量（即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间），同时这些实例变量被赋予默认值（零值）；</li>
<li> <strong>调用构造函数，初始化成员字段</strong>：在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是<strong>实例变量初始化</strong>、<strong>实例代码块初始化</strong>以及<strong>构造函数初始化</strong>；</li>
<li> <strong>user对象指向分配的内存空间： 注意：new操作不是原子操作，b和c的顺序可能会调换</strong>。</li>
</ol>
</li>
<li><p>clone方法创建对象：</p>
<ol>
<li>要想让一个对象支持clone，必须让这个对象对应的类实现Cloneable接口（标识接口），同时此类中也要重写clone方法</li>
<li>clone()方法是属于Object类的，clone是在堆内存中用二进制的方式进行拷贝，重新分配给对象一块内存</li>
</ol>
</li>
<li><p>反射创建对象：</p>
<ol>
<li><p>获取类的Class对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取方式如下：</span><br><span class="line">Class.forName(<span class="string">&quot;类全路径&quot;</span>);</span><br><span class="line">类名.class; 如：Animal.class;</span><br><span class="line">对象名.getClass();</span><br></pre></td></tr></table></figure></li>
<li><p>通过反射创建类对象的实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.newInstance()：调用无参的构造方法，必需确保类中有无参数的可见的构造函数，否则将会抛出异常；</span><br></pre></td></tr></table></figure></li>
<li><p>强制转换成用户所需类型</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>Java 反射机制是指在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种<strong>动态的获取信息</strong>以及<strong>动态调用对象的方法</strong>的功能称为<strong>java 的反射机制</strong>。 反射机制很重要的一点就是“<strong>运行时</strong>”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）</p>
</blockquote>
<ul>
<li>反序列化创建对象<ol>
<li>Java中要序列化的类必须实现Serializable接口；</li>
<li>所有可在网络上传输的对象都必须是可序列化的；如RMI（remote method invoke，即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；</li>
<li>所有需要保存到磁盘的java对象都必须是可序列化的；通常建议：程序创建的每个JavaBean类都实现Serializeable接口；</li>
</ol>
</li>
</ul>
<h2 id="New对象创建过程"><a href="#New对象创建过程" class="headerlink" title="New对象创建过程"></a>New对象创建过程</h2><p>我们以虚拟机遇到一个new指令开始：</p>
<ul>
<li><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</p>
</li>
<li><p>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</p>
</li>
<li><p>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</p>
<p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）</p>
<ul>
<li>指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”</li>
<li>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</li>
<li>两种方式的选择由Java堆是否规整决定</li>
<li>Java堆规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定</li>
</ul>
</li>
<li><p>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</p>
</li>
<li><p>设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029dc326a3f84f1d9902eca81addc1ce~tplv-k3u1fbpfcp-zoom-1.image" alt="对象创建过程"></p>
<p>从虚拟机角度来看，设置完对象头信息以后初始化就已经完成了，但是对于Java程序而言，new指令之后会接着执行<init> ()方法，对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<h2 id="分配对象内存的时候如何保证线程安全"><a href="#分配对象内存的时候如何保证线程安全" class="headerlink" title="分配对象内存的时候如何保证线程安全"></a>分配对象内存的时候如何保证线程安全</h2><p><strong>分配内存线程安全问题</strong>：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>线程安全问题有两种解可选方案：</p>
<ul>
<li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</li>
<li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8809c7fe03d4403a68f38f4e9e425c3~tplv-k3u1fbpfcp-zoom-1.image" alt="对象的内存布局"></p>
<p>在64位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的64个比特存储空间中的31个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，在其他状态（轻量级锁、重量级锁、偏向锁）下对象的存储内容变化如图示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988ab7a8b17045d4972b29a84ae98042~tplv-k3u1fbpfcp-zoom-1.image" alt="64虚拟机Mark World"></p>
<p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，<strong>Java虚拟机通过这个指针来确定该对象是哪个类的实例</strong>。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据信息并不一定要经过对象本身，</p>
<p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：</p>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6228654998449090f63181082ac4a8~tplv-k3u1fbpfcp-zoom-1.image" alt="通过句柄访问对象"></p>
<ul>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d722a4c37d0046bab9c4529ff05e68a6~tplv-k3u1fbpfcp-zoom-1.image" alt="通过直接指针访问对象"></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>
<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>
<p><strong>HotSpot虚拟机主要使用直接指针来进行对象访问。</strong></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><img src="JVM%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3.png" alt="Java内存区域和对象详解"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JVM（一）内存区域和对象详解</p><p><a href="http://example.com/2021/05/10/JVM（一）内存区域和对象详解/">http://example.com/2021/05/10/JVM（一）内存区域和对象详解/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/10/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JVM（二）垃圾回收和内存分配</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/07/Java%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%B8%8B/"><span class="level-item">Java并发理论基础-下</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java内存区域"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java内存区域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#运行时数据区"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">运行时数据区</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#程序计数器"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">程序计数器</span></span></a></li><li><a class="level is-mobile" href="#虚拟机栈"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">虚拟机栈</span></span></a></li><li><a class="level is-mobile" href="#本地方法栈"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">本地方法栈</span></span></a></li><li><a class="level is-mobile" href="#Java堆"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">Java堆</span></span></a></li><li><a class="level is-mobile" href="#方法区"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">方法区</span></span></a></li><li><a class="level is-mobile" href="#运行时常量池"><span class="level-left"><span class="level-item">1.1.6</span><span class="level-item">运行时常量池</span></span></a></li><li><a class="level is-mobile" href="#直接内存"><span class="level-left"><span class="level-item">1.1.7</span><span class="level-item">直接内存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JDK的内存演变"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">JDK的内存演变</span></span></a></li><li><a class="level is-mobile" href="#哪些地方会发生OOM"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">哪些地方会发生OOM</span></span></a></li><li><a class="level is-mobile" href="#对象的创建都是在堆上吗"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">对象的创建都是在堆上吗</span></span></a></li><li><a class="level is-mobile" href="#字符串常量池的底层原理"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">字符串常量池的底层原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java对象详解"><span class="level-left"><span class="level-item">2</span><span class="level-item">Java对象详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建对象的4种方式"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">创建对象的4种方式</span></span></a></li><li><a class="level is-mobile" href="#New对象创建过程"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">New对象创建过程</span></span></a></li><li><a class="level is-mobile" href="#分配对象内存的时候如何保证线程安全"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">分配对象内存的时候如何保证线程安全</span></span></a></li><li><a class="level is-mobile" href="#对象的内存布局"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">对象的内存布局</span></span></a></li><li><a class="level is-mobile" href="#对象的访问定位"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">对象的访问定位</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结："><span class="level-left"><span class="level-item">3</span><span class="level-item">总结：</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">50</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-24T14:52:52.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AE%A1%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">Java并发（二）管程和线程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-24T14:52:02.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/">Java并发（三）并发工具类</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-24T14:50:41.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/">Java并发（四）并发集合</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-24T14:18:04.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java并发（六）线程池</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-24T14:17:29.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E5%8E%9F%E5%AD%90%E7%B1%BB/">Java并发（五）原子类</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>