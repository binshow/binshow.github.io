<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Redis（三）过期键删除和持久化 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Redis过期键的删除和持久化策略"><meta property="og:type" content="blog"><meta property="og:title" content="Redis（三）过期键删除和持久化"><meta property="og:url" content="http://example.com/2021/05/13/Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="Redis过期键的删除和持久化策略"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/Redis3.jpeg"><meta property="article:published_time" content="2021-05-13T06:19:54.000Z"><meta property="article:modified_time" content="2021-05-13T07:23:31.511Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/Redis3.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/13/Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/"},"headline":"Redis（三）过期键删除和持久化","image":[],"datePublished":"2021-05-13T06:19:54.000Z","dateModified":"2021-05-13T07:23:31.511Z","author":{"@type":"Person","name":"binshow"},"description":"Redis过期键的删除和持久化策略"}</script><link rel="canonical" href="http://example.com/2021/05/13/Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Redis3.jpeg" alt="Redis（三）过期键删除和持久化"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-13T06:19:54.000Z" title="2021/5/13下午2:19:54">2021-05-13</time>发表</span><span class="level-item"><time dateTime="2021-05-13T07:23:31.511Z" title="2021/5/13下午3:23:31">2021-05-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">24 分钟读完 (大约3663个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis（三）过期键删除和持久化</h1><div class="content"><p>Redis过期键的删除和持久化策略</p>
<span id="more"></span>



<h1 id="过期键删除"><a href="#过期键删除" class="headerlink" title="过期键删除"></a>过期键删除</h1><h2 id="键过期的本质是什么"><a href="#键过期的本质是什么" class="headerlink" title="键过期的本质是什么"></a>键过期的本质是什么</h2><h2 id="可能存在的删除策略"><a href="#可能存在的删除策略" class="headerlink" title="可能存在的删除策略"></a>可能存在的删除策略</h2><h2 id="Redis如何删除过期键的"><a href="#Redis如何删除过期键的" class="headerlink" title="Redis如何删除过期键的"></a>Redis如何删除过期键的</h2><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p> Redis 用做缓存时，直接从内存中读取数据，响应速度会非常快。但是<strong>一旦服务器宕机，内存中的数据将全部丢失</strong>。</p>
<p>从后端数据库恢复这些数据，但这种方式存在两个问题：</p>
<p>一是，需要频繁访问数据库，会给数据库带来巨大的压力；</p>
<p>二是，这些数据是从慢速数据库中读取出来的，性能肯定比不上从 Redis 中读取，导致使用这些数据的应用程序响应变慢。</p>
<p>所以，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><h3 id="为什么是写后日志"><a href="#为什么是写后日志" class="headerlink" title="为什么是写后日志"></a>为什么是写后日志</h3><p>之前学习MySQL的时候接触的都是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。</p>
<p>但是在Redis中却恰恰相反， Redis 是先执行命令，把数据写入内存，然后才记录日志。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/RedisAof.png"></p>
<p>那么为什么要这样设置呢？</p>
<p>传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p>
<p>“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3set”表示这部分有 3 个字节，也就是“set”命令。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%97%A5%E5%BF%97%E5%86%85%E5%AE%B9.png" alt="AOF日志内容"></p>
<p>为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</p>
<p>有两个缺陷：</p>
<ol>
<li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</li>
<li>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li>
</ol>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>在AOF的配置文件中，AOF 机制给我们提供了三个选择，也就是 AOF 配置项appendfsync 的三个可选值。</p>
<ul>
<li><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>
<li><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的<strong>内存缓冲区</strong>，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ul>
<p>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/%E5%86%99%E5%9B%9E%E7%A3%81%E7%9B%98%E7%AD%96%E7%95%A5.png" alt="写回磁盘策"></p>
<blockquote>
<p>想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择Everysec 策略。</p>
</blockquote>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>AOF 文件过大会带来一系列性能问题，主要在于以下三个方面：</p>
<ol>
<li>文件系统本身对文件大小有限制，无法保存过大的文件；</li>
<li>如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li>
<li>如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li>
</ol>
<p><strong>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件</strong>，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对“testkey”:“testvalue”之后，重写机制会记录 settestkey testvalue 这条命令。</p>
<p>我们知道，AOF 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E9%87%8D%E5%86%99%E4%B8%BE%E4%BE%8B.png" alt="AOF重写举例"></p>
<h3 id="AOF重写会阻塞主线程吗"><a href="#AOF重写会阻塞主线程吗" class="headerlink" title="AOF重写会阻塞主线程吗"></a>AOF重写会阻塞主线程吗</h3><p>AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<p>每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，子进程这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p>
<blockquote>
<p>所谓fork子进程指的是，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。</p>
</blockquote>
<p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E9%87%8D%E5%86%99%E9%9D%9E%E9%98%BB%E5%A1%9E.png" alt="AOF重写非阻塞"></p>
<h2 id="RDB（Redis-DataBase-）"><a href="#RDB（Redis-DataBase-）" class="headerlink" title="RDB（Redis DataBase ）"></a>RDB（Redis DataBase ）</h2><p>内存快照</p>
<h3 id="给哪些内存数据做快照？"><a href="#给哪些内存数据做快照？" class="headerlink" title="给哪些内存数据做快照？"></a>给哪些内存数据做快照？</h3><p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave </p>
<ul>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是Redis RDB 文件生成的默认配置。</li>
</ul>
<p><strong>避免阻塞和正常处理写操作并不是一回事！！！</strong>。此时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>
<p>简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/copyonwrite.png" alt="copyonwrite"></p>
<h3 id="快照频率如何确定"><a href="#快照频率如何确定" class="headerlink" title="快照频率如何确定"></a>快照频率如何确定</h3><p>如果频繁地执行全量快照，也会带来两方面的开销。</p>
<ul>
<li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li>
</ul>
<p>我们可以做增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/%E5%A2%9E%E9%87%8F%E5%BF%AB%E7%85%A7.png" alt="增量快照"></p>
<p>它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p>
<p>虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？</p>
<h2 id="AOF-日志和内存快照混合"><a href="#AOF-日志和内存快照混合" class="headerlink" title="AOF 日志和内存快照混合"></a>AOF 日志和内存快照混合</h2><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<p><img src="Redis%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/RDB%E5%92%8CAOF%E6%B7%B7%E5%90%88.png" alt="RDB和AOF混合"></p>
<p>关于 AOF 和 RDB 的选择问题，我想再给你提三点建议：</p>
<ul>
<li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li>
<li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li>
<li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Redis（三）过期键删除和持久化</p><p><a href="http://example.com/2021/05/13/Redis（三）过期键删除和持久化/">http://example.com/2021/05/13/Redis（三）过期键删除和持久化/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-13</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Redis/">Redis</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/13/Redis%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis（四）主从复制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/13/Redis%EF%BC%88%E4%BA%8C%EF%BC%89IO%E6%A8%A1%E5%9E%8B/"><span class="level-item">Redis（二）IO模型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#过期键删除"><span class="level-left"><span class="level-item">1</span><span class="level-item">过期键删除</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#键过期的本质是什么"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">键过期的本质是什么</span></span></a></li><li><a class="level is-mobile" href="#可能存在的删除策略"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">可能存在的删除策略</span></span></a></li><li><a class="level is-mobile" href="#Redis如何删除过期键的"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Redis如何删除过期键的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#持久化"><span class="level-left"><span class="level-item">2</span><span class="level-item">持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#AOF（Append-Only-File）"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">AOF（Append Only File）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么是写后日志"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">为什么是写后日志</span></span></a></li><li><a class="level is-mobile" href="#三种写回策略"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">三种写回策略</span></span></a></li><li><a class="level is-mobile" href="#AOF文件重写"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">AOF文件重写</span></span></a></li><li><a class="level is-mobile" href="#AOF重写会阻塞主线程吗"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">AOF重写会阻塞主线程吗</span></span></a></li></ul></li><li><a class="level is-mobile" href="#RDB（Redis-DataBase-）"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">RDB（Redis DataBase ）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#给哪些内存数据做快照？"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">给哪些内存数据做快照？</span></span></a></li><li><a class="level is-mobile" href="#快照频率如何确定"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">快照频率如何确定</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AOF-日志和内存快照混合"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">AOF 日志和内存快照混合</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">69</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-09T02:02:01.000Z">2021-10-09</time></p><p class="title"><a href="/2021/10/09/%E4%BC%98%E6%83%A0%E5%88%B8%E9%A1%B9%E7%9B%AE/">优惠券项目</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:40:04.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%94%81/">MySQL（十一）锁</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:39:51.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%EF%BC%89%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97/">MySQL（十）回滚日志</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:58.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E4%B9%9D%EF%BC%89%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/">MySQL（九）日志详解</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:41.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/">MySQL（八）事务</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>