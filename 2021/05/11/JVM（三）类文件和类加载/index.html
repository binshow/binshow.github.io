<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM（三）类文件和类加载 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="binshow"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="binshow"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java学习"><meta property="og:type" content="blog"><meta property="og:title" content="JVM（三）类文件和类加载"><meta property="og:url" content="http://example.com/2021/05/11/JVM%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="Java学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"><meta property="article:published_time" content="2021-05-11T01:53:11.000Z"><meta property="article:modified_time" content="2021-05-11T02:26:12.935Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/11/JVM%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},"headline":"JVM（三）类文件和类加载","image":["http://example.com/gallery/covers/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"],"datePublished":"2021-05-11T01:53:11.000Z","dateModified":"2021-05-11T02:26:12.935Z","author":{"@type":"Person","name":"Binshow"},"description":"java跨平台的实现是基于JVM虚拟机的，编写的java源码，编译后会生成一种.class文件，称为字节码文件。  java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。  为了保证Class文件在多个平台的通用性，java官方制定了严格的Class文件格式。  了解Class文件结构，有利于我们反编译 .class 文件或在程序编译期间修改字节码做代码注入。"}</script><link rel="canonical" href="http://example.com/2021/05/11/JVM%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="JVM（三）类文件和类加载"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-11T01:53:11.000Z" title="2021/5/11上午9:53:11">2021-05-11</time>发表</span><span class="level-item"><time dateTime="2021-05-11T02:26:12.935Z" title="2021/5/11上午10:26:12">2021-05-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约7668个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM（三）类文件和类加载</h1><div class="content"><p>java跨平台的实现是基于JVM虚拟机的，编写的java源码，编译后会生成一种<code>.class</code>文件，称为字节码文件。</p>
<ul>
<li><p>java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。</p>
</li>
<li><p>为了保证Class文件在多个平台的通用性，java官方制定了严格的Class文件格式。</p>
</li>
<li><p>了解Class文件结构，有利于我们反编译 <code>.class</code> 文件或在程序编译期间修改字节码做代码注入。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p>Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p>
<p>每一个 Class 文件对应于一个如下所示的 ClassFile 结构体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line"> u4 magic;</span><br><span class="line"> u2 minor_version;</span><br><span class="line"> u2 major_version;</span><br><span class="line"> u2 constant_pool_count;</span><br><span class="line"> cp_info constant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line"> u2 access_flags;</span><br><span class="line"> u2 this_class;</span><br><span class="line"> u2 super_class;</span><br><span class="line"> u2 interfaces_count;</span><br><span class="line"> u2 interfaces[interfaces_count];</span><br><span class="line"> u2 fields_count;</span><br><span class="line"> field_info fields[fields_count];</span><br><span class="line"> u2 methods_count;</span><br><span class="line"> method_info methods[methods_count];</span><br><span class="line"> u2 attributes_count;</span><br><span class="line"> attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>简单看一下各项的含义：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1516ac75c624af490aae79f219544fa~tplv-k3u1fbpfcp-zoom-1.image" alt="Class 文件结构"></p>
<p>由于 Class 文件结构没有任何分隔符，所以无论是每个数据项的的顺序还是数量，都是严格限定的，哪个字节代表什么含义，长度多少，先后顺序如何，都是不允许改变的</p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>将class文件用16进制打开的话</p>
<p>第一行中有一串特殊的字符 <code>cafebabe</code>，它就是一个魔数，是 JVM 识别 class 文件的标志，JVM 会在验证阶段检查 class 文件是否以该魔数开头，如果不是则会抛出 <code>ClassFormatError</code>。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式未发生变化。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
<p>这17类常量结构只有一个相同之处，表结构起始的第一位是个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。</p>
<p>17种常量类型所代表的具体含义如表所示：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>标志</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8 编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>表示方法类型</td>
</tr>
<tr>
<td>CONSTANT_Dynamic_info</td>
<td>17</td>
<td>表示一个动态计算常量</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
<tr>
<td>CONSTANT_Moudle_info</td>
<td>19</td>
<td>表示一个模块</td>
</tr>
<tr>
<td>CONSTANT_Package_info</td>
<td>20</td>
<td>表示一个模块中开放或者导出的包</td>
</tr>
</tbody></table>
<p>常量池非常繁琐，17种常量类型各自有着完全独立的数据结构，彼此之间没有什么共性和联系。</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），<strong>这个标志用于识别一些类或者接口层次的访问信息</strong>，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。</p>
<p>具体的标志位以及标志的含义如表：</p>
<table>
<thead>
<tr>
<th><strong>标志名称</strong></th>
<th><strong>标志值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为 Public 类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用 invokespecial 字节码指令的新语义</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志这个类并非由用户代码产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一 律为零。</p>
<h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><p>这三者用来确定类的继承关系。</p>
<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了 java.lang.Object外，所有Java类的父类索引都不为0。</p>
<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（后的接口顺序从左到右排列在接口索引集合中。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>接口索引结束后，接着是字段表（field_info），它用于描述接口或者类中声明的变量——这里的<code>字段（Field）</code>只包括类级变量以及实例级变量，不包括在方法内部声明的局部变量。</p>
<p>描述的主要信息包括：</p>
<p>　　①、字段的作用域（public，protected，private修饰）</p>
<p>　　②、是类级变量还是实例级变量（static修饰）</p>
<p>　　③、是否可变（final修饰）</p>
<p>　　④、并发可见性（volatile修饰，是否强制从主从读写）</p>
<p>　　⑤、是否可序列化（transient修饰）</p>
<p>　　⑥、字段数据类型（8种基本数据类型，对象，数组等引用类型）</p>
<p>　　⑦、字段名称</p>
<p>字段表的结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>access_flags是该字段的的访问标志，它和类中的访问标志很类似，用以描述该字段的权限类型：private、protected、public；并发可见性：volatile；可变性：final；</p>
<p>访问标志详情如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9886171580d4df38c96e9e7e05fb703~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210419220242129"></p>
<p>由于Java语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，如表所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef62f50d36794a92a750e57145036d25~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210419220451611"></p>
<p>有区别的部分只有方法访问标志<code> access_flag</code>, 因为volatile关键字和transient关键字不能修饰方法。</p>
<p>方法表标志位及其取值如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d250e3366e6f4ed3b825d9c9217d2b7c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210419220603688"></p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>接下来终于到了最后一项：属性表集合。</p>
<p>前面提到的Class文件、字段表、方法表都可以携带自己的属性表集合，就是引用的这里。</p>
<p>属性表集合中的属性如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1002d5801cde4dddbd1771fb8e2b7129~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210419220806085"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef0dfebb1221461ea792d4dc96928a34~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210419220927662"></p>
<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p>
<h2 id="举例查看"><a href="#举例查看" class="headerlink" title="举例查看"></a>举例查看</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java  //javac 命令编译成 jvm 能识别的 class 文件</span><br><span class="line">xxd Hello.class  //以 16 进制的方式查看这个 class 文件</span><br></pre></td></tr></table></figure>

<p>16进制如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 001d 0a00 0600 0f09  .......4........  //cafe babe为魔数</span><br><span class="line">00000010: 0010 0011 0800 120a 0013 0014 0700 1507  ................</span><br><span class="line">00000020: 0016 0100 063c 696e 6974 3e01 0003 2829  .....&lt;init&gt;...()</span><br><span class="line">00000030: 5601 0004 436f 6465 0100 0f4c 696e 654e  V...Code...LineN</span><br><span class="line">00000040: 756d 6265 7254 6162 6c65 0100 046d 6169  umberTable...mai</span><br><span class="line">00000050: 6e01 0016 285b 4c6a 6176 612f 6c61 6e67  n...([Ljava/lang</span><br><span class="line">00000060: 2f53 7472 696e 673b 2956 0100 0a53 6f75  /String;)V...Sou</span><br><span class="line">00000070: 7263 6546 696c 6501 000a 4865 6c6c 6f2e  rceFile...Hello.</span><br><span class="line">00000080: 6a61 7661 0c00 0700 0807 0017 0c00 1800  java............</span><br><span class="line">00000090: 1901 000b 4865 6c6c 6f20 576f 726c 6407  ....Hello World.</span><br><span class="line">000000a0: 001a 0c00 1b00 1c01 0021 636f 6d2f 7869  .........!com/xi</span><br><span class="line">000000b0: 6173 6d2f 6173 6d64 656d 6f2f 636c 6173  asm/asmdemo/clas</span><br><span class="line">000000c0: 7374 6573 742f 4865 6c6c 6f01 0010 6a61  stest/Hello...ja</span><br><span class="line">000000d0: 7661 2f6c 616e 672f 4f62 6a65 6374 0100  va/lang/Object..</span><br><span class="line">000000e0: 106a 6176 612f 6c61 6e67 2f53 7973 7465  .java/lang/Syste</span><br><span class="line">000000f0: 6d01 0003 6f75 7401 0015 4c6a 6176 612f  m...out...Ljava/</span><br><span class="line">00000100: 696f 2f50 7269 6e74 5374 7265 616d 3b01  io/PrintStream;.</span><br><span class="line">00000110: 0013 6a61 7661 2f69 6f2f 5072 696e 7453  ..java/io/PrintS</span><br><span class="line">00000120: 7472 6561 6d01 0007 7072 696e 746c 6e01  tream...println.</span><br><span class="line">00000130: 0015 284c 6a61 7661 2f6c 616e 672f 5374  ..(Ljava/lang/St</span><br><span class="line">00000140: 7269 6e67 3b29 5600 2100 0500 0600 0000  ring;)V.!.......</span><br><span class="line">00000150: 0000 0200 0100 0700 0800 0100 0900 0000  ................</span><br><span class="line">00000160: 1d00 0100 0100 0000 052a b700 01b1 0000  .........*......</span><br><span class="line">00000170: 0001 000a 0000 0006 0001 0000 0003 0009  ................</span><br><span class="line">00000180: 000b 000c 0001 0009 0000 0025 0002 0001  ...........%....</span><br><span class="line">00000190: 0000 0009 b200 0212 03b6 0004 b100 0000  ................</span><br><span class="line">000001a0: 0100 0a00 0000 0a00 0200 0000 0500 0800  ................</span><br><span class="line">000001b0: 0600 0100 0d00 0000 0200 0e              ...........</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c xxx 是用来对class文件进行反编译</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xiasmdeMacBook-Pro:test xiasm$ javap -c Hello</span><br><span class="line">警告: 二进制文件Hello包含com.xiasm.asmdemo.classtest.Hello</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  Compiled from <span class="string">&quot;Hello.java&quot;</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xiasm</span>.<span class="title">asmdemo</span>.<span class="title">classtest</span>.<span class="title">Hello</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">public</span> com.xiasm.asmdemo.classtest.Hello();</span><br><span class="line"><span class="number">4</span>      Code:</span><br><span class="line"><span class="number">5</span>         <span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">6</span>         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line"><span class="number">10</span>     Code:</span><br><span class="line"><span class="number">11</span>        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">12</span>        <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span><br><span class="line"><span class="number">13</span>        <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">14</span>        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第5行：aload_x 操作码用来把 <strong>对象引用</strong> 加载到 <strong>操作数栈</strong>，非静态的函数都有第一个默认参数，那就是 this，这里的 aload_0 就是把 this 入栈</li>
<li>第6行：invokespecial #1  invokespecial指令调用实例初始化方法、私有方法、父类方法，#1 指的是常量池中的第一个，这里是方法引用java/lang/Object.””:()V，也即构造器函数</li>
<li>第7行：return，这个操作码属于 ireturn、lreturn、freturn、dreturn、areturn 和 return 操作码组中的一员，其中 i 表示 int，返回整数，同类的还有 l 表示 long，f 表示 float，d 表示 double，a 表示 对象引用。没有前缀类型字母的 return 表示返回 void</li>
</ul>
<p>到此，构造器函数就结束了，接下来是 main 函数：</p>
<ul>
<li>第11行：getstatic #2   getstatic获取指定类的静态域，并将其值压入栈顶，#2 代表常量池中的第 2 个，这里表示的是java/lang/System.out:Ljava/io/PrintStream;，其实就是java.lang.System 类的静态变量 out（类型是 PrintStream）</li>
<li>第12行：ldc #3 ldc表示将int, float或String型常量值从常量池中推送至栈顶，#3 代表常量池的第三个（字符串 Hello, World）</li>
<li>第13行：invokevirtual #4   invokevirutal 指令调用一个对象的实例方法，#4表示 PrintStream.println(String) 函数引用，并把栈顶两个元素出栈</li>
</ul>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad84e5878c7e4848a7cc7a87966195f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>加载就是把字节码文件从IO或内存加载到内存中的过程；初始化就是使用<clinit>()进行类初始化的过程，这不同于调用构造函数；使用就是字面意思；卸载就是从方法区移除类型。</clinit></p>
<h2 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>　　①、通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>　　②、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>　　③、在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p>
<p>它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。</p>
<p><strong>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程</strong>。</p>
<p>定义此类的二进制流的获取方式有多种：</p>
<p>　1、从 ZIP 包中读取。这称为后面的 JAR、EAR、WAR 格式的基础。</p>
<p>　2、从网络中获取。比较典型的应用就是 Applet。</p>
<p>　3、运行时计算生成。这就是动态代理技术。</p>
<p>　4、由其它文件生成。比如 JSP 应用。</p>
<p>　5、从数据库中读取。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，然后在Java堆中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<p>　　注意，加载阶段与连接阶段的部分内容（如一部分字节码文件的格式校验）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始了。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>作用是为了<strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p>
<p>①、文件格式验证</p>
<p>②、元数据验证</p>
<p>③、字节码验证</p>
<p>④、符号引用验证</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令。</p>
<p>准备阶段是正式为<strong>类变量</strong>分配内存并设置<strong>类变量</strong>初始值的阶段，这些内存是在方法区中进行分配。</p>
<p>　　注意：</p>
<p>　　一、上面说的是类变量，也就是被 static 修饰的变量，不包括实例变量。实例变量会在对象实例化时随着对象一起分配在堆中。</p>
<p>　　二、初始值，指的是一些数据类型的默认值。基本的数据类型初始值如下（引用类型的初始值为null）：</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1120165/201911/1120165-20191107230747222-307539212.png" alt="img"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是<strong>虚拟机将常量池中的符号引用替换为直接引用的过程</strong>。</p>
<p>　　符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</p>
<p>　　直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。</p>
<p>　　解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用，分别对应于常量池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANTS_InterfaceMethodref_info四种类型常量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段是执行类构造器<clinit>() 方法的过程</clinit></strong>。</p>
<p>这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>①、<clinit>() 方法 是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</clinit></p>
<p>　　比如如下代码会报错：</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1120165/201911/1120165-20191117224046088-277331745.png" alt="img"></p>
<p> 　但是你把第 14 行代码放到 static 静态代码块的上面就不会报错了。或者不改变代码顺序，将第 11 行代码移除，也不会报错。</p>
<p>　　②、<clinit>() 方法与类的构造函数（或者说是实例构造器<init>()方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的<init>()方法执行之前，父类的<init>()方法已经执行完毕。因此虚拟机中第一个被执行的<init>()方法的类肯定是 java.lang.Object。</init></init></init></init></clinit></p>
<p>　　③、由于父类的<clinit>() 方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></p>
<p>　　④、<clinit>() 方法对于接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>() 方法。</clinit></clinit></p>
<p>　　⑤、接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>() 方法。但接口与类不同的是，执行接口中的<clinit>() 方法不需要先执行父接口的<clinit>() 方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。</clinit></clinit></clinit></p>
<p>　　⑥、接口的实现类在初始化时也一样不会执行接口的<clinit>() 方法。</clinit></p>
<p>　　⑦、虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确的加锁和同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>() 方法，其他的线程都需要阻塞等待，直到活动线程执行<clinit>() 方法完毕。如果在一个类的<clinit>() 方法中有很耗时的操作，那么可能造成多个进程的阻塞。</clinit></clinit></clinit></clinit></p>
<p>　　比如对于如下代码：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"> View Code</p>
<p>　　运行结果如下：</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1120165/201911/1120165-20191117230014699-485676426.png" alt="img"></p>
<p>　　线程1抢到了执行<clinit>() 方法，但是该方法是一个死循环，线程2将一直阻塞等待。</clinit></p>
<p>　　知道了类的初始化过程，那么类的初始化何时被触发呢？JVM大概规定了如下几种情况：</p>
<p>　　①、当虚拟机启动时，初始化用户指定的类。</p>
<p>　　②、当遇到用以新建目标类实例的 new 指令时，初始化 new 指定的目标类。</p>
<p>　　③、当遇到调用静态方法的指令时，初始化该静态方法所在的类。</p>
<p>　　④、当遇到访问静态字段的指令时，初始化该静态字段所在的类。</p>
<p>　　⑤、子类的初始化会触发父类的初始化。</p>
<p>　　⑥、如果一个接口定义了 default 方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化。</p>
<p>　　⑦、使用反射 API 对某个类进行反射调用时，会初始化这个类。</p>
<p>　　⑧、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</p>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p><strong>①、启动类加载器（Bootstrap ClassLoader）</strong></p>
<p>　　负责将存放在 <strong><JAVA_HOME>/lib</JAVA_HOME></strong> 目录中的，或者被**-Xbootclasspath** 参数所指定的路径中的，并且是虚拟机按照文件名识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。**<br>**　　启动类加载器无法被Java程序直接引用。**<br>**</p>
<p>　　JDK 中的源码类大都是由启动类加载器加载，比如前面说的 java.lang.String，java.util.List等，需要注意的是，启动类 main Class 也是由启动类加载器加载。</p>
<p><strong>②、扩展类加载器（Extension ClassLoader）</strong></p>
<p> 　这个类加载器由 <strong>sun.misc.Launcher$ExtClassLoader</strong> 实现，负责加载<strong>＜JAVA_HOME＞/lib/ext</strong> 目录中的，或者被 <strong>java.ext.dirs</strong> 系统变量所指定的路径中的所有类库。</p>
<p>　　开发者可以直接使用扩展类加载器。</p>
<p><strong>③、应用程序类加载器（Application ClassLoader）</strong></p>
<p>　　由 <strong>sun.misc.Launcher$AppClassLoader</strong> 实现。由于这个类加载器是 ClassLoader.getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。</p>
<p>　　它负责加载用户类路径ClassPath上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p> 　通常项目中自定义的类，都会放在类路径下，由应用程序类加载器加载。</p>
<p><strong>④、自定义类加载器（User ClassLoader）</strong></p>
<p> 　这是由用户自己定义的类加载器，一般情况下我们不会自定义类加载器，但有些特殊情况，比如JDBC能够通过连接各种不同的数据库就是自定义类加载器来实现的，具体用处会在后文详细介绍。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><strong>双亲委派机制就是如果一个类加载器收到了类加载请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈到无法完成这个加载请求（它的搜索范围没有找到这个类），子加载器才会尝试自己去加载。</strong></p>
<img src="/Users/shengbinbin/Library/Application Support/typora-user-images/image-20210503101101916.png" alt="image-20210503101101916" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create by YSOcean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = ClassLoadTest.class.getClassLoader();</span><br><span class="line">        ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">        ClassLoader classLoader3 = classLoader2.getParent();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">        System.out.println(classLoader2);</span><br><span class="line">        System.out.println(classLoader3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双亲委派机制有什么好处呢?</p>
<p>　　回到上面提出的问题，如果你自定义了一个 java.lang.String类，你会发现这个自定义的String.java<strong>可以正常编译，但是永远无法被加载运行</strong>。因为加载这个类的加载器，会一层一层的往上推，最终由启动类加载器来加载，而启动类加载的会是源码包下的String类，不是你自定义的String类。</p>
<p>实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>先说说我们为什么要自定义类加载器？</p>
<p><strong>①、加密</strong></p>
<p>　　我们知道Java字节码是可以进行反编译的，在某些安全性高的场景，是不允许这种情况发生的。那么我们可以将编译后的代码用某种加密算法进行加密，加密后的文件就不能再用常规的类加载器去加载类了。而我们自己可以自定义类加载器在加载的时候先解密，然后在加载。</p>
<p><strong>②、动态创建</strong></p>
<p>　　比如很有名的动态代理。</p>
<p><strong>③、从非标准的来源加载代码</strong></p>
<p>　　我们不用非要从class文件中获取定义此类的二进制流，还可以从数据库，从网络中，或者从zip包等。</p>
<p>　　明白了为什么要自定义类加载器，接下来我们再来详述如何自定义类加载器。</p>
<p>　　通过第 3 小节的 java.lang.ClassLoader 类的源码分析，类加载时根据双亲委派模型会先一层层找到父加载器，如果加载失败，则会调用当前加载器的 findClass() 方法来完成加载。因此我们自定义类加载器，有两个步骤：</p>
<p>　　1、<strong>继承 ClassLoader</strong></p>
<p>　　<strong>2、覆写 findClass() 方法</strong></p>
<h2 id="破坏双亲委派模型的情况"><a href="#破坏双亲委派模型的情况" class="headerlink" title="破坏双亲委派模型的情况"></a>破坏双亲委派模型的情况</h2><ul>
<li>重写 loadClass() 方法</li>
<li>逆向使用类加载器，引入线程上下文类加载器，如果 API 中的基础类想要调用用户的代码(JNDI/JDBC 等),此时双亲委派模型就不能完成.为了解决这个问题,java 设计团队只好 使用一个不优雅的设计方案:Thread 的上下文类加载器,默认就是应用程序的类加载器。</li>
<li>追求程序的动态性：代码热替换、模块热部署等技术，希望应用程序不用重启就可以加载最新的字节码文件.此时就需要破坏双亲委派模型</li>
</ul>
<h2 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h2><p>对于一个普通的Java动态代理，其实现过程可以简化成为：</p>
<ul>
<li><p>提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如com.mycorp.Hello。</p>
</li>
<li><p>实现InvocationHandler，对代理对象方法的调用，会被分派到其invoke方法来真正实现动作。</p>
</li>
<li><p>通过Proxy类，调用其newProxyInstance方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> satic Object <span class="title">newProxyInsance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>

<p>我们分析一下，动态代码生成是具体发生在什么阶段呢？</p>
<p>不错，就是在newProxyInstance生成代理类实例的时候。我选取了JDK自己采用的ASM作为示例，一起来看看用ASM实现的简要过程，请参考下面的示例代码片段。</p>
<p>第一步，生成对应的类，其实和我们去写Java代码很类似，只不过改为用ASM方法和指定参数，代替了我们书写的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">cw.visit(V1_8, <span class="comment">// 指定Java版本</span></span><br><span class="line">ACC_PUBLIC, <span class="comment">// 说明是public类型</span></span><br><span class="line"><span class="string">&quot;com/mycorp/HelloProxy&quot;</span>, <span class="comment">// 指定包和类的名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>, <span class="comment">// 签名，null表示不是泛型</span></span><br><span class="line"><span class="string">&quot;java/lang/Object&quot;</span>, <span class="comment">// 指定父类</span></span><br><span class="line"><span class="keyword">new</span> String[]&#123; <span class="string">&quot;com/mycorp/Hello&quot;</span> &#125;); <span class="comment">// 指定需要实现的接口</span></span><br><span class="line">更进一步，我们可以按照需要为代理对象实例，生成需要的方法和逻辑。</span><br><span class="line">MethodVisitor mv = cw.visitMethod(</span><br><span class="line">ACC_PUBLIC, <span class="comment">// 声明公共方法</span></span><br><span class="line"><span class="string">&quot;sayHello&quot;</span>, <span class="comment">// 方法名称</span></span><br><span class="line"><span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="comment">// 描述符</span></span><br><span class="line"><span class="keyword">null</span>, <span class="comment">// 签名，null表示不是泛型</span></span><br><span class="line"><span class="keyword">null</span>); <span class="comment">// 可能抛出的异常，如果有，则指定字符串数组</span></span><br><span class="line">mv.visitCode();</span><br><span class="line"><span class="comment">// 省略代码逻辑实现细节</span></span><br><span class="line">cw.visitEnd(); <span class="comment">// 结束类字节码生成</span></span><br></pre></td></tr></table></figure>

<p>上面的代码虽然有些晦涩，但总体还是能多少理解其用意，不同的visitX方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了Visitor模式，如果你熟悉这个模式，</p>
<p>就会知道它所针对的场景是将算法和对象结构解耦，非常适合字节码操纵的场合，因为我们大部分情况都是依赖于特定结构修改或者添加新的方法、变量或者类型等。</p>
<p>按照前面的分析，字节码操作最后大都应该是生成byte数组，ClassWriter提供了一个简便的方法。</p>
<p>cw.toByteArray();</p>
<p>然后，就可以进入我们熟知的类加载过程了，</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2021/05/11/JVM%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="JVM类文件和类加载"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JVM（三）类文件和类加载</p><p><a href="http://example.com/2021/05/11/JVM（三）类文件和类加载/">http://example.com/2021/05/11/JVM（三）类文件和类加载/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">消息队列基础问题</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/10/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="level-item">JVM（二）垃圾回收和内存分配</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Class文件结构"><span class="level-left"><span class="level-item">1</span><span class="level-item">Class文件结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#魔数"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">魔数</span></span></a></li><li><a class="level is-mobile" href="#版本号"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">版本号</span></span></a></li><li><a class="level is-mobile" href="#常量池"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">常量池</span></span></a></li><li><a class="level is-mobile" href="#访问标志"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">访问标志</span></span></a></li><li><a class="level is-mobile" href="#类索引、父类索引、接口索引"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">类索引、父类索引、接口索引</span></span></a></li><li><a class="level is-mobile" href="#字段表集合"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">字段表集合</span></span></a></li><li><a class="level is-mobile" href="#方法表集合"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">方法表集合</span></span></a></li><li><a class="level is-mobile" href="#属性表集合"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">属性表集合</span></span></a></li><li><a class="level is-mobile" href="#举例查看"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">举例查看</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类加载过程"><span class="level-left"><span class="level-item">2</span><span class="level-item">类加载过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类加载过程-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">类加载过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加载"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">加载</span></span></a></li><li><a class="level is-mobile" href="#验证"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">验证</span></span></a></li><li><a class="level is-mobile" href="#准备"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">准备</span></span></a></li><li><a class="level is-mobile" href="#解析"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">解析</span></span></a></li><li><a class="level is-mobile" href="#初始化"><span class="level-left"><span class="level-item">2.1.5</span><span class="level-item">初始化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类加载器分类"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">类加载器分类</span></span></a></li><li><a class="level is-mobile" href="#双亲委派模型"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">双亲委派模型</span></span></a></li><li><a class="level is-mobile" href="#自定义类加载器"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">自定义类加载器</span></span></a></li><li><a class="level is-mobile" href="#破坏双亲委派模型的情况"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">破坏双亲委派模型的情况</span></span></a></li><li><a class="level is-mobile" href="#动态代理的实现"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">动态代理的实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">3</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-12T01:50:36.000Z">2021-05-12</time></p><p class="title"><a href="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/">MySQL（三）索引</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-11T12:12:52.000Z">2021-05-11</time></p><p class="title"><a href="/2021/05/11/MySQL%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">MySQL（二）存储引擎</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-11T09:06:04.000Z">2021-05-11</time></p><p class="title"><a href="/2021/05/11/MySQL%EF%BC%88%E4%B8%80%EF%BC%89%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">MySQL（一）语法和数据类型</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-11T06:19:16.000Z">2021-05-11</time></p><p class="title"><a href="/2021/05/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/">消息队列基础问题</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-11T01:53:11.000Z">2021-05-11</time></p><p class="title"><a href="/2021/05/11/JVM%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/">JVM（三）类文件和类加载</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 Binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>