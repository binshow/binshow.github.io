<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL（三）索引 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="binshow"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="binshow"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java学习"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL（三）索引"><meta property="og:url" content="http://example.com/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="Java学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/%E7%B4%A2%E5%BC%95.jpeg"><meta property="article:published_time" content="2021-05-12T01:50:36.000Z"><meta property="article:modified_time" content="2021-05-12T03:27:49.591Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="MySQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/%E7%B4%A2%E5%BC%95.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/"},"headline":"MySQL（三）索引","image":[],"datePublished":"2021-05-12T01:50:36.000Z","dateModified":"2021-05-12T03:27:49.591Z","author":{"@type":"Person","name":"Binshow"},"description":"索引是加速数据查找的一种数据结构！ 本文介绍了  索引介绍 从磁盘IO的角度来理解SQL查询 理想的索引"}</script><link rel="canonical" href="http://example.com/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/%E7%B4%A2%E5%BC%95.jpeg" alt="MySQL（三）索引"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-12T01:50:36.000Z" title="2021/5/12上午9:50:36">2021-05-12</time>发表</span><span class="level-item"><time dateTime="2021-05-12T03:27:49.591Z" title="2021/5/12上午11:27:49">2021-05-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约7279个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL（三）索引</h1><div class="content"><p>索引是加速数据查找的一种数据结构！</p>
<p>本文介绍了</p>
<ul>
<li>索引介绍</li>
<li>从磁盘IO的角度来理解SQL查询</li>
<li>理想的索引</li>
</ul>
<span id="more"></span>

<h1 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><ol>
<li>索引是mysql为了高效获取数据的一种数据结构</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734bff356f9f2f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h2><p>优势：</p>
<ol>
<li><strong>提高数据检索效率，降低数据库IO成本</strong></li>
<li><strong>降低数据排序的成本，将随机IO变成顺序IO，降低CPU的消耗</strong></li>
</ol>
<p>劣势：</p>
<ol>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li>
</ol>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="功能逻辑分类"><a href="#功能逻辑分类" class="headerlink" title="功能逻辑分类"></a>功能逻辑分类</h3><ul>
<li><strong>普通索引</strong>：是基础的索引，没有任何约束，主要用于提高查询效率。</li>
<li><strong>唯一索引</strong>：就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。</li>
<li><strong>主键索引</strong>：在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引</li>
<li><strong>全文索引</strong>：用的不多，MySQL 自带的全文索引只支持英文</li>
</ul>
<blockquote>
<p>在一张数据表中只能有一个主键索引，这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。但可以有多个普通索引或者多个唯一索引。</p>
</blockquote>
<blockquote>
<p>InnoDB 表必须要有主键，并且推荐使用整型自增主键，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p>
</blockquote>
<h3 id="物理实现分类"><a href="#物理实现分类" class="headerlink" title="物理实现分类"></a>物理实现分类</h3><ul>
<li><strong>聚集索引</strong>：按照主键来排序存储数据，页子节点上就是数据行。</li>
<li><strong>非聚集索引（辅助索引）</strong>：系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行</li>
</ul>
<blockquote>
<p>每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。</p>
</blockquote>
<p>聚集索引与非聚集索引的原理不同，在使用上也有一些区别：</p>
<ol>
<li>聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。</li>
<li>使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</li>
</ol>
<h3 id="字段个数分类"><a href="#字段个数分类" class="headerlink" title="字段个数分类"></a>字段个数分类</h3><ul>
<li><strong>单一索引</strong>：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li><strong>联合索引</strong>：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
</ul>
<h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p>
<h2 id="B树和B-树的介绍"><a href="#B树和B-树的介绍" class="headerlink" title="B树和B+树的介绍"></a>B树和B+树的介绍</h2><p>B树是专门为了磁盘等外设存储设备设计的一种平衡查找树，B 树的英文是 Balance Tree，也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构经常采用 B 树来实现。</p>
<blockquote>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
</blockquote>
<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。B-Tree作为平衡的多路搜索树，<strong>它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶</strong>。同时你能看到，每个磁盘块中包括了关键字和子节点的指针。<strong>如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1</strong>。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。</li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。</li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734bff356b40f0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="索引"></p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p>模拟查找关键字29的过程：</p>
<ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。因此出现了改进之后的B+Tree：</p>
<p>在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li>
<li><strong>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中</strong>。而 B 树中，非叶子节点既保存索引，也保存数据记录。</li>
<li><strong>所有关键字都在叶子节点出现，叶子节点构成一个有序链表</strong>，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734bff3498c6715?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<ol>
<li><p>首先，<strong>B+ 树查询效率更稳定</strong>。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p>
</li>
<li><p>其次，<strong>B+ 树的查询效率更高</strong>，这是因为通常 B+ 树比 B 树更矮胖（阶数更大，深度更低），查询所需要的磁盘 I/O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p>
</li>
<li><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+ 树的效率也比 B 树高</strong>。这是因为所有关键字都出现在 B+ 树的叶子节点中，并通过有序链表进行了链接。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
</li>
</ol>
<h2 id="从数据页的角度来看B-树"><a href="#从数据页的角度来看B-树" class="headerlink" title="从数据页的角度来看B+树"></a>从数据页的角度来看B+树</h2><p>在一棵 B+ 树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间。同一层上的节点之间，通过页的结构构成一个双向的链表（页文件头中的两个指针字段）。非叶子节点，包括了多个索引行，每个索引行里存储索引键和指向下一层页面的页面指针。最后是叶子节点，它存储了关键字和行记录，在节点内部（也就是页结构的内部）记录之间是一个单向的链表，但是对记录进行查找，则可以通过页目录采用二分查找的方式来进行。</p>
<p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>1.B+ 树是如何进行记录检索的？</strong></p>
<p>如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p>
<p><strong>2. 普通索引和唯一索引在查询效率上有什么不同？</strong></p>
<p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p>
<h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><p>通过某一列建立辅助索引时，通过该列查找数据时，需要经历以下两个阶段：</p>
<ol>
<li>在辅助索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p>
<ul>
<li><p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p>
</li>
<li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p>
</li>
<li><p><strong>判断标准</strong></p>
<p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p>
</li>
</ul>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
<h2 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h2><p><strong>如何通过索引让SQL查询效率最大化？</strong></p>
<h3 id="哪些情况下需要创建索引"><a href="#哪些情况下需要创建索引" class="headerlink" title="哪些情况下需要创建索引"></a>哪些情况下需要创建索引</h3><ol>
<li><p><strong>有唯一性约束的字段，比如主键或唯一性字段</strong>，可以直接创建主键索引或者唯一性索引。</p>
</li>
<li><p><strong>频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下</strong></p>
</li>
<li><p><strong>需要经常 GROUP BY 和 ORDER BY 的列</strong></p>
<blockquote>
<p>如果同时有GROUP BY 和 ORDER BY 的情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> user_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> product_comment <span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> comment_time <span class="keyword">desc</span> limit <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>当我们对 user_id 和 comment_time 分别创建索引,效率反而不高</p>
<p>实际上<strong>多个单列索引在多条件查询时只会生效一个索引</strong>（MySQL 会选择其中一个限制最严格的作为索引），<strong>所以在多条件联合查询的时候最好创建联合索引</strong>。在这个例子中，我们创建联合索引 (user_id, comment_time)，再来看下查询的时间，查询时间为 0.775s，效率提升了很多。如果我们创建联合索引的顺序为 (comment_time, user_id) 呢？运行时间为 1.990s，同样比两个单列索引要快，但是会比顺序为 (user_id, comment_time) 的索引要慢一些。<strong>这是因为在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照这个联合索引的顺序效率是最高的</strong>。</p>
</blockquote>
</li>
<li><p><strong>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引</strong></p>
</li>
<li><p><strong>DISTINCT 字段需要创建索引</strong></p>
</li>
<li><p><strong>做多表 JOIN 连接操作时，创建索引需要注意以下的原则</strong>：</p>
<blockquote>
<p>查询中与其他表关联的字段，外键关系建立索引</p>
<p>首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 user_id 在 product_comment 表和 user 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
</blockquote>
</li>
</ol>
<h3 id="什么时候不需要创建索引"><a href="#什么时候不需要创建索引" class="headerlink" title="什么时候不需要创建索引"></a>什么时候不需要创建索引</h3><ol>
<li>WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的</li>
<li>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</li>
<li>字段中如果有大量重复数据，也不用创建索引，比如性别字段</li>
<li>频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</li>
</ol>
<h3 id="索引什么时候会失效"><a href="#索引什么时候会失效" class="headerlink" title="索引什么时候会失效"></a>索引什么时候会失效</h3><ol>
<li>如果索引进行了表达式计算，则会失效</li>
<li><strong>如果对索引使用函数，也会造成失效</strong></li>
<li><strong>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。</strong></li>
<li><strong>当我们使用 LIKE 进行模糊查询的时候，前面不能是 %</strong></li>
<li><strong>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。</strong></li>
<li><strong>我们在使用联合索引的时候要注意最左原则</strong></li>
</ol>
<h1 id="从磁盘IO的角度来理解SQL查询"><a href="#从磁盘IO的角度来理解SQL查询" class="headerlink" title="从磁盘IO的角度来理解SQL查询"></a>从磁盘IO的角度来理解SQL查询</h1><p>数据库存储的基本单位是页，对于一棵 B+ 树的索引来说，是先从根节点找到叶子节点，也就是先查找数据行所在的页，再将页读入到内存中，在内存中对页的记录进行查找，从而得到想要数据。你看，虽然我们想要查找的，只是一行记录，但是对于磁盘 I/O 来说却需要加载一页的信息，因为页是最小的存储单位。</p>
<p>如果我们想要查找多行记录，查询时间是否会成倍地提升呢？其实数据库会采用缓冲池的方式提升页的查找效率。</p>
<h2 id="数据库缓冲池"><a href="#数据库缓冲池" class="headerlink" title="数据库缓冲池"></a>数据库缓冲池</h2><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="数据库缓冲池"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">134217728</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做 checkpoint 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当缓冲池不够用时，需要释放掉一些不常用的页，就可以采用强行采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirty page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h2 id="数据页加载的三种方式"><a href="#数据页加载的三种方式" class="headerlink" title="数据页加载的三种方式"></a>数据页加载的三种方式</h2><ul>
<li><p>内存读取：如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96.png" alt="内存读取"></p>
</li>
<li><p>随机读取：如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间（包括了寻道和半圈旋转时间），有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96.png" alt="随机读取"></p>
</li>
<li><p><strong>顺序读取</strong>其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I/O 操作了。如果一个磁盘的吞吐量是 40MB/S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560（40MB/16KB）个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。</p>
</li>
</ul>
<h2 id="通过-last-query-cost-统计-SQL-语句的查询成本"><a href="#通过-last-query-cost-统计-SQL-语句的查询成本" class="headerlink" title="通过 last_query_cost 统计 SQL 语句的查询成本"></a>通过 last_query_cost 统计 SQL 语句的查询成本</h2><p>我们先前已经讲过，一条 SQL 查询语句在执行前需要确定查询计划，如果存在多种查询计划的话，MySQL 会计算每个查询计划所需要的成本，从中选择成本最小的一个作为最终执行的查询计划。</p>
<p>如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的 last_query_cost 变量值来得到当前查询的成本。<strong>这个查询成本对应的是 SQL 语句所需要读取的页的数量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span> deptno <span class="operator">|</span> deptname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> tech     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span> sale     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span> fin      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span> hr       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">0.549000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果另外一个查询所读取的页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间</strong></p>
<h1 id="理想的索引是什么样的"><a href="#理想的索引是什么样的" class="headerlink" title="理想的索引是什么样的"></a>理想的索引是什么样的</h1><h2 id="索引片"><a href="#索引片" class="headerlink" title="索引片"></a>索引片</h2><p>索引片就是 SQL 查询语句在执行中需要扫描的一个索引片段，我们会根据索引片中包含的匹配列的数量不同，将索引分成窄索引（比如包含索引列数为 1 或 2）和宽索引（包含的索引列数大于 2）。</p>
<p>如果索引片越宽，那么需要顺序扫描的索引页就越多；如果索引片越窄，就会减少索引访问的开销。</p>
<h2 id="过滤因子"><a href="#过滤因子" class="headerlink" title="过滤因子"></a>过滤因子</h2><p>谓词的选择性也等于满足这个条件列的记录数除以总记录数的比例。</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E8%BF%87%E6%BB%A4%E5%9B%A0%E5%AD%90.png" alt="过滤因子"></p>
<p>这时如果我们创建一个联合的过滤条件<code>（height, team_id）</code>，那么它的过滤能力是怎样的呢？</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E8%BF%87%E6%BB%A4%E5%9B%A0%E5%AD%90.png" alt="联合过滤因子"></p>
<p>联合过滤因子有更高的过滤能力，这里还需要注意一个条件，那就是条件列的关联性应该尽量相互独立，否则如果列与列之间具有相关性，联合过滤因子的能力就会下降很多。比如城市名称和电话区号就有强相关性，这两个列组合到一起不会加强过滤效果。</p>
<p>你能看到过滤因子决定了索引片的大小（注意这里不是窄索引和宽索引），过滤因子的条件过滤能力越强，满足条件的记录数就越少，SQL 查询需要扫描的索引片也就越小。同理，如果我们没有选择好索引片中的过滤因子，就会造成索引片中的记录数过多的情况。</p>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p>三星索引具体指的是：</p>
<ol>
<li>在 WHERE 条件语句中，找到所有等值谓词中的条件列，将它们作为索引片中的开始列；</li>
<li>将 GROUP BY 和 ORDER BY 中的列加入到索引中；</li>
<li>将 SELECT 字段中剩余的列加入到索引片中。</li>
</ol>
<p>首先，如果我们要通过索引查找符合条件的记录，就需要将 WHERE 子句中的等值谓词列加入到索引片中，这样索引的过滤能力越强，最终扫描的数据行就越少。</p>
<p>另外，如果我们要对数据记录分组或者排序，都需要重新扫描数据记录。为了避免进行 file sort 排序，可以把 GROUP BY 和 ORDER BY 中涉及到的列加入到索引中，因为创建了索引就会按照索引的顺序来存储数据，这样再对这些数据按照某个字段进行分组或者排序的时候，就会提升效率。</p>
<p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95.png" alt="三星索引"></p>
<p>有时候我们并不能需要完全遵循三星索引的原则，原因主要有以下两点：</p>
<ol>
<li><strong>采用三星索引会让索引片变宽</strong>，这样每个页能够存储的索引数据就会变少，从而增加了页加载的数量。从另一个角度来看，如果数据量很大，比如有 1000 万行数据，过多索引所需要的磁盘空间可能会成为一个问题，对缓冲池所需空间的压力也会增加。</li>
<li><strong>增加了索引维护的成本</strong>。如果我们为所有的查询语句都设计理想的三星索引，就会让数据表中的索引个数过多，这样索引维护的成本也会增加。举个例子，当我们添加一条记录的时候，就需要在每一个索引上都添加相应的行（存储对应的主键值），假设添加一行记录的时间成本是 10ms（磁盘随机读取一个页的时间），那么如果我们创建了 10 个索引，添加一条记录的时间就可能变成 0.1s，如果是添加 10 条记录呢？就会花费近 1s 的时间。从索引维护的成本来看消耗还是很高的。当然对于数据库来说，数据的更新不一定马上回写到磁盘上，但即使不及时将脏页进行回写，也会造成缓冲池中的空间占用过多，脏页过多的情况。</li>
</ol>
<p>针对一条 SQL 查询来说，三星索引是个理想的方式，但实际运行起来我们要考虑更多维护的成本，在索引效率和索引维护之间进行权衡。</p>
<p>三星索引会让索引变宽，好处就是不需要进行回表查询，减少了磁盘 I/O 的次数，弊端就是会造成频繁的页分裂和页合并，对于数据的插入和更新来说，效率会降低不少。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><img src="/2021/05/12/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.png" alt="索引总结"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MySQL（三）索引</p><p><a href="http://example.com/2021/05/12/MySQL（三）索引/">http://example.com/2021/05/12/MySQL（三）索引/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MySQL/">MySQL</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/12/MySQL%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL（四）事务和锁</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/11/MySQL%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"><span class="level-item">MySQL（二）存储引擎</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#索引介绍"><span class="level-left"><span class="level-item">1</span><span class="level-item">索引介绍</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是索引"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">什么是索引</span></span></a></li><li><a class="level is-mobile" href="#索引的优势和劣势"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">索引的优势和劣势</span></span></a></li><li><a class="level is-mobile" href="#索引的分类"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">索引的分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#功能逻辑分类"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">功能逻辑分类</span></span></a></li><li><a class="level is-mobile" href="#物理实现分类"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">物理实现分类</span></span></a></li><li><a class="level is-mobile" href="#字段个数分类"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">字段个数分类</span></span></a></li><li><a class="level is-mobile" href="#数据结构分类"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">数据结构分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#B树和B-树的介绍"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">B树和B+树的介绍</span></span></a></li><li><a class="level is-mobile" href="#从数据页的角度来看B-树"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">从数据页的角度来看B+树</span></span></a></li><li><a class="level is-mobile" href="#回表查询"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">回表查询</span></span></a></li><li><a class="level is-mobile" href="#覆盖索引"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">覆盖索引</span></span></a></li><li><a class="level is-mobile" href="#哈希索引"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">哈希索引</span></span></a></li><li><a class="level is-mobile" href="#索引的使用原则"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">索引的使用原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#哪些情况下需要创建索引"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">哪些情况下需要创建索引</span></span></a></li><li><a class="level is-mobile" href="#什么时候不需要创建索引"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">什么时候不需要创建索引</span></span></a></li><li><a class="level is-mobile" href="#索引什么时候会失效"><span class="level-left"><span class="level-item">1.9.3</span><span class="level-item">索引什么时候会失效</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#从磁盘IO的角度来理解SQL查询"><span class="level-left"><span class="level-item">2</span><span class="level-item">从磁盘IO的角度来理解SQL查询</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数据库缓冲池"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">数据库缓冲池</span></span></a></li><li><a class="level is-mobile" href="#数据页加载的三种方式"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">数据页加载的三种方式</span></span></a></li><li><a class="level is-mobile" href="#通过-last-query-cost-统计-SQL-语句的查询成本"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">通过 last_query_cost 统计 SQL 语句的查询成本</span></span></a></li></ul></li><li><a class="level is-mobile" href="#理想的索引是什么样的"><span class="level-left"><span class="level-item">3</span><span class="level-item">理想的索引是什么样的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#索引片"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">索引片</span></span></a></li><li><a class="level is-mobile" href="#过滤因子"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">过滤因子</span></span></a></li><li><a class="level is-mobile" href="#三星索引"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">三星索引</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结："><span class="level-left"><span class="level-item">4</span><span class="level-item">总结：</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-22T00:55:50.000Z">2021-06-22</time></p><p class="title"><a href="/2021/06/22/git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">git之基本操作</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-27T00:10:59.000Z">2021-05-27</time></p><p class="title"><a href="/2021/05/27/Netty%EF%BC%88%E5%85%AB%EF%BC%89%E4%BC%98%E5%8C%96%E5%92%8C%E5%AE%89%E5%85%A8/">Netty（八）优化和安全</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-27T00:10:34.000Z">2021-05-27</time></p><p class="title"><a href="/2021/05/27/Netty%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/">Netty（七）案例编写和调优参数</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-25T13:47:18.000Z">2021-05-25</time></p><p class="title"><a href="/2021/05/25/Netty%EF%BC%88%E5%85%AD%EF%BC%89%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Netty（六）流程源码解析</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-25T05:41:38.000Z">2021-05-25</time></p><p class="title"><a href="/2021/05/25/Netty%EF%BC%88%E4%BA%94%EF%BC%89%E9%94%81%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/">Netty（五）锁和内存使用</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 Binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>