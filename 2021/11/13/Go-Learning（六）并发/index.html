<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go_Learning（六）并发 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本节介绍GO的两大杀器：  goroutine channel"><meta property="og:type" content="blog"><meta property="og:title" content="Go_Learning（六）并发"><meta property="og:url" content="http://example.com/2021/11/13/Go-Learning%EF%BC%88%E5%85%AD%EF%BC%89%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="本节介绍GO的两大杀器：  goroutine channel"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/Go6.jpeg"><meta property="article:published_time" content="2021-11-13T01:59:35.000Z"><meta property="article:modified_time" content="2021-12-30T14:21:11.434Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="Go语言"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/Go6.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/11/13/Go-Learning%EF%BC%88%E5%85%AD%EF%BC%89%E5%B9%B6%E5%8F%91/"},"headline":"Go_Learning（六）并发","image":[],"datePublished":"2021-11-13T01:59:35.000Z","dateModified":"2021-12-30T14:21:11.434Z","author":{"@type":"Person","name":"binshow"},"description":"本节介绍GO的两大杀器：  goroutine channel"}</script><link rel="canonical" href="http://example.com/2021/11/13/Go-Learning%EF%BC%88%E5%85%AD%EF%BC%89%E5%B9%B6%E5%8F%91/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Go6.jpeg" alt="Go_Learning（六）并发"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-13T01:59:35.000Z" title="2021/11/13 上午9:59:35">2021-11-13</time>发表</span><span class="level-item"><time dateTime="2021-12-30T14:21:11.434Z" title="2021/12/30 下午10:21:11">2021-12-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约8193个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Go_Learning（六）并发</h1><div class="content"><p>本节介绍GO的两大杀器：</p>
<ul>
<li>goroutine</li>
<li>channel</li>
</ul>
<span id="more"></span>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li><strong>并发concurrency</strong>:     逻辑上具备同时处理多个任务的能力。</li>
<li><strong>并行parallesim</strong>:        物理上在同一时刻执行多个并发任务。</li>
</ul>
<p>在单核处理器上，它们能以间隔方式切换执行。而并行则依赖多核处理器等物理设备，让多个任务真正在同一时刻执行，它代表了当前程序运行状态。简单点说，<strong>并行是并发设计的理想执行模式</strong>。</p>
<blockquote>
<p>单线程也可用协程( coroutine)做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，但它也有自己的优势。除了将因阻塞而浪费的时间找回来外，还免去了线程切换开销，有着不错的执行效率。</p>
<p>协程上运行的多个任务本质上是依旧串行的，加上可控自主调度，所以并不需要做同步处理。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单演示 go 开启多个任务单元并行执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;i am goroutine1!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;(<span class="string">&quot;i am goroutine2!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;i am main goroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果不确定</span></span><br></pre></td></tr></table></figure>

<p>关键字go并非执行并发操作，而是创建一个<strong>并发任务单元</strong>。</p>
<p>新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。</p>
<blockquote>
<p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系统默认MB级别的线程栈，<strong>goroutine 自定义栈初始仅须2 KB</strong>，所以才能创建成千上万的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到GB规模。</p>
</blockquote>
<h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>下面的代码会输出啥：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上啥也不输出，因为main goroutine很快就结束了，go开启的goroutine根本没来得及执行对应逻辑</p>
<p>那么如何改进呢？只要使main goroutine阻塞等待其他的goroutine就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// main goroutine 阻塞在这里</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps： 报错是因为所有的goroutine都执行完了，你的select还在那里阻塞着，不会有case等你执行的，所以有死锁的可能。Go强制杀死了这个等待，并抛出了一个错误。你可以使用 sync.WaitGroup 或 time.Sleep来完善.</p>
<p>如下代码输出啥？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上输出 3 3 3。为啥？</p>
<blockquote>
<p>closure 闭包的缘故，可以认为是匿名函数保持对外部变量的引用，for循环每次迭代都使用的是变量i，而这个变量i是在func外部定义的，这样每个goroutine都持有对相同的变量的引用。</p>
<p>main goroutine 很快就执行完这个for循环了，所以i很快就变成3了，内部的goroutine根本没有反应过来</p>
</blockquote>
<p>两种改进方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 将i传值进去变成v</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		v := i <span class="comment">// 多设置一个变量v</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><p>Go也借鉴了CSP的理论，但又有所不同，最大的不同是Go显示地使用channel, channel在Go中是第一类的对象，goroutine通信完全通过通过channel实现的。<br>CSP模型中消息的分发是即时和同步的，Go的Channel则不同，消息会缓存在Channel中。</p>
<h2 id="goroutine和thread"><a href="#goroutine和thread" class="headerlink" title="goroutine和thread"></a>goroutine和thread</h2><ol>
<li><p>内存占用:goroutine并不需要太多太多的内存占用，<strong>初始只需2kB的栈空间即可</strong>(自Go 1.4起)，按照需要可以增长。线程初始1MB，并且会分配一个防护页(guard page)。</p>
<blockquote>
<p>在使用Java开发服务器的过程中经常会遇到<strong>request per thread</strong>的问题，如果为每个请求都分配一个线程的话，大并发的情况下服务器很快就死掉，因为内存不够了，所以很多Java框架比如Netty都会使用线程池来处理请求，而不会让线程任意增长。</p>
<p>而使用goroutine则没有这个问题，你页可以看到官方的net/http库就是使用<strong>request per goroutine</strong>这种模式进行处理的，内存占用不会是问题。</p>
</blockquote>
</li>
<li><p>对象的创建和销毁: 线程的创建和销毁肯定有花费，因为需要从OS中请求／返还资源。<strong>而goroutine的创建和销毁花费很少，因为它是用户态的操作</strong>。并且Go语言也不提供goroutine的手工管理。</p>
</li>
<li><p>切换时间当线程阻塞时，其它的线程进可能被执行，这叫做线程的切换。切换的时候，调度器需要保存当前阻塞的线程的状态，恢复要执行的线程状态，包括所有的寄存器，16个通用寄存器、程序计数器、栈指针、段寄存器、16个XMM寄存器、FP协处理器、16个 AVX寄存器、所有的MSR等等。<strong>goroutine的保存和恢复只需要三个寄存器：程序计数器、栈指针和DX寄存器。因为goroutine之间共享堆空间，不共享栈空间</strong>，所以只需把goroutine的栈指针和程序执行到那里的信息保存和恢复即可，花费很低。</p>
</li>
</ol>
<p>通过上面三个方面的分析，可以看到goroutine比线程有更多的优势。实际上Go使用少量线程来执行这些goroutine,通过GOMAXPROCS环境变量可以控制有多少线程可以并发执行用户态的代码。由于系统调用而被阻塞的线程不受这个变量的限制。以前版本的Go中这个变量为1,自Go 1.5后它的默认值为CPU的核数。</p>
<p>总结：</p>
<blockquote>
<p><strong>进程</strong>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。<br><strong>线程</strong>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br><strong>协程</strong>和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</p>
</blockquote>
<h2 id="goroutine的调度"><a href="#goroutine的调度" class="headerlink" title="goroutine的调度"></a>goroutine的调度</h2><p>goroutine调度器有三个重要的数据结构，都是以单字母命名: G、P、M,因为Golang以及实现了自举，所以绝大部分的代码都是由Go本身实现的，少部分的以汇编实现。</p>
<ul>
<li>M代表<strong>系统线程</strong>(Machine)，由操作系统管理。</li>
<li>G代表goroutine,包括栈／指令指针以及其它对调度goroutine有用的信息。</li>
<li>P代表<strong>处理器</strong>(processor),注意不是CPU处理器，而是调度处理器，包含调度的上下文。</li>
</ul>
<p>这三个结构源代码位于：Go源代码的<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/runtime2.go">src/runtime/runtime2.go</a></p>
<p><strong>P必须和M组合起来执行G</strong>，但是两者也并不是完全1:1对应，<strong>通常情况下P的数量固定和CPU的核数一样(GOMAXPROCS参数)，M则是按需创建</strong>，比如当M因为陷入系统调用而长时间阻塞的时候，P就会被监控线程抢回，去新建或者唤醒另一个M去执行，因此M的数量会增加，系统中可能存在一些阻塞的M。</p>
<p>当一个G被创建的时候，它可能被放入到一个P的本地队列或者全局队列中：</p>
<p>由于goroutine的执行的时间不会一样，goroutine不可能均匀地分布在所有的P的本地队列中，如果其中的一个P执行地很快，它的队列中没有其它的gouroutine需要执行了，它就会从全局队列中拿一批goroutine过来。</p>
<p>如果全局队列中也没有要执行的goroutine，那么这个P可能要从其它的P中“偷”一些goroutine过来。</p>
<p>这样设计的目的就是不要让一部分P忙的要死，另外一部分P确很清闲，这是一个balance的过程。</p>
<h2 id="Goroutine常用方法"><a href="#Goroutine常用方法" class="headerlink" title="Goroutine常用方法"></a>Goroutine常用方法</h2><ul>
<li>GOMAXPROCS</li>
<li>Gosched</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n = 0 查询当前可以并发的goroutine数目，默认和处理器合数相等</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;GOMAXPROCS = &quot;</span> , runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 8,</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;GOMAXPROCS = &quot;</span> , runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;				<span class="comment">// 确保a先打印，在打印b</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;b&quot;</span>)   </span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;a&quot;</span> , i)</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">				runtime.Gosched()  <span class="comment">// 打印到1时让出当前线程,让b先执行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>通道，他有点像在两个routine之间架设的管道，一个goroutine可以往这个管道里塞数据，另外一个可以从这个管道里取数据，有点类似于我们说的队列。</p>
<p>如果一个通道被关闭了，我们就不能往这个通道里发送数据了，如果发送的话，会引起<code>painc</code>异常。但是，我们还可以接收通道里的数据，如果通道里没有数据的话，接收的数据是<code>零值</code></p>
<h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><p>可以在goroutine中往channel中写入值，在其他的goroutine中监听这个channel完成，类似于事件触发完成通信。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(sum)</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine finish the work&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 写通道</span></span><br><span class="line">		c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;- ch  <span class="comment">// main goroutine 在这阻塞, 一直等待到上面的 goroutine完成任务了往ch里面写入值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="操作channel基本原则"><a href="#操作channel基本原则" class="headerlink" title="操作channel基本原则"></a>操作channel基本原则</h2><p>操作不同状态的channel会引发三种行为：</p>
<p><strong>panic：</strong></p>
<ul>
<li>向已经关闭的通道写数据会导致panic。<strong>最佳实践是由写入者关闭通道，能最大程度地避免向已经关闭的通道写数据而导致的panic</strong>。</li>
<li>重复关闭的通道会导致panic。</li>
</ul>
<p><strong>阻塞:</strong></p>
<ul>
<li>向未初始化的通道写数据或读数据都会导致当前goroutine的永久阻塞。</li>
<li>向<strong>缓冲区已满的通道</strong>写入数据会导致goroutine阻塞。</li>
<li><strong>通道中没有数据，读取该通道</strong>会导致goroutine阻塞。</li>
</ul>
<p><strong>非阻塞：</strong></p>
<ul>
<li>读取已经关闭的通道不会引发阻塞，而是立即返回通道元素类型的零值，可以使用comma,ok语法判断通道是否已经关闭。</li>
<li>向有缓冲且没有满的通道读/写不会引发阻塞。</li>
</ul>
<h2 id="channel分类"><a href="#channel分类" class="headerlink" title="channel分类"></a>channel分类</h2><h3 id="无缓冲的channel"><a href="#无缓冲的channel" class="headerlink" title="无缓冲的channel"></a>无缓冲的channel</h3><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。<strong>如果两个 goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待</strong>。</p>
<p>这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送goroutine和接收goroutine同时准备好，才可以完成发送和接收操作。  这种也称为 <strong>同步通道</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		ch &lt;- sum</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前面用过sync.WaitGroup 来实现主线程 等待协程运行完之后才退出</span></span><br><span class="line">	<span class="comment">// 这里的channel也可以，因为是一个同步通道。所以主线程在去通道里的数据是会一直阻塞，知道协程完成任务把值塞入到通道中去！！！</span></span><br><span class="line">	fmt.Println( &lt;- ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模拟两个协程打网球比赛：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 两个协程间的网球比赛</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	court := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>) <span class="comment">// 计数 + 2 表示需要等待两个协程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;binshow&quot;</span> , court)</span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;zkd&quot;</span> , court)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发球</span></span><br><span class="line">	court &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()<span class="comment">//等待两个协程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(name <span class="keyword">string</span>, court <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 函数退出是，调用done告诉main函数工作已经完成</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		ball , ok := &lt;- court</span><br><span class="line">		<span class="keyword">if</span> !ok &#123; <span class="comment">// 如果返回false说明</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s won \n&quot;</span> , name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选随机数，判断是否丢球</span></span><br><span class="line">		n := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		<span class="keyword">if</span> n % <span class="number">13</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s Missed \n&quot;</span> , name)</span><br><span class="line">			<span class="built_in">close</span>(court) <span class="comment">// 关闭通道，表示我们输了</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Player %s Hit %d\n&quot;</span>, name, ball)</span><br><span class="line">		ball++</span><br><span class="line"></span><br><span class="line">		court &lt;- ball <span class="comment">// 将球打向对手</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>模拟运动员接力比赛：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个无缓冲的通道</span></span><br><span class="line">	batch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>) <span class="comment">// 为最后一位跑步者将计数+1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Runner(batch)</span><br><span class="line"></span><br><span class="line">	batch &lt;- <span class="number">1</span> <span class="comment">//开始比赛</span></span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">//等待比赛结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接力比赛中的一位跑步者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待接力棒</span></span><br><span class="line">	runner := &lt;- baton</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Running With Baton \n&quot;</span> , runner)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> runner != <span class="number">4</span> &#123;</span><br><span class="line">		newRunner = runner + <span class="number">1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d To The Line \n&quot;</span> , newRunner)</span><br><span class="line">		<span class="keyword">go</span> Runner(baton)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始围绕跑道跑</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;开始围绕跑道跑&quot;)</span></span><br><span class="line">	time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> runner == <span class="number">4</span> &#123;</span><br><span class="line">		 fmt.Printf(<span class="string">&quot;Runner %d Finished , Race Over \n&quot;</span> , runner)</span><br><span class="line">		 wg.Done()  <span class="comment">// 只有第四名运动员跑完之后才 done</span></span><br><span class="line">		 <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将接力棒交给下一位跑步者</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Exchange With Runner %d \n&quot;</span> , runner , newRunner)</span><br><span class="line"></span><br><span class="line">	baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h3><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。</p>
<p>只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：<strong>无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// 创建容量为3的有缓冲的通道</span></span><br></pre></td></tr></table></figure>



<p><strong>当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。</strong></p>
<p>能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	numberGoroutines = <span class="number">4</span> <span class="comment">// 要使用的goroutine的数量</span></span><br><span class="line">	taskLoad = <span class="number">10</span> <span class="comment">//要处理的工作数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创造一个有缓冲的通道来管理工作</span></span><br><span class="line">	tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span> , taskLoad)</span><br><span class="line"></span><br><span class="line">	wg.Add(numberGoroutines)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动协程来处理工作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numberGoroutines; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(tasks , i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加一组要完成的工作</span></span><br><span class="line">	<span class="keyword">for</span> post:=<span class="number">1</span> ; post &lt;= taskLoad ; post++&#123;</span><br><span class="line">		tasks &lt;- fmt.Sprintf(<span class="string">&quot;Task: %d&quot;</span> , post)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从有缓冲的通道传入的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(task <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="comment">// 等待分配工作</span></span><br><span class="line">		task , ok := &lt;- task</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// 这意味着通道已经空了，并且已经被关闭了</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Worker: %d : Shutting Down \n&quot;</span> , worker)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 要开始工作了</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker : %d : Started %s \n&quot;</span> , worker , task)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示我们完成了工作</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker : %d : Completed %s \n&quot;</span> , worker , task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>         <span class="comment">// channel can only receive data</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// channel can only send data</span></span><br></pre></td></tr></table></figure>

<p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。通道创建的时候都是双向的，但也可以分配有方向的通道变量</p>
<h2 id="实现管道"><a href="#实现管道" class="headerlink" title="实现管道"></a>实现管道</h2><p>我们使用通道也可以做到管道的效果，我们只需要把一个通道的输出，当成下一个通道的输入即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChannel2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	one := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	two := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// g1 先运行 将 100 翻入channel one 中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		one &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// g2 因为要从 one中取数据，所以等g1放数据进去之后再运行。取出来放入 two中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		v := &lt;- one</span><br><span class="line">		two &lt;- v</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// main 因为要从 two中取数据，因此需要等 g2 将数据放入 two中才能继续运行</span></span><br><span class="line">	fmt.Println( &lt;- two) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>select 做的就是：选择处理列出的多个通信情况中的一个。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）</li>
</ul>
<p><strong>在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞!!!</strong></p>
<p>案例1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> pump1(ch1)</span><br><span class="line">	<span class="keyword">go</span> pump2(ch2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> suck(ch1 , ch2)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ;; i++&#123;</span><br><span class="line">		ch &lt;- i*<span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ;; i++&#123;</span><br><span class="line">		ch &lt;- i+<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suck</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="comment">// 因为没有default，所有select会一直阻塞轮询两个channel中是否有值</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;- ch1:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Received on channel 1: %d \n&quot;</span> , v)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;- ch2:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Received on channel 2: %d \n&quot;</span> , v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h1 id="共享内存并发机制"><a href="#共享内存并发机制" class="headerlink" title="共享内存并发机制"></a>共享内存并发机制</h1><p>看下面的需求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> share_mem_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何完成线程安全机制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			counter++</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定小于 5000，也就是说线程不安全</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用锁来解决线程不安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			mut.Lock() <span class="comment">// 先加锁</span></span><br><span class="line">			counter++</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//在defer函数中释放锁</span></span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 强制主线程等待1秒钟，让所有的协程完成操作再退出.如果注释了就不等于5000了</span></span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定 ==  5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何让主线程智能的等待其他协程的完成再退出呢？ -- waitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 增加一个要等待的量</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			mut.Lock() <span class="comment">// 先加锁</span></span><br><span class="line">			counter++</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//在defer函数中释放锁</span></span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			wg.Done() <span class="comment">// 减少一个要等待的量</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 主线程必须等到 wg == 0 时才往下执行</span></span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定 ==  5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="WaitGroup信号量"><a href="#WaitGroup信号量" class="headerlink" title="WaitGroup信号量"></a>WaitGroup信号量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//一个计数的信号量，使用它的目的是要main函数等待两个goroutine执行完成后再结束</span></span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span> ; i &lt; <span class="number">100</span> ; i++&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A: &quot;</span> , i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;B: &quot;</span> , i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Wait方法的意思是如果计数器大于0，就会阻塞，所以main 函数会一直等待2个goroutine完成后，再结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行这个程序，会发现A和B前缀会交叉出现，并且每次运行的结果可能不一样，这就是Go调度器调度的结果</p>
<h2 id="并发资源竞争"><a href="#并发资源竞争" class="headerlink" title="并发资源竞争"></a>并发资源竞争</h2><p>有并发的情况就肯定会存在资源竞争的问题，如果两个goroutine在没有相互同步的情况下共同访问一个共享的资源，就会处于相互竞争的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	count <span class="keyword">int32</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是不确定的 ！！！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		value := count</span><br><span class="line">		runtime.Gosched() <span class="comment">// 当前goroutine暂停的意思，退回执行队列，让其他等待的goroutine运行</span></span><br><span class="line">		value++</span><br><span class="line">		count = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="Time-After-和-time-Ticker"><a href="#Time-After-和-time-Ticker" class="headerlink" title="Time.After 和 time.Ticker"></a>Time.After 和 time.Ticker</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeTicker</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用</span></span><br><span class="line">	<span class="comment">// 返回一个存放着时间的channel，且周期性的会往这个channel里放值</span></span><br><span class="line">	chRate := time.Tick(time.Second)</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := &lt;-chRate; ok &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeAfter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;now time = &quot;</span> , time.Now())</span><br><span class="line">	times := time.After(time.Second * <span class="number">5</span>) <span class="comment">// 只发送一次时间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := &lt;-times; ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;time.After ,&quot;</span> ,v)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAfterAndTicker</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tick := time.Tick(<span class="number">1e8</span>)</span><br><span class="line">	boom := time.After(<span class="number">5e8</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick:</span><br><span class="line">			fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-boom:</span><br><span class="line">			fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">5e7</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用模式：</p>
<ul>
<li><p>简单超时模式：一般是等待某一段时间，如果这段时间没有完成操作就放弃：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSimpleTimeOut</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>)</span><br><span class="line">	timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span> , <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		timeout &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//time.Sleep(time.Second * 1)</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		ch &lt;- time.Now().Unix()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;开始执行操作了,接受到值 = &quot;</span> ,v)</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> &lt;-timeout: <span class="comment">// 检测超时的操作 </span></span><br><span class="line">		fmt.Println(<span class="string">&quot;2秒钟时间到了，停止操作了&quot;</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接使用 time.After 来代替上面的timeout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSimpleTimeOut</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//time.Sleep(time.Second * 1)</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		ch &lt;- time.Now().Unix()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;开始执行操作了,接受到值 = &quot;</span> ,v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(<span class="number">2</span> * time.Second): <span class="comment">// 检测超时的操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;2秒钟时间到了，停止操作了&quot;</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>取消耗时很长的同步调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeout</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span> , <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			ch &lt;- time.Now().Unix()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	下面的超时检测机制会失效，因为在有多个 case 符合条件时， select 对 case 的选择是伪随机的，也就是说</span></span><br><span class="line"><span class="comment">	select 语句可能不会在定时器超时信号到来时立刻选中 time.After(timeoutNs) 对应的 case，因此协程可能不会严格按照定时器设置的时间结束。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	L:</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">				<span class="comment">// do something</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;接收到值了 = &quot;</span> ,v)</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">2</span>):</span><br><span class="line">				<span class="comment">// 超时</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span> L</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>假设程序从多个复制的数据库同时读取。只需要一个答案，需要接收首先到达的答案</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(conns []conn, query <span class="keyword">string</span>)</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c Conn)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- c.DoQuery(query):</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;- ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="并发范式"><a href="#并发范式" class="headerlink" title="并发范式"></a>并发范式</h1><h2 id="ID生成器"><a href="#ID生成器" class="headerlink" title="ID生成器"></a>ID生成器</h2><p>在应用系统编程中，常见的应用场景就是调用一个统 的全局的生成器服务， 于生成全局事务号、订单号、序列号和随机数等 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个 goroutine 用来生成一个随机数，函数返回一个channel用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateIntA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ch := GenerateIntA()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>多个 goroutine增强型生成器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个 goroutine 用来生成一个随机数，函数返回一个channel用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个 goroutine 用来生成一个随机数，函数返回一个channel用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;- GenerateIntA():</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;- GenerateIntB():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateIntA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ch := GenerateInt()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println( &lt;- ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>希望ID生成器可以自动退出</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个 goroutine 用来生成一个随机数，函数返回一个channel用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Label:</span><br><span class="line">			<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">				<span class="comment">//通过 select 监听一个信号 chan 来确定是否停止生成</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">				<span class="keyword">case</span> &lt;- done:</span><br><span class="line">					fmt.Println(<span class="string">&quot;监听到done信号&quot;</span>)</span><br><span class="line">					<span class="keyword">break</span> Label</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateIntA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := GenerateIntA(done)</span><br><span class="line"></span><br><span class="line">	fmt.Println( &lt;- ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不需要生成器了</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 必须要先关闭在遍历ch，</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch&#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="work模式"><a href="#work模式" class="headerlink" title="work模式"></a>work模式</h2><p>这个模式主要是创建一个goroutine池，这些goroutine执行并控制一组工作，让其并发执行。使用无缓冲的通道保证两个goroutine之间的数据交换。</p>
<p>主要包含了以下几类的goroutine：</p>
<ul>
<li>初始化任务的goroutine</li>
<li>分发任务的goroutine</li>
<li>等待所有worker结束通知，然后关闭结果通道的goroutine</li>
</ul>
<p>程序使用三个通道：</p>
<ul>
<li>传递task任务的通道</li>
<li>传递task结果的通道</li>
<li>接受worker处理完任务后所发送通知的通道</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作池的 goroutine 数目</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	NUMBER = <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作任务</span></span><br><span class="line"><span class="keyword">type</span> task <span class="keyword">struct</span> &#123;</span><br><span class="line">	begin <span class="keyword">int</span></span><br><span class="line">	end <span class="keyword">int</span></span><br><span class="line">	result <span class="keyword">chan</span> &lt;- <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务处理: 计算 begin 到 end 的和，结果写入到 chan result</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *task)</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := t.begin ; i &lt;= t.end ; i++&#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	t.result &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWorker</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	workers := NUMBER</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 工作通道</span></span><br><span class="line">	taskChan := <span class="built_in">make</span>(<span class="keyword">chan</span> task , <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 结果通道</span></span><br><span class="line">	resChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> , <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// worker信号通道</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; , <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 初始化 task 的goroutine ， 计算100个自然数之和</span></span><br><span class="line">	<span class="keyword">go</span> InitTask(taskChan , resChan , <span class="number">100</span>)</span><br><span class="line">	<span class="comment">// 分发任务到 goroutine池</span></span><br><span class="line">	DistributeTask(taskChan , workers , done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取各个goroutine 处理完任务的通知，并关闭结果channel</span></span><br><span class="line">	<span class="keyword">go</span> CloseResult(done , resChan , workers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过结果channel 获取结果并汇总</span></span><br><span class="line">	sum := ProcessResult(resChan)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sum = &quot;</span> , sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitTask</span><span class="params">(taskChan <span class="keyword">chan</span>&lt;- task, r <span class="keyword">chan</span> <span class="keyword">int</span>, p <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	qu := p / <span class="number">10</span></span><br><span class="line">	mod := p % <span class="number">10</span></span><br><span class="line">	high := qu * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j:= <span class="number">0</span> ; j &lt; qu ; j++&#123;</span><br><span class="line">		b := <span class="number">10</span> * j + <span class="number">1</span></span><br><span class="line">		e := <span class="number">10</span> * (j + <span class="number">1</span>)</span><br><span class="line">		tsk := task&#123;</span><br><span class="line">			begin: b,</span><br><span class="line">			end: e,</span><br><span class="line">			result: r,</span><br><span class="line">		&#125;</span><br><span class="line">		taskChan &lt;- tsk</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mod != <span class="number">0</span> &#123;</span><br><span class="line">		tsk := task&#123;</span><br><span class="line">			begin: high + <span class="number">1</span>,</span><br><span class="line">			end: p,</span><br><span class="line">			result: r,</span><br><span class="line">		&#125;</span><br><span class="line">		taskChan &lt;- tsk</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(taskChan)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DistributeTask</span><span class="params">(taskChan &lt;-<span class="keyword">chan</span> task, workers <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> ProcessTask(taskChan , done)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作goroutine处理具体工作，并将处理结果发送到结果chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessTask</span><span class="params">(taskchan &lt;- <span class="keyword">chan</span> task , done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> t := <span class="keyword">range</span> taskchan&#123;</span><br><span class="line">		t.do()</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 done channel 同步等待所有工作 goroutine的结束，然后关闭 结果chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseResult</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, resChan <span class="keyword">chan</span> <span class="keyword">int</span>, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; workers ; i++&#123;</span><br><span class="line">		&lt;- done</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	<span class="built_in">close</span>(resChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取结果channel ， 汇总结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessResult</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> resChan&#123;</span><br><span class="line">		sum += r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>工作流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211120105254.png"></p>
<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>主要应对的场景是：一个流程需要多个子调用，这些子调用之间没有相互依赖。采用并行的方式来进行这些子调用：</p>
<p>重要的思想就是把<strong>同步调用 转换成 并行调用</strong>！！！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> query <span class="keyword">struct</span>&#123;</span><br><span class="line">	sql <span class="keyword">chan</span> <span class="keyword">string</span> <span class="comment">// 参数channel</span></span><br><span class="line">	result <span class="keyword">chan</span> <span class="keyword">string</span> <span class="comment">// 结果channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execQuery</span><span class="params">(q query)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//获取输入</span></span><br><span class="line">		sql := &lt;- q.sql</span><br><span class="line"></span><br><span class="line">		<span class="comment">//访问数据库</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 输出到结果channel</span></span><br><span class="line">		q.result &lt;- <span class="string">&quot;result from &quot;</span> + sql</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFuture</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	q := query&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span> , <span class="number">1</span>) , <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span> , <span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 query，</span></span><br><span class="line">	execQuery(q)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送参数</span></span><br><span class="line">	q.sql &lt;- <span class="string">&quot; select * from table&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做其他事情</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取结果</span></span><br><span class="line">	fmt.Println(&lt;- q.result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/binshow/img/master/20211120105915.png" style="zoom:50%;" />





<h1 id="Context标准库"><a href="#Context标准库" class="headerlink" title="Context标准库"></a>Context标准库</h1><p>应用场景：在实际的编码开发中，goroutine会拉起新的 goroutine，新的 goroutine又会开启新的 goroutine，最终形成一个树状的结构。那么如何通知到这个树上的所有goroutine呢？</p>
<p>主要设计目的就是两个：</p>
<ul>
<li>通知可以传递给所有goroutine调用树上的每一个goroutine</li>
<li>数据可以传递给整个goroutine调用树上的每一个goroutine</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>第一个创建context的goroutine称为 root节点，root节点负责创建一个实现Context接口的具体对象，并将该对象作为参数传递到新拉起的goroutine，下游的goroutine可以继续封装该对象，再传递到更下游的goroutine。</p>
<p>也就是说Context对象在传递的过程中最终会形成一个树状的数据结构，这样通过root节点的context对象就能遍历整个context对象树，通知和消息就可以通过root节点传递过去！！！</p>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNumOfGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start with goroutines num : &quot;</span> , runtime.NumGoroutine())</span><br><span class="line">	<span class="keyword">go</span> spawn()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Before finished , goroutines num: &quot;</span> , runtime.NumGoroutine())</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine exit !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里存在一个问题，主协程创建一个子协程之后，主协程被唤醒后退出的那一刻，其实程序里还是有其他goroutine的，只是main goroutine退出之后会自动把其他的goroutine干掉，但这其实并不是一个优雅的处理方式。</p>
<p>这种行为称为 <strong>协程泄漏！</strong></p>
<p>解决方法：</p>
<ul>
<li><p><strong>用channel</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listenWithSignals</span><span class="params">(sig <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- sig:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 正常执行</span></span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;main goroutine exit !&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> listenWithSignals(sig)</span><br><span class="line">	fmt.Println(<span class="string">&quot;start with goroutines num : &quot;</span> , runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line">	sig &lt;- <span class="literal">true</span> <span class="comment">// main goroutine 主动通知 子goroutine 退出, goroutine num - 1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Before finished , goroutines num: &quot;</span> , runtime.NumGoroutine())</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>就是用引入的context来解决</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LeakSomeRoutine</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 启动3个goroutine 去往channel中输入数据,但只有一个goroutine可以写入，另外2个都会阻塞</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">1</span>&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">2</span>&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">3</span>&#125;()</span><br><span class="line">	<span class="keyword">return</span> &lt;- ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泄漏前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakRoutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		LeakSomeRoutine()</span><br><span class="line">		<span class="comment">// 可以看出每一轮都会泄漏两个 goroutine</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Goroutine in roop end : &quot;</span> , runtime.NumGoroutine())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 4 6 8 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FixLeakingByContext</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 上下文管理子协程</span></span><br><span class="line">	ctx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> cancelByContext(ctx , ch)</span><br><span class="line">	<span class="keyword">go</span> cancelByContext(ctx , ch)</span><br><span class="line">	<span class="keyword">go</span> cancelByContext(ctx , ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随机触发某个子 goroutine 退出</span></span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelByContext</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="comment">//fmt.Println(&quot;cancel by ctx&quot;)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> n := &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancelByContext</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++&#123;</span><br><span class="line">		FixLeakingByContext()</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">1000</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Goroutines in roop end : %d \n&quot;</span> , runtime.NumGoroutine())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 2 2 2 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h2><h3 id="取消函数WithCancel"><a href="#取消函数WithCancel" class="headerlink" title="取消函数WithCancel"></a>取消函数WithCancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">				 n++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc() <span class="comment">// 当上下文操作完成后需要立马调用</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n:= <span class="keyword">range</span> gen(ctx)&#123;  <span class="comment">// gen 函数使用单独的 goroutine 生成整数发送到channel，而gen的调用者要在使用完生成的整数之后取消上下文，以免内部的goroutine泄漏</span></span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="截止退出WithDeadline"><a href="#截止退出WithDeadline" class="headerlink" title="截止退出WithDeadline"></a>截止退出WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithDeadLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">	ctx, cancelFunc := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> cancelFunc() <span class="comment">// 虽然 ctx 会过期，但是在上下文执行完毕之后调用 cancel函数是一个非常好的习惯</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// select 会使得 main goroutine 陷入等待 ，等待1秒后打印 overslept 或等待上下文过期之后退出</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Second):</span><br><span class="line">		fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="超时退出WithTimeout"><a href="#超时退出WithTimeout" class="headerlink" title="超时退出WithTimeout"></a>超时退出WithTimeout</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToDB</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	LOOP:</span><br><span class="line">		<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;db connecting ...&quot;</span>)</span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">				<span class="keyword">break</span> LOOP</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;worker done!&quot;</span>)</span><br><span class="line">		wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个超时时间，时间一到就取消此上下文并释放相关的资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithTimeout</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancelFunc := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> connectToDB(ctx)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	cancelFunc()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现了一个新的 context来实现 context 接口</span></span><br><span class="line"><span class="keyword">type</span> otherContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestContext</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// context.Background() 来创建一个 WithCancel 类型的上下文</span></span><br><span class="line">	ctxa, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// work 模拟运行前并检测前端的退出通知</span></span><br><span class="line">	<span class="keyword">go</span> work(ctxa , <span class="string">&quot;work1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 withDeadLine来包装前面的上下文对象 ctxa</span></span><br><span class="line">	tm := time.Now().Add(<span class="number">3</span> * time.Second)</span><br><span class="line">	ctxb, _ := context.WithDeadline(ctxa, tm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> work(ctxb , <span class="string">&quot;work2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 withValue 包装前面的上下文对象 ctxb</span></span><br><span class="line">	oc := otherContext&#123;ctxb&#125;</span><br><span class="line">	ctxc := context.WithValue(oc , <span class="string">&quot;key&quot;</span> , <span class="string">&quot;andes , pass from main &quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> workWithValue(ctxc , <span class="string">&quot;work3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">10</span>) <span class="comment">// 故意 sleep 10秒中，让 work2 和 work3 都超时退出</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示的调用 work1的cancel方法通知其退出</span></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 work1打印退出信息</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main stop&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s get msg to cannel\n&quot;</span> , name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s is running \n&quot;</span> , name)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待前端的退出通知，并试图获取context传递的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithValue</span><span class="params">(ctx context.Context , name <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s get msg to cancel\n&quot;</span> , name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			value := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s is running value = %s \n&quot;</span> , name , value)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













</div><div class="article-licensing box"><div class="licensing-title"><p>Go_Learning（六）并发</p><p><a href="http://example.com/2021/11/13/Go-Learning（六）并发/">http://example.com/2021/11/13/Go-Learning（六）并发/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-12-30</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/13/Go-Learning%EF%BC%88%E4%B8%83%EF%BC%89%E5%8F%8D%E5%B0%84/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Go_Learning（七）反射</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/11/13/Go-Learning%EF%BC%88%E4%BA%94%EF%BC%89%E6%8E%A5%E5%8F%A3/"><span class="level-item">Go_Learning（四）接口</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">109</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础知识"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并发和并行"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">并发和并行</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Goroutine"><span class="level-left"><span class="level-item">2</span><span class="level-item">Goroutine</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一个例子"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">一个例子</span></span></a></li><li><a class="level is-mobile" href="#CSP并发模型"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">CSP并发模型</span></span></a></li><li><a class="level is-mobile" href="#goroutine和thread"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">goroutine和thread</span></span></a></li><li><a class="level is-mobile" href="#goroutine的调度"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">goroutine的调度</span></span></a></li><li><a class="level is-mobile" href="#Goroutine常用方法"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Goroutine常用方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Channel"><span class="level-left"><span class="level-item">3</span><span class="level-item">Channel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事件通知"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">事件通知</span></span></a></li><li><a class="level is-mobile" href="#操作channel基本原则"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">操作channel基本原则</span></span></a></li><li><a class="level is-mobile" href="#channel分类"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">channel分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#无缓冲的channel"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">无缓冲的channel</span></span></a></li><li><a class="level is-mobile" href="#有缓冲的channel"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">有缓冲的channel</span></span></a></li><li><a class="level is-mobile" href="#单向channel"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">单向channel</span></span></a></li></ul></li><li><a class="level is-mobile" href="#实现管道"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">实现管道</span></span></a></li><li><a class="level is-mobile" href="#Select"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">Select</span></span></a></li></ul></li><li><a class="level is-mobile" href="#共享内存并发机制"><span class="level-left"><span class="level-item">4</span><span class="level-item">共享内存并发机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#WaitGroup信号量"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">WaitGroup信号量</span></span></a></li><li><a class="level is-mobile" href="#并发资源竞争"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">并发资源竞争</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Time-After-和-time-Ticker"><span class="level-left"><span class="level-item">5</span><span class="level-item">Time.After 和 time.Ticker</span></span></a></li><li><a class="level is-mobile" href="#并发范式"><span class="level-left"><span class="level-item">6</span><span class="level-item">并发范式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ID生成器"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">ID生成器</span></span></a></li><li><a class="level is-mobile" href="#work模式"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">work模式</span></span></a></li><li><a class="level is-mobile" href="#Future模式"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Future模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Context标准库"><span class="level-left"><span class="level-item">7</span><span class="level-item">Context标准库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本数据结构"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">基本数据结构</span></span></a></li><li><a class="level is-mobile" href="#问题引入"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">问题引入</span></span></a></li><li><a class="level is-mobile" href="#用法实例"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">用法实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#取消函数WithCancel"><span class="level-left"><span class="level-item">7.3.1</span><span class="level-item">取消函数WithCancel</span></span></a></li><li><a class="level is-mobile" href="#截止退出WithDeadline"><span class="level-left"><span class="level-item">7.3.2</span><span class="level-item">截止退出WithDeadline</span></span></a></li><li><a class="level is-mobile" href="#超时退出WithTimeout"><span class="level-left"><span class="level-item">7.3.3</span><span class="level-item">超时退出WithTimeout</span></span></a></li></ul></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">94</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-11T15:17:17.000Z">2022-01-11</time></p><p class="title"><a href="/2022/01/11/CLion%E7%BC%96%E5%86%99%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F/">CLion编写多个程序</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-09T15:07:17.000Z">2022-01-09</time></p><p class="title"><a href="/2022/01/09/Go-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%E5%92%8C%E5%8F%91%E5%B1%95/">Go_协程的历史和发展</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-08T13:06:43.000Z">2022-01-08</time></p><p class="title"><a href="/2022/01/08/CSAPP%EF%BC%88%E5%9B%9B%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">CSAPP（四）虚拟内存</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-06T15:25:41.000Z">2022-01-06</time></p><p class="title"><a href="/2022/01/06/CSAPP%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">CSAPP（三）存储结构</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-06T15:25:30.000Z">2022-01-06</time></p><p class="title"><a href="/2022/01/06/CSAPP%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA/">CSAPP（二）信息表示</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2022 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>