<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go入门之goroutine和channel - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本节介绍GO的两大杀器：  goroutine channel"><meta property="og:type" content="blog"><meta property="og:title" content="Go入门之goroutine和channel"><meta property="og:url" content="http://example.com/2021/11/07/Go%E5%85%A5%E9%97%A8%E4%B9%8Bgoroutine%E5%92%8Cchannel/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="本节介绍GO的两大杀器：  goroutine channel"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8.png"><meta property="article:published_time" content="2021-11-07T14:09:37.000Z"><meta property="article:modified_time" content="2021-11-10T15:16:58.406Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="Go语言"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/11/07/Go%E5%85%A5%E9%97%A8%E4%B9%8Bgoroutine%E5%92%8Cchannel/"},"headline":"Go入门之goroutine和channel","image":["http://example.com/gallery/covers/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8.png"],"datePublished":"2021-11-07T14:09:37.000Z","dateModified":"2021-11-10T15:16:58.406Z","author":{"@type":"Person","name":"binshow"},"description":"本节介绍GO的两大杀器：  goroutine channel"}</script><link rel="canonical" href="http://example.com/2021/11/07/Go%E5%85%A5%E9%97%A8%E4%B9%8Bgoroutine%E5%92%8Cchannel/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B8.png" alt="Go入门之goroutine和channel"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-07T14:09:37.000Z" title="2021/11/7下午10:09:37">2021-11-07</time>发表</span><span class="level-item"><time dateTime="2021-11-10T15:16:58.406Z" title="2021/11/10下午11:16:58">2021-11-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">36 分钟读完 (大约5419个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Go入门之goroutine和channel</h1><div class="content"><p>本节介绍GO的两大杀器：</p>
<ul>
<li>goroutine</li>
<li>channel</li>
</ul>
<span id="more"></span>

<h1 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h1><h1 id="共享内存并发机制"><a href="#共享内存并发机制" class="headerlink" title="共享内存并发机制"></a>共享内存并发机制</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> share_mem_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何完成线程安全机制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			counter++</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定小于 5000，也就是说线程不安全</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用锁来解决线程不安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			mut.Lock() <span class="comment">// 先加锁</span></span><br><span class="line">			counter++</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//在defer函数中释放锁</span></span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 强制主线程等待1秒钟，让所有的协程完成操作再退出.如果注释了就不等于5000了</span></span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定 ==  5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何让主线程智能的等待其他协程的完成再退出呢？ -- waitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5000</span> ; i++&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 增加一个要等待的量</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			mut.Lock() <span class="comment">// 先加锁</span></span><br><span class="line">			counter++</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//在defer函数中释放锁</span></span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			wg.Done() <span class="comment">// 减少一个要等待的量</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 主线程必须等到 wg == 0 时才往下执行</span></span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span> , counter) <span class="comment">// 肯定 ==  5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="WaitGroup信号量"><a href="#WaitGroup信号量" class="headerlink" title="WaitGroup信号量"></a>WaitGroup信号量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//一个计数的信号量，使用它的目的是要main函数等待两个goroutine执行完成后再结束</span></span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span> ; i &lt; <span class="number">100</span> ; i++&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A: &quot;</span> , i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;B: &quot;</span> , i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Wait方法的意思是如果计数器大于0，就会阻塞，所以main 函数会一直等待2个goroutine完成后，再结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行这个程序，会发现A和B前缀会交叉出现，并且每次运行的结果可能不一样，这就是Go调度器调度的结果</p>
<h2 id="并发资源竞争"><a href="#并发资源竞争" class="headerlink" title="并发资源竞争"></a>并发资源竞争</h2><p>有并发的情况就肯定会存在资源竞争的问题，如果两个goroutine在没有相互同步的情况下共同访问一个共享的资源，就会处于相互竞争的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	count <span class="keyword">int32</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是不确定的 ！！！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		value := count</span><br><span class="line">		runtime.Gosched() <span class="comment">// 当前goroutine暂停的意思，退回执行队列，让其他等待的goroutine运行</span></span><br><span class="line">		value++</span><br><span class="line">		count = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结论：<strong>我们对于同一个资源的读写必须是原子化的，也就是说，同一时间只能有一个goroutine对共享资源进行读写操作</strong></p>
<p>排查工具：</p>
<p><code>go build -race</code>命令。我们在当前项目目录下执行这个命令，生成一个可以执行文件，然后再运行这个可执行文件，就可以看到打印出的检测信息。</p>
<p>多加了一个<code>-race</code>标志，这样生成的可执行程序就自带了检测资源竞争的功能</p>
<p>如何解决并发资源竞争中的安全问题呢?</p>
<p>传统的方式就是加锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	count <span class="keyword">int32</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	mutex sync.Mutex <span class="comment">// 加锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过加锁来解决线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	<span class="keyword">go</span> inCount()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		mutex.Lock() <span class="comment">// 加锁</span></span><br><span class="line">		value := count</span><br><span class="line">		runtime.Gosched() <span class="comment">// 当前goroutine暂停的意思，退回执行队列，让其他等待的goroutine运行</span></span><br><span class="line">		value++</span><br><span class="line">		count = value</span><br><span class="line">		mutex.Unlock() <span class="comment">// 解锁，上面的代码称为临界区的代码，是线程安全的！</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道，他有点像在两个routine之间架设的管道，一个goroutine可以往这个管道里塞数据，另外一个可以从这个管道里取数据，有点类似于我们说的队列。</p>
<p>如果一个通道被关闭了，我们就不能往这个通道里发送数据了，如果发送的话，会引起<code>painc</code>异常。但是，我们还可以接收通道里的数据，如果通道里没有数据的话，接收的数据是<code>零值</code></p>
<h2 id="无缓冲的channel"><a href="#无缓冲的channel" class="headerlink" title="无缓冲的channel"></a>无缓冲的channel</h2><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。<strong>如果两个 goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待</strong>。</p>
<p>这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送goroutine和接收goroutine同时准备好，才可以完成发送和接收操作。  这种也称为 <strong>同步通道</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		ch &lt;- sum</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前面用过sync.WaitGroup 来实现主线程 等待协程运行完之后才退出</span></span><br><span class="line">	<span class="comment">// 这里的channel也可以，因为是一个同步通道。所以主线程在去通道里的数据是会一直阻塞，知道协程完成任务把值塞入到通道中去！！！</span></span><br><span class="line">	fmt.Println( &lt;- ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模拟两个协程打网球比赛：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 两个协程间的网球比赛</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	court := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>) <span class="comment">// 计数 + 2 表示需要等待两个协程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;binshow&quot;</span> , court)</span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;zkd&quot;</span> , court)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发球</span></span><br><span class="line">	court &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()<span class="comment">//等待两个协程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(name <span class="keyword">string</span>, court <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 函数退出是，调用done告诉main函数工作已经完成</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		ball , ok := &lt;- court</span><br><span class="line">		<span class="keyword">if</span> !ok &#123; <span class="comment">// 如果返回false说明</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s won \n&quot;</span> , name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选随机数，判断是否丢球</span></span><br><span class="line">		n := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		<span class="keyword">if</span> n % <span class="number">13</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s Missed \n&quot;</span> , name)</span><br><span class="line">			<span class="built_in">close</span>(court) <span class="comment">// 关闭通道，表示我们输了</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Player %s Hit %d\n&quot;</span>, name, ball)</span><br><span class="line">		ball++</span><br><span class="line"></span><br><span class="line">		court &lt;- ball <span class="comment">// 将球打向对手</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>模拟运动员接力比赛：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个无缓冲的通道</span></span><br><span class="line">	batch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>) <span class="comment">// 为最后一位跑步者将计数+1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Runner(batch)</span><br><span class="line"></span><br><span class="line">	batch &lt;- <span class="number">1</span> <span class="comment">//开始比赛</span></span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">//等待比赛结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接力比赛中的一位跑步者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待接力棒</span></span><br><span class="line">	runner := &lt;- baton</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Running With Baton \n&quot;</span> , runner)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> runner != <span class="number">4</span> &#123;</span><br><span class="line">		newRunner = runner + <span class="number">1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d To The Line \n&quot;</span> , newRunner)</span><br><span class="line">		<span class="keyword">go</span> Runner(baton)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始围绕跑道跑</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;开始围绕跑道跑&quot;)</span></span><br><span class="line">	time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> runner == <span class="number">4</span> &#123;</span><br><span class="line">		 fmt.Printf(<span class="string">&quot;Runner %d Finished , Race Over \n&quot;</span> , runner)</span><br><span class="line">		 wg.Done()  <span class="comment">// 只有第四名运动员跑完之后才 done</span></span><br><span class="line">		 <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将接力棒交给下一位跑步者</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Exchange With Runner %d \n&quot;</span> , runner , newRunner)</span><br><span class="line"></span><br><span class="line">	baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h2><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。</p>
<p>只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// 创建容量为3的有缓冲的通道</span></span><br></pre></td></tr></table></figure>



<p><strong>当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。</strong></p>
<p>能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	numberGoroutines = <span class="number">4</span> <span class="comment">// 要使用的goroutine的数量</span></span><br><span class="line">	taskLoad = <span class="number">10</span> <span class="comment">//要处理的工作数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创造一个有缓冲的通道来管理工作</span></span><br><span class="line">	tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span> , taskLoad)</span><br><span class="line"></span><br><span class="line">	wg.Add(numberGoroutines)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动协程来处理工作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numberGoroutines; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(tasks , i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加一组要完成的工作</span></span><br><span class="line">	<span class="keyword">for</span> post:=<span class="number">1</span> ; post &lt;= taskLoad ; post++&#123;</span><br><span class="line">		tasks &lt;- fmt.Sprintf(<span class="string">&quot;Task: %d&quot;</span> , post)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从有缓冲的通道传入的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(task <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="comment">// 等待分配工作</span></span><br><span class="line">		task , ok := &lt;- task</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// 这意味着通道已经空了，并且已经被关闭了</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Worker: %d : Shutting Down \n&quot;</span> , worker)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 要开始工作了</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker : %d : Started %s \n&quot;</span> , worker , task)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示我们完成了工作</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker : %d : Completed %s \n&quot;</span> , worker , task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="实现管道"><a href="#实现管道" class="headerlink" title="实现管道"></a>实现管道</h2><p>我们使用通道也可以做到管道的效果，我们只需要把一个通道的输出，当成下一个通道的输入即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChannel2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	one := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	two := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// g1 先运行 将 100 翻入channel one 中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		one &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// g2 因为要从 one中取数据，所以等g1放数据进去之后再运行。取出来放入 two中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		v := &lt;- one</span><br><span class="line">		two &lt;- v</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// main 因为要从 two中取数据，因此需要等 g2 将数据放入 two中才能继续运行</span></span><br><span class="line">	fmt.Println( &lt;- two) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="CSP并发机制"><a href="#CSP并发机制" class="headerlink" title="CSP并发机制"></a>CSP并发机制</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> csp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;working on something else&quot;</span>)</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Task is done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行的执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(service())</span><br><span class="line">	otherTask() <span class="comment">//TestService (0.16s) 耗时为 0.16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsyncService</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//retCh := make(chan string)</span></span><br><span class="line">	retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span> , <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ret := service()</span><br><span class="line">		fmt.Println(<span class="string">&quot;return result.&quot;</span>)</span><br><span class="line">		retCh &lt;- ret</span><br><span class="line">		fmt.Println(<span class="string">&quot;service exited.&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> retCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAsyncService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	retCh := AsyncService()</span><br><span class="line">	otherTask() <span class="comment">// 虽然是后面调用的，但是会被立即执行</span></span><br><span class="line">	fmt.Println(&lt;-retCh) <span class="comment">//TestAsyncService (0.11s)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	working on something else</span></span><br><span class="line"><span class="comment">	return result.</span></span><br><span class="line"><span class="comment">	Task is done.</span></span><br><span class="line"><span class="comment">	Done</span></span><br><span class="line"><span class="comment">	service exited.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSelect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> res := &lt;- AsyncService():</span><br><span class="line">		t.Log(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">		t.Error(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h1 id="多路选择和超时"><a href="#多路选择和超时" class="headerlink" title="多路选择和超时"></a>多路选择和超时</h1><p>多路复用的一般形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    <span class="comment">// ...use x...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个case代表一个通信操作(在某个channel上进行发送或者接收)并且会包含一些语句组成的一个语句块。</p>
<p>select 做的就是：选择处理列出的多个通信情况中的一个。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的。</li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ;;i++&#123;</span><br><span class="line">		ch &lt;- i * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ;;i++&#123;</span><br><span class="line">		ch &lt;- i+<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也是在无限循环中轮询输入的，通过 select 语句获取 ch1 和 ch2 的整数并输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sunk</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Recived On channel 1 : %d \n&quot;</span> , v)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-ch2:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Recived On channel 2 : %d \n&quot;</span> , v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSelect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> pump1(ch1)</span><br><span class="line">	<span class="keyword">go</span> pump2(ch2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> sunk(ch1 , ch2)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="并发的Clock服务"><a href="#并发的Clock服务" class="headerlink" title="并发的Clock服务"></a>并发的Clock服务</h2><p>server：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;net Listen failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//死循环</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err := listen.Accept() <span class="comment">// listen.Accept() 会阻塞当前线程，直到有连接进来返回一个conn</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;listen accept failed&quot;</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// handleConn(conn) // 处理连接：一次只能处理一个</span></span><br><span class="line">		<span class="keyword">go</span> handleConn(conn) <span class="comment">// 开启一个线程来处理连接</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理连接的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="comment">// 获取当前时间写入给客户端</span></span><br><span class="line">		_, err := io.WriteString(c, <span class="string">&quot;server1=&quot;</span> + time.Now().Format(<span class="string">&quot;15:05:03\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 说明客户端断开连接了</span></span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	mustCopy(os.Stdout , conn) <span class="comment">// 将连接传入的数据打印到控制台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer , src io.Reader)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>实现一个客户端接受多个服务器的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个客户端可以和多个服务器通信，并获取所有结果打印出来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一运行就退出:说明主线程直接退出了，协程还没来得及工作</span></span><br><span class="line">	<span class="keyword">go</span> dial(<span class="string">&quot;8000&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> dial(<span class="string">&quot;8001&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> dial(<span class="string">&quot;8002&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">20</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dial</span><span class="params">(port <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	address := <span class="string">&quot;localhost:&quot;</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, address+port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	mustCopy(os.Stdout , conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer , src io.Reader)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="并发的Echo服务"><a href="#并发的Echo服务" class="headerlink" title="并发的Echo服务"></a>并发的Echo服务</h2><p>Server:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToUpper(shout))</span><br><span class="line">	time.Sleep(delay)</span><br><span class="line">	fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, shout)</span><br><span class="line">	time.Sleep(delay)</span><br><span class="line">	fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">	input := bufio.NewScanner(c)</span><br><span class="line">	<span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">		echo(c, input.Text(), <span class="number">1</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">	c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;net Listen failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//死循环</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err := listen.Accept() <span class="comment">// listen.Accept() 会阻塞当前线程，直到有连接进来返回一个conn</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;listen accept failed&quot;</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// handleConn(conn) // 处理连接：一次只能处理一个</span></span><br><span class="line">		<span class="keyword">go</span> handleConn(conn) <span class="comment">// 开启一个线程来处理连接</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Client:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;io&quot;</span>	<span class="string">&quot;log&quot;</span>	<span class="string">&quot;net&quot;</span>	<span class="string">&quot;os&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;		log.Fatal(err)	&#125;	<span class="keyword">defer</span> conn.Close()	<span class="keyword">go</span> mustCopy(os.Stdout, conn)	mustCopy(conn, os.Stdin) <span class="comment">// &#125;func mustCopy(dst io.Writer , src io.Reader)  &#123;	if _, err := io.Copy(dst, src); err != nil &#123;		log.Fatal(err)	&#125;&#125;</span></span><br></pre></td></tr></table></figure>





<h1 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h1><ul>
<li><p>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息</p>
</li>
<li><p>每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
</li>
<li><p>使用内置的make函数，我们可以创建一个channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type &#x27;chan int&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p>
</li>
<li><p>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</p>
</li>
<li><p>一个channel有发送和接受两个主要操作，都是通信行为。</p>
</li>
<li><p><strong>Channel还支持close操作</strong>，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据.</p>
</li>
<li><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channelch = make(chan int, 0) // unbuffered channelch = make(chan int, 3) // buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h3><p><strong>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</strong></p>
<p>反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p>
<p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。</p>
<p>当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前（译注：<em>happens before</em>，这是Go语言并发内存模型的一个关键术语！）</p>
<p>常见场景：<strong>使得主线程等待其余的协程完成之后再退出</strong></p>
<p>比如上面的EchoClient：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个 无缓存channel</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 当前协程操作完之后向 done中 输入一个值</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		io.Copy(os.Stdout, conn) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">		log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// signal the main goroutine</span></span><br><span class="line">	&#125;()</span><br><span class="line">	mustCopy(conn, os.Stdin)</span><br><span class="line">	<span class="comment">//然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-ﬁle）结束的信号。</span></span><br><span class="line">	<span class="comment">//关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”</span></span><br><span class="line">	conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主线程在这里将channel中的值输出，如果channel中还没有值的话就会一直阻塞直到协程完成任务放值进去</span></span><br><span class="line">	&lt;-done <span class="comment">// wait for background goroutine to finish</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer , src io.Reader)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="练习题8-3"><a href="#练习题8-3" class="headerlink" title="练习题8.3"></a>练习题8.3</h4><p>在上面这个例子中，conn虽然是一个interface类型的值，但是其底层真实类型是*net.TCPConn，代表一个TCP连接。一个TCP连接有读和写两个部分，可以使用CloseRead和CloseWrite方法分别关闭它们。修改上面的主goroutine代码，只关闭网络连接中写的部分，这样的话后台goroutine可以在标准输入被关闭后继续打印从reverb1服务器传回的数据。</p>
<p>使用<strong>类型断言</strong>来完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;io&quot;</span>	<span class="string">&quot;log&quot;</span>	<span class="string">&quot;net&quot;</span>	<span class="string">&quot;os&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;		log.Fatal(err)	&#125;	<span class="comment">// 创建一个 无缓存channel	done := make(chan struct&#123;&#125;)	// 当前协程操作完之后向 done中 输入一个值	go func() &#123;		_, err := io.Copy(os.Stdout, conn)		log.Println(err)		log.Println(&quot;done&quot;)		done &lt;- struct&#123;&#125;&#123;&#125; // signal the main goroutine	&#125;()	mustCopy(conn, os.Stdin)	//类型断言，调用*net.TCPConn的方法CloseWrite()只关闭TCP的写连接	cw := conn.(*net.TCPConn)	cw.CloseWrite()	&lt;-done // wait for background goroutine to finish&#125;func mustCopy(dst io.Writer , src io.Reader)  &#123;	if _, err := io.Copy(dst, src); err != nil &#123;		log.Fatal(err)	&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="串联的Channels（Pipeline）"><a href="#串联的Channels（Pipeline）" class="headerlink" title="串联的Channels（Pipeline）"></a>串联的Channels（Pipeline）</h3><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）</p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><h1 id="基于共享变量的并发"><a href="#基于共享变量的并发" class="headerlink" title="基于共享变量的并发"></a>基于共享变量的并发</h1><h2 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h2><p>由前面的练习我们知道可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。</p>
<p>一个只能为1和0的信号量叫做二元信号量(binary semaphore)。比如下面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; , <span class="number">1</span>) <span class="comment">// 用一个大小为1的channel来保证共享变量在同一时间内只有一个goroutine在访问</span></span><br><span class="line">	balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">// 先将这个channel占满，再操作共享变量 balance</span></span><br><span class="line">	balance += amount</span><br><span class="line">	&lt;- sema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 先将这个channel占满，再读取共享变量 balance</span></span><br><span class="line">	b := balance</span><br><span class="line">	&lt;- sema</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> Deposit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;余额 = &quot;</span> , Balance()) <span class="comment">//余额 =  10000</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个大小为1的channel在go语言中非常实用，因此被表示为sync包中的Mutex：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">//sema = make(chan struct&#123;&#125; , 1) // 用一个大小为1的channel来保证共享变量在同一时间内只有一个goroutine在访问</span></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	balance += amount</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock() <span class="comment">// 用defer来调用Unlock，临界区会隐式地延伸到函数作用域的最后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> Deposit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;余额 = &quot;</span> , Balance()) <span class="comment">//余额 =  10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>设计一个安全的取款的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这样写的话会存在问题： 多个取款操作同时执行时，可能会导致一些取款被错误的拒绝。因为取款不是原子操作：</span></span><br><span class="line"><span class="comment">// 而包含了三个步骤，且每一步都需要去获取并是否互斥锁，任何一次锁不会锁住整个取款的流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw1</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	Deposit(-amount)</span><br><span class="line">	<span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">		 Deposit(amount)</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写也是错误的，因为 Deposit 会第二次去获取互斥锁，但go里面并没有重入锁的概念，这会导致死锁的发生。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw2</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	Deposit(-amount)</span><br><span class="line">	<span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">		Deposit(amount)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法应该如下：</span></span><br><span class="line"><span class="comment">//当你使用mutex时，确保mutex和其保护的变量没有被导出(在go里也就是小写，且不要被大写字母开头的函数访问啦)，</span></span><br><span class="line"><span class="comment">//无论这些变量是包级的变量还是一个struct的字段 !!!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	deposit(-amount)</span><br><span class="line">	<span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">		deposit(amount)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	balance += amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RWMutex读写锁"><a href="#RWMutex读写锁" class="headerlink" title="RWMutex读写锁"></a>RWMutex读写锁</h2></div><div class="article-licensing box"><div class="licensing-title"><p>Go入门之goroutine和channel</p><p><a href="http://example.com/2021/11/07/Go入门之goroutine和channel/">http://example.com/2021/11/07/Go入门之goroutine和channel/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/21/Spring%E4%B8%AD%E7%9A%84Bean/"><span class="level-item">Spring中的Bean</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">19</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#协程机制"><span class="level-left"><span class="level-item">1</span><span class="level-item">协程机制</span></span></a></li><li><a class="level is-mobile" href="#共享内存并发机制"><span class="level-left"><span class="level-item">2</span><span class="level-item">共享内存并发机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#WaitGroup信号量"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">WaitGroup信号量</span></span></a></li><li><a class="level is-mobile" href="#并发资源竞争"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">并发资源竞争</span></span></a></li></ul></li><li><a class="level is-mobile" href="#通道"><span class="level-left"><span class="level-item">3</span><span class="level-item">通道</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#无缓冲的channel"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">无缓冲的channel</span></span></a></li><li><a class="level is-mobile" href="#有缓冲的channel"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">有缓冲的channel</span></span></a></li><li><a class="level is-mobile" href="#实现管道"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">实现管道</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CSP并发机制"><span class="level-left"><span class="level-item">4</span><span class="level-item">CSP并发机制</span></span></a></li><li><a class="level is-mobile" href="#多路选择和超时"><span class="level-left"><span class="level-item">5</span><span class="level-item">多路选择和超时</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并发的Clock服务"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">并发的Clock服务</span></span></a></li><li><a class="level is-mobile" href="#并发的Echo服务"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">并发的Echo服务</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Channels"><span class="level-left"><span class="level-item">6</span><span class="level-item">Channels</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#不带缓存的Channels"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">不带缓存的Channels</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#练习题8-3"><span class="level-left"><span class="level-item">6.1.1.1</span><span class="level-item">练习题8.3</span></span></a></li></ul></li><li><a class="level is-mobile" href="#串联的Channels（Pipeline）"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">串联的Channels（Pipeline）</span></span></a></li><li><a class="level is-mobile" href="#单方向的Channel"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">单方向的Channel</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#基于共享变量的并发"><span class="level-left"><span class="level-item">7</span><span class="level-item">基于共享变量的并发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sync-Mutex互斥锁"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">sync.Mutex互斥锁</span></span></a></li><li><a class="level is-mobile" href="#RWMutex读写锁"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">RWMutex读写锁</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">80</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-07T14:09:37.000Z">2021-11-07</time></p><p class="title"><a href="/2021/11/07/Go%E5%85%A5%E9%97%A8%E4%B9%8Bgoroutine%E5%92%8Cchannel/">Go入门之goroutine和channel</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-21T13:04:42.000Z">2021-10-21</time></p><p class="title"><a href="/2021/10/21/Spring%E4%B8%AD%E7%9A%84Bean/">Spring中的Bean</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-11T02:36:47.000Z">2021-10-11</time></p><p class="title"><a href="/2021/10/11/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">算法题（九）栈和队列</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T16:43:12.000Z">2021-10-11</time></p><p class="title"><a href="/2021/10/11/Redis%EF%BC%88%E5%85%AB%EF%BC%89%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">Redis（八）缓存问题</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T12:51:32.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">操作系统（四）网络管理</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>