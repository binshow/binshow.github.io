<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>计算机网络（二）传输层 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="主要讲述的是传输层的一些协议：  UDP  TCP"><meta property="og:type" content="blog"><meta property="og:title" content="计算机网络（二）传输层"><meta property="og:url" content="http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="主要讲述的是传输层的一些协议：  UDP  TCP"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.jpeg"><meta property="article:published_time" content="2021-10-06T07:27:22.000Z"><meta property="article:modified_time" content="2021-10-17T12:50:07.478Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82/"},"headline":"计算机网络（二）传输层","image":[],"datePublished":"2021-10-06T07:27:22.000Z","dateModified":"2021-10-17T12:50:07.478Z","author":{"@type":"Person","name":"binshow"},"description":"主要讲述的是传输层的一些协议：  UDP  TCP"}</script><link rel="canonical" href="http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.jpeg" alt="计算机网络（二）传输层"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-06T07:27:22.000Z" title="2021/10/6 下午3:27:22">2021-10-06</time>发表</span><span class="level-item"><time dateTime="2021-10-17T12:50:07.478Z" title="2021/10/17 下午8:50:07">2021-10-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约6969个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">计算机网络（二）传输层</h1><div class="content"><p>主要讲述的是传输层的一些协议：</p>
<ul>
<li><p>UDP</p>
</li>
<li><p>TCP</p>
</li>
</ul>
<span id="more"></span>

<h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><h2 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h2><p>源端口号 + 目标端口号 + 长度 + 检验和 ， 共 8 个字节。</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006194631.png" alt="20211006194631" style="zoom:80%;" />



<h2 id="UDP的三大特点"><a href="#UDP的三大特点" class="headerlink" title="UDP的三大特点"></a>UDP的三大特点</h2><p>UDP只是做了运输协议能够做的最少工作，除了复用/分解功能及少量的差错检测外，它几乎没有增加别的东西，比如<strong>DNS就是一个使用UDP的典型例子</strong>，UDP协议具有以下特点：</p>
<ol>
<li><strong>无需连接建立</strong>: UDP无需任何准备可以立即开始进行数据传输，因此不会引入建立连接的时延。</li>
<li><strong>无连接状态</strong>: TCP通过一系列的参数来保证数据的可靠传输，而UDP无需这些参数，因此也不会保证可靠传输。</li>
<li><strong>首部开销小</strong>: UDP首部只有8字节，而TCP首部有20个字节。</li>
</ol>
<h2 id="UDP的应用场景"><a href="#UDP的应用场景" class="headerlink" title="UDP的应用场景"></a>UDP的应用场景</h2><ol>
<li><strong>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong>： DHCP 就是基于 UDP 协议的。一般的获取 IP 地址都是内网请求，而且一次获取不到 IP 又没事，过一会儿还有机会。</li>
<li><strong>不需要一对一沟通，建立连接，而是可以广播的应用</strong>：DHCP 就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。</li>
<li><strong>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong></li>
</ol>
<h2 id="UDP的改进举例"><a href="#UDP的改进举例" class="headerlink" title="UDP的改进举例"></a>UDP的改进举例</h2><p>todo</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>而<strong>QUIC</strong>（全称<strong>Quick UDP Internet Connections</strong>，<strong>快速 UDP 互联网连接</strong>）是 Google提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。QUIC 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层“城会玩”的代表。</p>
<h3 id="流媒体的协议"><a href="#流媒体的协议" class="headerlink" title="流媒体的协议"></a><strong>流媒体的协议</strong></h3><p>直播协议多使用 RTMP，不适合TCP。很多直播应用，都基于UDP 实现了自己的视频传输协议。</p>
<h3 id="实时游戏"><a href="#实时游戏" class="headerlink" title="实时游戏"></a><strong>实时游戏</strong></h3><p>实时游戏中客户端和服务端要建立长连接，来保证实时传输。游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p>全称是 <strong>Transmisslon Control Protocol</strong> 数据传输协议</p>
<h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><p><strong>占了20个字节</strong></p>
<img src="/Users/shengbinbin/Library/Application%20Support/typora-user-images/image-20211006194837729.png" alt="image-20211006194837729" style="zoom:80%;" />



<ol>
<li>源端口号和目标端口号：确定数据是从哪个应用要发送到哪个应用去。</li>
<li><strong>序号</strong>：为了解决乱序问题</li>
<li><strong>确认序号</strong>：可以解决不丢包的问题</li>
<li>首部长度</li>
<li><strong>状态位</strong>：SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等</li>
<li>窗口大小：<strong>该字段用于流量控制，用于指示接收方愿意接受的字节数量</strong></li>
<li>校验和</li>
</ol>
<h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><p>Transmisslon Control Protocol 数据传输协议</p>
<ol>
<li><strong>面向连接的</strong>:一个进程向另一个进程发送数据之前，必须相互发送某些预备报文段，以建立确保数据传输的参数作为 TCP 连接建立的 部分，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态变量</li>
<li><strong>全双工服务</strong>：如果一台主机上的进程A与另一台主机上的进程B存在一条 TCP 连接，那么应用层数据就可在从进程A流向进程B的同时，也从进程B流向进程A</li>
<li><strong>点对点的服务</strong>：在单个发送方与单个接收方之间的连接</li>
<li>基于<strong>字节流</strong>：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/ee8d8e6068334b7d8ef23349e947449d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="简述建立连接的三次握手"><a href="#简述建立连接的三次握手" class="headerlink" title="简述建立连接的三次握手"></a>简述建立连接的三次握手</h2><ol>
<li>客户端向服务端发送SYN报文（<strong>TCP首部的标志位上SYN=1，序号seq=x</strong>），进入SYN_SEND状态即同步已发送。</li>
<li>服务端受到客户端发来的SYN报文之后，会返回一个响应报文，这个响应报文中（<strong>首部标志位上SYN= 1，ACK = 1 ， 序号seq = y ， 确认序号ack =x+1</strong>），此时服务器进入SYN_RECV状态即同步已收到状态。</li>
<li>客户端受到服务端发送的响应报文之后，会继续向服务器发送一个确认报文（<strong>首部标志位SYN = 1 , 序号seq = x+1 , 确认序号 ack = y+1</strong>），这个报文发送完毕后客户端和服务端完成了三次握手。（这次的响应报文是可以携带数据的）</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/598145e4eab04009b995cfd15b767bda~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h3><ol>
<li><p>防止 重复历史连接的初始化</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006200144.png" alt="20211006200144" style="zoom:50%;" /></li>
<li><p>同步双方的初始的序列号seq，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，即Tcp会用这个序号进行拼接数据</p>
</li>
<li><p>避免资源浪费</p>
</li>
</ol>
<blockquote>
<p>不采用四次握手原因：可以将服务器对客户端SYN同步包的响应回复ACK，和服务器发送给客户端的SYN同步包合并起来，提高传输效率。 </p>
</blockquote>
<blockquote>
<p>不采用两次握手原因：</p>
<p>两次握手无法保证服务器和客户端就服务器的初始序列值没有达成一致。 TCP不会为没有数据的ACK重传！</p>
<p>两次握⼿会造成消息滞留情况下，服务器重复接受⽆⽤的连接请求 SYN 报⽂，⽽造成᯿复分配资源。</p>
</blockquote>
<h3 id="如果客户端发送了一次SYN包之后就掉线了会发生什么？"><a href="#如果客户端发送了一次SYN包之后就掉线了会发生什么？" class="headerlink" title="如果客户端发送了一次SYN包之后就掉线了会发生什么？"></a>如果客户端发送了一次SYN包之后就掉线了会发生什么？</h3><p>Server服务器端收到Client客户端发送的SYN，Server服务器端回复Client客户端SYN-ACK的时候，如果此时Client客户端掉线了，Server服务器端未收到Client客户端的ACK确认。那么该连接就处于一个中间状态，即未连接成功也未连接失败状态。</p>
<p>此时Server服务器端不断重试直至超时，Linux默认重试5次，重试间隔从1秒开始，每次翻倍，等待63秒钟，tcp才会断开连接。</p>
<h3 id="SYN-Flood攻击该如何防御？"><a href="#SYN-Flood攻击该如何防御？" class="headerlink" title="SYN Flood攻击该如何防御？"></a>SYN Flood攻击该如何防御？</h3><p>我们都知道 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答，久⽽久之就会<strong>占满服务端的 SYN 接收队列（未连接队列</strong>），使得服务器不能为正常⽤户服务。此时服务器可能遭受SYN Flood攻击的风险。 </p>
<p>针对SYN Flood攻击风险的防护措施。</p>
<p>比如恶意程序给服务器发送SYN报文，发送以后就进行了下线，然后服务器默认等待63秒才会断开，攻击者就会将服务器的SYN连接的队列耗尽，让正常的连接请求不能处理。</p>
<p>Linux系统给出了一个方案，当SYN队列满后，通过tcp_syncookies参数回发SYN Cookie。TCP根据源地址端口，目标目的端口，时间戳生成一个特殊的Sequence Number即SYN Cookie回发给客户端。如果是攻击者是不会有响应的，若为正常连接则Client客户端会回发服务器端SYN Cookie，直接建立连接。通过SYN Cookie创建的连接，即使现在SYN队列满后，本次连接请求不在队列中，也可以创建连接。 如果建立连接后，Client客户端出现故障怎么办呢，其实TCP设置保活机制，在一段时间内，该时间被称为保活时间keep alive time，在这段时间内，连接处于非活动状态，开启保活功能的一端将向对方发送保活探测报文。向对方发送保活探测报文，如果发送端未收到响应报文，如果在保活时间内即提前配置好的keep alive time则继续发送。直到尝试次数达到保活探测数仍未收到响应则中断连接。对方直接将被确认为不可达，连接即被中断。</p>
<h2 id="简述TCP的四次挥手"><a href="#简述TCP的四次挥手" class="headerlink" title="简述TCP的四次挥手"></a>简述TCP的四次挥手</h2><ol>
<li>客户端向服务端发送终止报文（TCP首部标志位 FIN = 1 , 序号seq = u）,客户端进入 FIN_WAIT_1状态即中止等待1的状态。这里Client作为先发起断开连接的一端说明客户端已经没有数据要发送了。</li>
<li>服务端收到客户端的终止报文后，会发送一个响应报文（TCP首部ACK = 1，序号seq = v , 确认序号ack = u+1），服务端进入CLOSE_WAIT状态即关闭等待状态。</li>
<li>服务端此时仍然可以继续发送数据。</li>
<li>服务端发送完数据之后，也会向客户端发送一个终止报文（TCP标志位 FIN = 1 ，ACK = 1 ，seq = w ，确认序号ack = u+1），Server进入LAST_ACK状态即最后确认状态。</li>
<li>客户端受到服务端的终止报文后，会进入TIME_WAIT状态即时间等待状态，最后发送一个确认报文给服务端（TCP标志位 ACK = 1， seq = u+1,确认序号ack = w+1）。需要等待2倍的MSL最大报文段生存时间，来保证连接的可靠关闭，之后client进入CLOSE关闭状态，server收到client的ack以后，直接进入close状态。</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2363765db0ee429998ee33d8001ca66b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="为什么会有TIME-WAIT状态？"><a href="#为什么会有TIME-WAIT状态？" class="headerlink" title="为什么会有TIME_WAIT状态？"></a>为什么会有TIME_WAIT状态？</h3><p>TIME-WAIT时间等待状态到CLOSE关闭状态，有一个超时设置，这个超时设置是2乘以MSL。为什么要等待这一段时间呢，TIME-WAIT状态主要是要确保有足够的时间让对方收到ACK包，如果被动关闭的哪一方没有收到ACK确认，就会触发被动端重发FIN包（FINISH包）一来一去正好是2乘以MSL。</p>
<blockquote>
<p>2MSL 的时间是从客户端接收到 <strong>FIN</strong> 后发送 <strong>ACK</strong> 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端᯿发的 FIN 报⽂，那么 <strong>2MSL</strong> 时间将重新计时。</p>
</blockquote>
<ol>
<li>这个时间⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</li>
<li>是等待⾜够的时间以确保最后的 <strong>ACK</strong> 能让被动关闭⽅接收，从⽽帮助其正常关闭。</li>
</ol>
<h3 id="为什么需要四次挥手才能断开连接呢？"><a href="#为什么需要四次挥手才能断开连接呢？" class="headerlink" title="为什么需要四次挥手才能断开连接呢？"></a>为什么需要四次挥手才能断开连接呢？</h3><ol>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。</li>
</ol>
<p>建立连接的时候，server端的SYN和ACK包是合并为一次发送。而断开连接的时候，两个方向的数据发送的停止时间可能是不同的，所以无法合并FIN和ACK包，FIN和ACK是分开发送的。</p>
<h3 id="2MSL后服务端还没收到ACK咋办"><a href="#2MSL后服务端还没收到ACK咋办" class="headerlink" title="2MSL后服务端还没收到ACK咋办"></a>2MSL后服务端还没收到ACK咋办</h3><p>按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p>
<h3 id="TIME-WAIT状态过多的危害"><a href="#TIME-WAIT状态过多的危害" class="headerlink" title="TIME_WAIT状态过多的危害"></a>TIME_WAIT状态过多的危害</h3><ul>
<li>第⼀是内存资源占⽤；</li>
<li>第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝</li>
</ul>
<h2 id="TCP如何保证可靠传输的"><a href="#TCP如何保证可靠传输的" class="headerlink" title="TCP如何保证可靠传输的"></a>TCP如何保证可靠传输的</h2><p>1.将应用数据被分割成 TCP 认为最适合发送的数据块。<br>2.确认机制，发送报文后，等待确认。<br>3.重发机制，没有收到确认，将重发数据段。<br>4.保持它首部和数据的校验和。 确认数据的准确性。<br>5.排序，丢弃重复的，流量控制。</p>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已收到消息。</p>
<ol>
<li>一种方法就是<strong>超时重试</strong>，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法</strong>（<strong>Adaptive Retransmission Algorithm</strong>）。<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍</strong>。<strong>两次超时，就说明网络环境差，不宜频繁反复发送</strong></li>
</ol>
<blockquote>
<p>估计往返时间，通常需要采样以下两个：</p>
<ol>
<li>需要 TCP 通过采样 RTT 的时间，然后进⾏加权平均，算出⼀个平滑 RTT 的值，⽽且这个值还是要不断变化的，因为⽹络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有⼀个⼤的波动的话，很难被发现的情况。</li>
</ol>
</blockquote>
<ol>
<li>有一个可以<strong>快速重传</strong>的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送<strong>三个冗余的 ACK</strong>，客户端收到后，就在定时器过期之前，重传丢失的报文段。快速重传解决了超时时间的问题，但是<strong>没解决是重传之前的一个还是重传所有的问题</strong></li>
</ol>
<p>SACK （ Selective Acknowledgment 选择性确认）： </p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211006202806.png" alt="20211006202806"></p>
<p>这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>微信聊天的时候是你发一句我发一句吗？这样效率是不是太低了？因此引入窗口的概念：</p>
<p>窗口的大小：<strong>指的是无需等待确认应答，可以继续发送数据的最大值。</strong></p>
<blockquote>
<p>我们可以将窗口理解为操作系统的一个缓存空间，发送方主机在等待确认应答返回之前，必须在缓冲区中保留已经发送的数据，如果按期受到了确认应答，此时数据就可以从缓存区中清除。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006215707.png" alt="20211006215707" style="zoom:50%;" />

<p>窗口大小是由哪一边决定的？</p>
<p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。所以，<strong>通常窗⼝的⼤⼩是由接收⽅的窗⼝⼤⼩来决定的。</strong></p>
<p>发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。</p>
<p>发送方的滑动窗口：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006215848.png" alt="20211006215848" style="zoom:50%;" />



<p>当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽，在没收到ACK 确认之前是⽆法继续发送数据了：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006220707.png" alt="20211006220707" style="zoom:50%;" />



<p>当32<del>36之间的字节ACK确认应答之后，如果发送窗口没有发送变化，则滑动窗口往右边移动5个字节，接下来的52</del>56就又变成了可用窗口了：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006220924.png" alt="20211006220924" style="zoom:50%;" />





<p>接收方的滑动窗口：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006221034.png" alt="20211006221034" style="zoom:50%;" />



<p>发送方的滑动窗口和接收方的滑动窗口一定是相等的吗？</p>
<p>并不是完全相等，接收窗⼝的⼤⼩是约等于发送窗⼝的⼤⼩的。</p>
<p><strong>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接收窗⼝可以很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。</strong></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p><strong>流量控制是为了避免 发送方的数据填满了接收方的缓存，并不知道网络中发送了什么。</strong></p>
<p>实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，会被操作系统调整。</p>
<p>利用<strong>滑动窗口机制</strong>可以很方便的在TCP连接上实现对发送方的流量控制。<br>那怎么进行流量控制呢？ 接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小。发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。</p>
<p>那发送方何时再继续发送数据呢? 当发送方收到接受窗口 win = 0 时，这时发送方停止发送报文，并且同时开启一个定时器(持续计时器），每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。 那窗口大小怎么设置呢？</p>
<p>举例：当应用程序没有及时读取缓存时，发送窗口和接受窗口的变化：</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211006223256.png" alt="20211006223256"></p>
<ol>
<li><p>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。</p>
</li>
<li><p>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了 <strong>120</strong> 字节，当收到 <strong>140</strong> 字节数据后，⼜因为应⽤程序没有读取任何数据，所以 <strong>140</strong> 字节留在了缓冲区中，于是接收窗⼝⼤⼩从 <strong>360</strong> 收缩成了 <strong>100</strong>，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。</p>
</li>
<li><p>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。</p>
</li>
<li><p>服务端收到了 180 字节数据时，发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。</p>
</li>
<li><p>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。</p>
<p>所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。</p>
</li>
</ol>
<p>为了防⽌这种情况发⽣，<strong>TCP</strong> 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时间再减少缓存，这样就可以避免了丢包情况。</p>
<p>窗口关闭的潜在风险：</p>
<p>接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的。</p>
<p>那么，当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006223632.png" alt="20211006223632" style="zoom:50%;" />



<p>解决办法：加一个计时器打破这个死锁</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006223536.png" alt="20211006223536" style="zoom:50%;" />



<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>所谓拥塞控制就是<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</strong>，维护了一个拥塞窗口的概念。</p>
<p><strong>拥塞窗口cwnd ： 发送方维护的一个状态变量，会根据网络的拥塞程度动态的变化。</strong></p>
<blockquote>
<p>有了拥塞窗口后，发送窗口的值 swnd = Math.min(cwnd , rwnd),也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
</blockquote>
<p>如何判断网络发生了堵塞：发生了<code>超时重传</code>即认为网络阻塞了。</p>
<ol>
<li><strong>慢启动</strong>:</li>
</ol>
<p>当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(RTT)呈<strong>指数级增长</strong>，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。</p>
<ol start="2">
<li><strong>拥塞避免</strong>:</li>
</ol>
<p>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，<strong>当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段</strong>。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始<strong>加法增加</strong>。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p>
<ol start="3">
<li><strong>快速重传</strong>:</li>
</ol>
<p>当发生了超时重传时，慢启动门限变为原来的一般，拥塞窗口重置为1：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006222553.png" alt="20211006222553" style="zoom:50%;" />

<p>当发生了快速重传：拥塞窗口变为原来的一半，慢启动门限 = 拥塞窗口当前值，进入快速恢复算法</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006222845.png" alt="20211006222845" style="zoom:50%;" />







<p>总结：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006222940.png" alt="20211006222940" style="zoom:50%;" />











<h2 id="TCP连接中的计时器有哪几种？"><a href="#TCP连接中的计时器有哪几种？" class="headerlink" title="TCP连接中的计时器有哪几种？"></a>TCP连接中的计时器有哪几种？</h2><ol>
<li><strong>超时重传计时器</strong>（60s）：当TCP发送报文段时，就创建该特定报文段的重传计时器。</li>
<li><strong>持续计时器</strong>（60s）：用于流量控制，在接收端发送接收窗口大小=0报文后，发送端在持续计时器超时后，发送探询消息试探接收窗口的大小，以此来避免接收端重新发送&gt;0的窗口报文给发送方时出现报文丢失，造成双方僵持等待的死锁情况。</li>
<li><strong>保活计时器</strong>（2h）：保活计时器用来防止两个TCP之间的连续出现长时间的空闲。</li>
<li><strong>时间等待计时</strong>器(2MSL)：当客户端进入TIME-WAIT状态的时候，链接还没有释放掉，必须等待2倍的MSL(最长报文段寿命)后，客户端才能关闭连接。在时间等待期间，链接还处于一种过渡状态。</li>
</ol>
<h2 id="简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别"><a href="#简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别" class="headerlink" title="简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别"></a>简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别</h2><p>同： 两者的现象都是丢包，实现机制都是让发送方发的慢一点，发的少一点。<br>异： 拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。拥塞控制的丢包发生在路由器上，流量控制的丢包发生在接收端。</p>
<p><strong>滑动窗口一般指接收窗口</strong>，接收器窗口是接收器可以获取数据包的缓冲区，用于流量控制，而拥塞窗口用于拥塞控制。</p>
<p><strong>TCP真正的发送窗口=min(rwnd,cwnd)。</strong></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>计算机网络（二）传输层</p><p><a href="http://example.com/2021/10/06/计算机网络（二）传输层/">http://example.com/2021/10/06/计算机网络（二）传输层/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">计算机网络（三）网络层</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"><span class="level-item">计算机网络（一）应用层</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">109</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#UDP协议"><span class="level-left"><span class="level-item">1</span><span class="level-item">UDP协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#UDP报文段结构"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">UDP报文段结构</span></span></a></li><li><a class="level is-mobile" href="#UDP的三大特点"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">UDP的三大特点</span></span></a></li><li><a class="level is-mobile" href="#UDP的应用场景"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">UDP的应用场景</span></span></a></li><li><a class="level is-mobile" href="#UDP的改进举例"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">UDP的改进举例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#QUIC"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">QUIC</span></span></a></li><li><a class="level is-mobile" href="#流媒体的协议"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">流媒体的协议</span></span></a></li><li><a class="level is-mobile" href="#实时游戏"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">实时游戏</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#TCP协议"><span class="level-left"><span class="level-item">2</span><span class="level-item">TCP协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TCP报文段结构"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">TCP报文段结构</span></span></a></li><li><a class="level is-mobile" href="#TCP协议的特点"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">TCP协议的特点</span></span></a></li><li><a class="level is-mobile" href="#简述建立连接的三次握手"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">简述建立连接的三次握手</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么是三次握手"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">为什么是三次握手</span></span></a></li><li><a class="level is-mobile" href="#如果客户端发送了一次SYN包之后就掉线了会发生什么？"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">如果客户端发送了一次SYN包之后就掉线了会发生什么？</span></span></a></li><li><a class="level is-mobile" href="#SYN-Flood攻击该如何防御？"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">SYN Flood攻击该如何防御？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#简述TCP的四次挥手"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">简述TCP的四次挥手</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么会有TIME-WAIT状态？"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">为什么会有TIME_WAIT状态？</span></span></a></li><li><a class="level is-mobile" href="#为什么需要四次挥手才能断开连接呢？"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">为什么需要四次挥手才能断开连接呢？</span></span></a></li><li><a class="level is-mobile" href="#2MSL后服务端还没收到ACK咋办"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">2MSL后服务端还没收到ACK咋办</span></span></a></li><li><a class="level is-mobile" href="#TIME-WAIT状态过多的危害"><span class="level-left"><span class="level-item">2.4.4</span><span class="level-item">TIME_WAIT状态过多的危害</span></span></a></li></ul></li><li><a class="level is-mobile" href="#TCP如何保证可靠传输的"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">TCP如何保证可靠传输的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#重传机制"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">重传机制</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">滑动窗口</span></span></a></li><li><a class="level is-mobile" href="#流量控制"><span class="level-left"><span class="level-item">2.5.3</span><span class="level-item">流量控制</span></span></a></li><li><a class="level is-mobile" href="#拥塞控制"><span class="level-left"><span class="level-item">2.5.4</span><span class="level-item">拥塞控制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#TCP连接中的计时器有哪几种？"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">TCP连接中的计时器有哪几种？</span></span></a></li><li><a class="level is-mobile" href="#简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">简述流量控制（滑动窗口rwnd）和拥塞控制（拥塞窗口cwnd）的相同点和区别</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">94</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-11T15:17:17.000Z">2022-01-11</time></p><p class="title"><a href="/2022/01/11/CLion%E7%BC%96%E5%86%99%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F/">CLion编写多个程序</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-09T15:07:17.000Z">2022-01-09</time></p><p class="title"><a href="/2022/01/09/Go-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%E5%92%8C%E5%8F%91%E5%B1%95/">Go_协程的历史和发展</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-08T13:06:43.000Z">2022-01-08</time></p><p class="title"><a href="/2022/01/08/CSAPP%EF%BC%88%E5%9B%9B%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">CSAPP（四）虚拟内存</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-06T15:25:41.000Z">2022-01-06</time></p><p class="title"><a href="/2022/01/06/CSAPP%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">CSAPP（三）存储结构</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-06T15:25:30.000Z">2022-01-06</time></p><p class="title"><a href="/2022/01/06/CSAPP%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA/">CSAPP（二）信息表示</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2022 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>