<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>计算机网络（一）应用层 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="主要讲述的是应用层的一些协议：  HTTP DNS DHCP FTP"><meta property="og:type" content="blog"><meta property="og:title" content="计算机网络（一）应用层"><meta property="og:url" content="http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="主要讲述的是应用层的一些协议：  HTTP DNS DHCP FTP"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1.jpeg"><meta property="article:published_time" content="2021-10-06T07:27:08.000Z"><meta property="article:modified_time" content="2021-10-06T11:44:04.117Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"},"headline":"计算机网络（一）应用层","image":[],"datePublished":"2021-10-06T07:27:08.000Z","dateModified":"2021-10-06T11:44:04.117Z","author":{"@type":"Person","name":"binshow"},"description":"主要讲述的是应用层的一些协议：  HTTP DNS DHCP FTP"}</script><link rel="canonical" href="http://example.com/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1.jpeg" alt="计算机网络（一）应用层"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-06T07:27:08.000Z" title="2021/10/6下午3:27:08">2021-10-06</time>发表</span><span class="level-item"><time dateTime="2021-10-06T11:44:04.117Z" title="2021/10/6下午7:44:04">2021-10-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">1 小时读完 (大约12456个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">计算机网络（一）应用层</h1><div class="content"><p>主要讲述的是应用层的一些协议：</p>
<ul>
<li>HTTP</li>
<li>DNS</li>
<li>DHCP</li>
<li>FTP</li>
</ul>
<span id="more"></span>



<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。</p>
<h2 id="1-浏览器输入网址，发生哪些过程"><a href="#1-浏览器输入网址，发生哪些过程" class="headerlink" title="1.浏览器输入网址，发生哪些过程"></a>1.浏览器输入网址，发生哪些过程</h2><ol>
<li><p>你先在浏览器里面输入<strong>URL</strong>: <a target="_blank" rel="noopener" href="https://www.taobao.com/">https://www.taobao.com</a> 。浏览器只知道名字是“<a target="_blank" rel="noopener" href="http://www.taobao.com”,但是不知道具体的地点,所以不知道应该如何访问.于是,它打开地址簿去查找.可以使用一般的地址簿协议**dns**去查找,还可以使用另一种更加精准的地址簿查找协议**httpdns**./">www.taobao.com”，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿协议**DNS**去查找，还可以使用另一种更加精准的地址簿查找协议**HTTPDNS**。</a></p>
</li>
<li><p>通过DNS获得ip地址，这是是互联网世界的“门牌号”</p>
</li>
<li><p>浏览器开始打包请求，普通的请求用http，加密的用https。</p>
</li>
<li><p>下一层是<strong>传输层</strong>。传输层有两种协议，一种是无连接的协议<strong>UDP</strong>，一种是面向连接的协议<strong>TCP</strong>。TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。</p>
</li>
<li><p>传输层封装完毕后，浏览器会将包交给操作系统的<strong>网络层</strong>。网络层的协议是 IP 协议。在 IP协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</p>
</li>
<li><p>操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人（是否在同一个网段），如果在同一个网段，通过ip地址就能找到目标主机，如果不在，就需要通过网关。而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址192.168.1.1。</p>
</li>
<li><p>操作系统根据192.168.1.1的IP地址，在本地网段中大吼一声，网关就会回复它自己的MAC地址。（ARP协议）</p>
</li>
<li><p>操作系统将 IP 包交给了下一层，也就是<strong>MAC 层</strong>。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关</p>
<img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503130409390.png" alt="image-20210503130409390" style="zoom:50%;" /></li>
<li><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。相邻的路由器会经常沟通去哪里该怎么走，这种沟通的协议称为<strong>路由协议</strong>，常用的有<strong>OSPF</strong>和<strong>BGP</strong>。 </p>
</li>
<li><p>通过封装下一个路由器的MAC地址，找到下一个路由器。就这样依次下去</p>
</li>
<li><p>最后一个路由器就是和服务端IP地址在同一个网段中，大吼一声，目标服务器就会传过来一个MAC地址，通过这个 MAC 地址就能找到目标服务器。</p>
</li>
<li><p>目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即<strong>TCP 层</strong>。</p>
</li>
<li><p>在TCP层，对每一个收到的包都会有一个回复，说明包收到了。发送端的TCP如果一段时间内没收到回复确认，就会闷头重试。</p>
</li>
<li><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号<img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503131019860.png" alt="image-20210503131019860" style="zoom:50%;" />、</p>
</li>
<li><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。通过RPC调用找到负责相关服务的服务主机进行请求。</p>
</li>
<li><p>当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。</p>
</li>
</ol>
<h2 id="2-为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？"><a href="#2-为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？" class="headerlink" title="2.为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？"></a>2.为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？</h2><p>局域网内IP地址是动态分配的，假如我是192.168.2.100，如果我下线了，可能IP就分配给了另一台电脑。IP和设备并不总是对应的，这对通信就产生了问题，但是MAC地址不同，MAC地址和设备是一一对应且全球唯一的。所以局域网使用MAC地址通信没有问题。</p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p><img src="https://raw.githubusercontent.com/binshow/img/master/16f22ad122eb4f74~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<ol>
<li><p>协议方案名。 使用http：或https：等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。 <strong>也可使用data：或javascript：这类指定数据或脚本程序的方案名</strong>。</p>
</li>
<li><p>登录信息（认证） 指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p>
</li>
<li><p>服务器地址 使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名</p>
</li>
<li><p>查询字符串 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p>
</li>
<li><p>片段标识符 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p>
</li>
</ol>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><ul>
<li>将URL通过DNS拿到对应的IP地址</li>
<li>HTTP是基于 TCP 协议的，会先进行三次握手（后续章节再讲）</li>
<li>发送HTTP请求报文：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/16f262e041400a16~tplv-t2oaga2asx-watermark-20211006153913164.awebp" alt="img"></p>
<h3 id="请求报文三个组成"><a href="#请求报文三个组成" class="headerlink" title="请求报文三个组成"></a>请求报文三个组成</h3><ul>
<li>请求行（方法 + URI + 协议版本）</li>
<li>请求首部字段</li>
<li>内容实体</li>
</ul>
<h3 id="不同的HTTP方法"><a href="#不同的HTTP方法" class="headerlink" title="不同的HTTP方法"></a>不同的HTTP方法</h3><ol>
<li><strong>GET</strong> ，就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到底要返回什么，是由服务器端的实现决定的</li>
<li><strong>POST</strong>，它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON，比如支付场景，客户端就需要把“我是谁？我要支付多少？我要买啥？”告诉服务器，这就需要通过 POST 方法</li>
<li><strong>PUT</strong>，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而PUT 往往是用来修改一个资源的。</li>
<li><strong>DELETE</strong>。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 DELETE 方法</li>
<li><strong>HEAD</strong>，和get方法一样，只是不放回报文的主体部分。</li>
<li><strong>OPTIONS</strong>：询问支持的方法，响应报文会返回当前服务器所支持的方法：比如 <code>Allow:GET,POST,HEAD,OPTIONS</code></li>
</ol>
<h3 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h3><p>先说明下安全和幂等的概念：</p>
<ul>
<li><p>在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。</p>
</li>
<li><p>所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。</p>
</li>
</ul>
<p>再说一下两者的应用：</p>
<ul>
<li>Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</li>
<li>POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</li>
</ul>
<p>所以 Get方法是安全且幂等的，而post方法由于会修改服务器上的资源，所以是不安全的。</p>
<h3 id="请求报文常见首部字段"><a href="#请求报文常见首部字段" class="headerlink" title="请求报文常见首部字段"></a>请求报文常见首部字段</h3><p>请求行下面就是我们的首部字段。首部是 key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。</p>
<ol>
<li><strong>Accept-Charset</strong>，表示<strong>客户端可以接受的字符集</strong>。防止传过来的是另外的字符集，从而导致出现乱码</li>
<li><strong>Content-Type</strong>是指<strong>正文的格式</strong>。例如，我们进行 POST 的请求，如果正文是JSON，那么我们就应该将这个值设置为 JSON</li>
<li><strong>Cache-control</strong>是用来<strong>控制缓存</strong>的，当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。</li>
<li><strong>If-Modified-Since</strong>：如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。</li>
<li><strong>Host</strong>: 用于客户端发送请求时用来指定服务器的域名。比如<a target="_blank" rel="noopener" href="http://www.baidu.com中的baidu就是域名./">www.baidu.com中的baidu就是域名。</a></li>
<li><strong>Connection</strong>: 客户端要求服务器使⽤ TCP 持久连接,，以便其他请求复⽤。从HTTP1.1开始默认都是持久连接了。</li>
</ol>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><h3 id="响应报文三个组成"><a href="#响应报文三个组成" class="headerlink" title="响应报文三个组成"></a>响应报文三个组成</h3><ul>
<li>状态行（版本 + 状态码 + 状态码的原因短语）</li>
<li>响应首部字段</li>
<li>内容实体</li>
</ul>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p><strong>1XX：正在允许</strong></p>
<p><strong>2XX：运行成功</strong></p>
<p><strong>3XX：重定向</strong>：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">状态码意思</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100 continue</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">200 OK</td>
<td align="center">请求成功，实体的主体部分已经包含了资源</td>
</tr>
<tr>
<td align="center">201 Created</td>
<td align="center">用于创建服务器对象的请求（比如put）</td>
</tr>
<tr>
<td align="center">202  Accepted</td>
<td align="center">请求已经被接收，但服务器还没对其执行任何动作</td>
</tr>
<tr>
<td align="center">204 No Content</td>
<td align="center">请求已经成功处理，但是返回的响应报文不包含实体的主体部分</td>
</tr>
<tr>
<td align="center">206 Partial Content</td>
<td align="center">表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">301 Moved Permanently</td>
<td align="center">永久重定向，返回的响应首部字段中Location包含了资源现在的URL</td>
</tr>
<tr>
<td align="center">302 Found</td>
<td align="center">表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问</td>
</tr>
<tr>
<td align="center">303 see other</td>
<td align="center">告知客户端应该用另一个URL获取资源。</td>
</tr>
<tr>
<td align="center">304 Not Modified</td>
<td align="center">客户端发起get请求而资源没有发生改变，说明资源没有发生改变，响应中也不应该包含实体的主体部分</td>
</tr>
<tr>
<td align="center">305 Use Proxy</td>
<td align="center">用来说明必须通过一个代理来访问资源，代理的位置由Location给出</td>
</tr>
<tr>
<td align="center">307  Temporary Redirect</td>
<td align="center">临时重定向，客户端应该使用Location给出的URL来定位临时资源，但将来的请求还是应该用老的URL</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动᯿定向新的 URL。</strong> </p>
<table>
<thead>
<tr>
<th align="center">4XX 客户端错误</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">400 Bad Request</td>
<td>请求报文中存在语法错误</td>
</tr>
<tr>
<td align="center">401 Unauthorized</td>
<td>未认证，需要认证</td>
</tr>
<tr>
<td align="center">403  Forbidden</td>
<td>请求被服务器拒绝（通常不说明拒绝原因）</td>
</tr>
<tr>
<td align="center">404 Not Found</td>
<td>无法找到对应的URL资源</td>
</tr>
<tr>
<td align="center">405 Method Not Allowed</td>
<td>方法不被允许</td>
</tr>
<tr>
<td align="center">408 Request Timeout</td>
<td>请求超时</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">5XX 服务器错误</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">500 Internal Server Error</td>
<td>服务器正在执行请求时发生错误</td>
</tr>
<tr>
<td align="center">502 Bad Gateway</td>
<td>网关或代理服务器从上游服务器收到无效的请求</td>
</tr>
<tr>
<td align="center">503 Service Unavailable</td>
<td>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求，这个是临时的，一段时间后恢复</td>
</tr>
<tr>
<td align="center">504 Gateway Timeout</td>
<td>网关或代理服务器没能及时从上游服务器收到响应</td>
</tr>
<tr>
<td align="center"><strong>501 Not Implemented</strong></td>
<td>表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="响应报文常见首部字段"><a href="#响应报文常见首部字段" class="headerlink" title="响应报文常见首部字段"></a>响应报文常见首部字段</h3><ol>
<li><strong>Retry-After</strong>表示，告诉客户端应该在多长时间以后再次尝试一下。“503 错误”是说“服务暂时不再和这个值配合使用</li>
<li><strong>Content-Type</strong>，表示返回的是 HTML，还是 JSON。</li>
</ol>
<h2 id="Http1-1的优化"><a href="#Http1-1的优化" class="headerlink" title="Http1.1的优化"></a>Http1.1的优化</h2><p>HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：</p>
<ul>
<li><p>使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。</p>
</li>
<li><p>⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</p>
</li>
</ul>
<p>优化思路：</p>
<ul>
<li>避免发送HTTP请求 — 缓存优化</li>
<li>减少HTTP请求：</li>
<li>减少HTTP响应的数据大小</li>
</ul>
<h3 id="缓存的应用"><a href="#缓存的应用" class="headerlink" title="缓存的应用"></a>缓存的应用</h3><p>客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。</p>
<p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006155138.png" alt="20211006155138" style="zoom:80%;" />

<p>既然有缓存，可以就需要解决<strong>缓存一致性</strong>的问题了：</p>
<p>万⼀缓存的响应不是最新的，⽽客户端并不知情，那么该怎么办呢？</p>
<ul>
<li>服务器在发送 HTTP 响应时，会估算⼀个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新新发送⽹络请求。</li>
</ul>
<p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是⽼样⼦，那么你觉得还要在服务器的响应带上这个资源吗？</p>
<ul>
<li>只需要客户端在重新发送请求时，在请求的 Etag 头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。</li>
<li>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</li>
<li>如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的 304 Not Modified 304 Not Modified 响应，告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时，</li>
</ul>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006155252.png" alt="20211006155252" style="zoom:80%;" />





<h3 id="减少请求"><a href="#减少请求" class="headerlink" title="减少请求"></a>减少请求</h3><p>方法：</p>
<ul>
<li>减少重定向</li>
<li>合并请求</li>
<li>延迟发送请求</li>
</ul>
<blockquote>
<p>重定向请求是指服务器上的一个资源转移到了另外一个url上面了，而客户端并不知道。它还是会继续请求原来的url，这时候服务器需要通过返回302状态码和Location头部字段表示资源已经换地方存储了，这时客户端根据URL2再去获取资源。</p>
<p>因此重定向请求需要多次发送HTTP请求，需要减少。</p>
</blockquote>
<p>另外，服务端这⼀⽅往往不只有⼀台服务器，⽐如源服务器上⼀级是代理服务器，然后代理服务器才与客户端通信，这时客户端᯿定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006160643.png" alt="20211006160643" style="zoom:50%;" />

<p>如果重定向的⼯作交由代理服务器完成，就能减少 <strong>HTTP</strong> 请求次数了，如下图：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006160734.png" alt="20211006160734" style="zoom:50%;" />



<p>合并请求的⽅式就是合并资源，以⼀个⼤资源的请求替换多个⼩资源的请求。</p>
<p>延迟发送请求的意思：请求⽹⻚的时候，没必要把全部资源都获取到（比如全部的URL），⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p>
<h3 id="减少响应数据大小"><a href="#减少响应数据大小" class="headerlink" title="减少响应数据大小"></a>减少响应数据大小</h3><p>通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率，所以应当选择更优秀的压缩算法。</p>
<h2 id="Http2-0的优化"><a href="#Http2-0的优化" class="headerlink" title="Http2.0的优化"></a>Http2.0的优化</h2><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p><strong>头部压缩</strong>：HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p>
<p>为⾼频出现在头部的字符串和字段建⽴了⼀张静态表表中的 Index 表示索引（Key）， Header Value 表示索引对应的 Value， Header Name 表示字段的名字，⽐如Index 为 2 代表 GET，Index 为 8 代表状态码 200。</p>
<ul>
<li><img src="https://raw.githubusercontent.com/binshow/img/master/20211006191929.png" alt="20211006191929" style="zoom:50%;" />**</li>
</ul>
<h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><ol>
<li><p><strong>二进制分帧</strong>：HTTP/2 厉害的地⽅在于将 HTTP/1 的⽂本格式改成<strong>⼆进制格式传输数据</strong>，<strong>极⼤提⾼了 HTTP 传输效率</strong>，⽽且⼆进制数据使⽤位运算能⾼效解析。常见的帧有<strong>Header 帧</strong>，用于传输 Header 内容，并且会开启一个新的流。再就是<strong>Data 帧</strong>，用来传输正文实体。多个 Data 帧属于同一个流。</p>
<ul>
<li><img src="https://raw.githubusercontent.com/binshow/img/master/20211006192128.png" alt="20211006192128" style="zoom:50%;" /></li>
</ul>
</li>
</ol>
<p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p>
<p>举例子：假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p> HTTP/1.1 的实现是基于<strong>请求-响应模型</strong>的。同⼀个连接中，HTTP 完成⼀个事务（请求与响应），才能处理下⼀个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是⽆法发送的，也造成了队头阻塞的问题。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211006192509.png" alt="20211006192509"></p>
<ul>
<li>HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。</li>
<li>Stream ⾥可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li>
<li>Message ⾥包含⼀条或者多个 Frame，Frame 是 HTTP/2 最⼩单位，以⼆进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</li>
</ul>
<p><strong>HTTP 消息可以由多个 Frame 构成，以及 1 个 Frame 可以由多个 TCP 报⽂构成。</strong></p>
<p>在 HTTP/2 连接上，不同 <strong>Stream</strong> 的帧是可以乱序发送的（因此可以并发不同的 <strong>Stream</strong> ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，<strong>⽽同⼀ Stream 内部的帧必须是严格有序的</strong>。</p>
<p>HTTP/2 通过 Stream 实现的并发，⽐ HTTP/1.1 通过 TCP 连接实现并发要⽜逼的多，因为当 <strong>HTTP/2</strong> 实现 <strong>100</strong> 个并发 <strong>Stream</strong> 时，只需要建⽴⼀次 <strong>TCP</strong> 连接，⽽ <strong>HTTP/1.1</strong> 需要建⽴ <strong>100</strong> 个 <strong>TCP</strong> 连接，每个 <strong>TCP</strong> 连接都要经过<strong>TCP</strong> 握⼿、慢启动以及 <strong>TLS</strong> 握⼿过程，这些都是很耗时的。</p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/1.1 不⽀持服务器主动推送资源给客户端，都是由客户端向服务器发起请求后，才能获取到服务器响应的资源。</p>
<p>⽐如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML ⽂件，⽽ HTML 可能还需要依赖 CSS 来渲染⻚⾯，这时客户端还要再发起获取 CSS ⽂件的请求，需要两次消息往返，如下图左边部分：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006192902.png" alt="20211006192902" style="zoom:50%;" />



<p>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS ⽂件，减少了消息传递的次数。</p>
<p><strong>如何实现服务端推送的呢？</strong></p>
<p>客户端发起的请求，必须使⽤的是奇数号 Stream，服务器主动的推送，使⽤的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211006193144.png" alt="20211006193144" style="zoom:50%;" />

<p>服务器推送资源时，会先发送 PUSH_PROMISE帧，告诉客户端接下来在哪个 Stream 发送资源，然后⽤偶数号 Stream 发送资源给客户端</p>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><ol>
<li><p> HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</p>
</li>
<li><p> HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</p>
</li>
<li><p>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</p>
</li>
<li><p> HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ol>
<h3 id="HTTP的问题"><a href="#HTTP的问题" class="headerlink" title="HTTP的问题"></a>HTTP的问题</h3><h3 id="HTTPS的解决方法"><a href="#HTTPS的解决方法" class="headerlink" title="HTTPS的解决方法"></a>HTTPS的解决方法</h3><p>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。</p>
<p>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。</p>
<p>将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。</p>
<blockquote>
<p>SSL 是洋⽂ “<em>Secure Sockets Layer</em> 的缩写，中⽂叫做「安全套接层」。它是在上世纪 90 年代中期，由⽹景公司</p>
<p>设计的。</p>
<p>到了1999年，SSL 因为应⽤⼴泛，已经成为互联⽹上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名</p>
<p>称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中⽂叫做 「传输层安全协议」。</p>
<p>很多相关的⽂章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同⼀个东⻄的不同阶段。</p>
</blockquote>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><ol>
<li><strong>在对称加密算法中，加密和解密使用的密钥是相同的</strong>。也就是说，加密和解密使用的是同一个密钥。</li>
<li><strong>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的</strong>。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</li>
</ol>
<p>因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以交互的场景下多用对称加密。</p>
<h3 id="混合加密的工作方式"><a href="#混合加密的工作方式" class="headerlink" title="混合加密的工作方式"></a>混合加密的工作方式</h3><img src="https://raw.githubusercontent.com/binshow/img/master/20211006162111.png" alt="20211006162111" style="zoom:50%;" />

<p>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。</p>
<p>⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。</p>
<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>主要用于实现数据的完整性：</p>
<p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211006162303.png" alt="20211006162303"></p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p>
<p>证书里面有什么呢？当然应该有<strong>公钥</strong>，这是最重要的；还有证书的<strong>所有者</strong>，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的<strong>发布机构</strong>和证书的<strong>有效期</strong>，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p>
<p>证书请求可以通过这个命令生成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req</span><br></pre></td></tr></table></figure>

<p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为<strong>签名算法</strong>。问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。</p>
<p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p>
<p>权威机构给证书签名的命令是这样的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.ke</span><br></pre></td></tr></table></figure>

<p>这个命令会返回 Signature ok，而 cliu8sitecertificate.pem 就是签过名的证书。CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。我们来查看这个证书的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cliu8sitecertificate.pem -noout -text </span><br></pre></td></tr></table></figure>

<p>这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public-key 是公钥内容；Signature Algorithm 是签名算法。</p>
<p>这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。你有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA的公钥就是对的呢？</p>
<p>所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为<strong>root CA</strong>，做最后的背书。通过这种<strong>层层授信背书</strong>的方式，从而保证了非对称加密模式的正常运转。除此之外，还有一种证书，称为<strong>Self-Signed Certificate</strong>，就是自己给自己签名。这个给人一种“我就是我，你爱信不信”的感觉。这里我就不多说了。</p>
<h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><p><strong>公钥私钥主要用于传输对称加密的秘钥</strong>，而真正的双方大数据量的通信都是通过对称加密进行的。</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211006162533.png" alt="20211006162533"></p>
<ol>
<li>客户端向服务器发起加密通信请求ClientHello，在这一步客户端主要向服务端发送下面的数据<ul>
<li>客户端支持的SSL/TLS的版本</li>
<li>客户端产生的随机数a</li>
<li>客户端支持的加密算法</li>
</ul>
</li>
<li>服务器受到客户端的ClientHello之后，会回复一个响应，响应主要包括：<ul>
<li>确认SSL/TLS版本号</li>
<li>服务器产生的随机数b</li>
<li>确认加密算法</li>
<li>服务器的数字证书</li>
</ul>
</li>
<li>客户端受到服务器的回应之后，会先通过浏览器或者操作系统中的CA公钥确认服务器给的数字证书真实性。如果证书没问题。会再生成一个随机数c，从服务器给的证书中的公钥对这个随机数c进行加密传输给服务器。</li>
<li>这样的话客户端和服务端都有3个随机数abc了，通过前面协商的加密算法，计算出本次会话的对称密钥，后续就用这个对称密钥来加密传输了。</li>
</ol>
<p><strong>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书</strong></p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p>
<p><strong>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态,用来让服务端记住客户端。</strong></p>
<p>过程：</p>
<ul>
<li>请求报文(首次请求)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">HOST: hacker.jp</span><br><span class="line">* 首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure>

<ul>
<li>响应报文(服务端生成Cookie信息)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">.....</span><br><span class="line">server: Apache &lt;Set-Cookie: sid=12313123121; path=/; .......&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>请求报文(第二次请求)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Cookie: sid=12313123121</span><br><span class="line">这样二次请求的时候，服务端通过cookie会记住上一次访问的是谁</span><br></pre></td></tr></table></figure>






<h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><h2 id="素质三连"><a href="#素质三连" class="headerlink" title="素质三连"></a>素质三连</h2><p><strong>DNS是什么</strong>：</p>
<p>将ip地址和域名相互转换的协议。比如：下面的<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的ip地址就是110.242.68.4</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shengbinbin @ binshow in ~ [12:45:53]</span></span><br><span class="line">$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (110.242.68.4): 56 data bytes</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=0 ttl=53 time=14.868 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=1 ttl=53 time=23.293 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=2 ttl=53 time=14.054 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=3 ttl=53 time=23.775 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=4 ttl=53 time=20.637 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=5 ttl=53 time=22.940 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=6 ttl=53 time=22.268 ms</span><br><span class="line">64 bytes from 110.242.68.4: icmp_seq=7 ttl=53 time=22.558 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">8 packets transmitted, 8 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 14.054/20.549/23.775/3.625 ms</span><br></pre></td></tr></table></figure>

<p><strong>为什么要DNS：</strong></p>
<p>IP地址的长度是固定32位的（如果是IPv6，就是128位），人们很难记住。转换成域名就比较好记住了。</p>
<p><strong>DNS是怎么实现的：</strong></p>
<p>通过使用<strong>分布式</strong>的域名系统DNS：当一个应用程序需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名解析器，本地域名服务器查找后，就返回对应的IP地址。应用进程获得目的的IP地址后即可进行通信。若本地域名服务器无法解析，就向上一层的域名服务器上查找，直到找到。</p>
<h2 id="域名的结构"><a href="#域名的结构" class="headerlink" title="域名的结构"></a>域名的结构</h2><blockquote>
<p>mail.cctv.com中 com 为顶级域名，cctv为二级域名,mail为三级域名。级别最低的写在最左边，而级别最高的顶级域名写在最右边。</p>
<p>通用顶级域名：com(公司企业) net(网络服务机构) org(非营利性组织) int(国际组织) edu(美国专用教育机构) gov(美国政府机构) mil(美国军事机构) 等等共有20个。</p>
<p>国家顶级域名： cn(中国)  us(美国) 等等</p>
<p>反向域名：arpa,用于反向解析</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/16ebf64cef01ada5~tplv-t2oaga2asx-watermark.awebp" alt="互联网域名空间"></p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>采用<strong>层次树状结构</strong>的命名方法，并使用<strong>分布式</strong>的域名系统DNS。</p>
<p>互联网的域名系统DNS被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS让大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此NDS系统<strong>效率</strong>很高。<strong>由于DNS是分布式系统，即便单个计算机出了故障，也不会妨碍整个DNS系统正常运行</strong>。</p>
<p>域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为 <strong>域名服务器</strong>。</p>
<p>分类：</p>
<ul>
<li><p>根域名服务器。最高层次，最重要的域名服务器。</p>
</li>
<li><p>顶级域名服务器。诸如com cn gov 这种的。</p>
</li>
<li><p>权限域名服务器。负责一个区的域名服务器。</p>
</li>
<li><p>本地域名服务器。<strong>当一台主机发出DNS查询请求，这个查询请求报文就发送给本地域名服务器</strong>。每个ISP，或一个大学都可以拥有一个本地域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。<em>当所要查询的主机也同属于同一个ISP时，该本地域名服务器立即就能把要查询的主机名转换为她的IP地址，而不需要去询问其他的域名服务器。</em></p>
</li>
</ul>
<h2 id="域名查询的两种方式"><a href="#域名查询的两种方式" class="headerlink" title="域名查询的两种方式"></a>域名查询的两种方式</h2><ul>
<li><p><strong>递归查询</strong></p>
<p>假如主机A想访问主机B。主机A输入B的域名后，先是到本地域名服务器查询，查询不到，本地域名服务器以DNS客户的身份代表主机A去访问根域名服务器，若还是查询不到，根域名服务器如法炮制去到下面一级的顶级域名服务器查询，直到拿到主机B的IP地址。然后原路返回，给主机A。</p>
</li>
<li><p><strong>迭代查询</strong></p>
<p>当根域名服务器收到本地域名服务器发出的请求报文时，要么给出IP地址，要么告诉本地域名服务器“下一步应该向哪一个域名服务器进行查询”，直到有域名服务器给出IP地址。</p>
</li>
</ul>
<p><strong>注意：主机向本地域名服务器查询一般采用递归查询。本地域名服务器向根域名服务器查询通常采用迭代查询。</strong></p>
<h2 id="高速缓存加速"><a href="#高速缓存加速" class="headerlink" title="高速缓存加速"></a>高速缓存加速</h2><p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量，在<strong>域名系统服务器</strong>中广泛使用了高速缓存。高速缓存用来存放<strong>最近查询过的域名</strong>以及从何处获得域名映射信息的记录。</p>
<p>许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且在缓存中找不到名字时才使用域名服务器。</p>
<h2 id="DNS解析详细流程"><a href="#DNS解析详细流程" class="headerlink" title="DNS解析详细流程"></a>DNS解析详细流程</h2><ol>
<li>电脑客户端会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 是啥啊，会先查本地的DNS缓存。如果没有进行第二步</li>
<li>发给本地域名服务器 (本地 DNS)。那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。</li>
<li>本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应IP 地址的大表格。如果能找到 <a target="_blank" rel="noopener" href="http://www.163.com,它直接就返回/">www.163.com，它直接就返回</a> IP 地址。如果没有，本地DNS 会去问它的根域名服务器：“老大，能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”根域名服务器是最高层次的，全球共有 13 套。它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求，发现后缀是 .com，说：“哦，<a target="_blank" rel="noopener" href="http://www.163.com啊,这个域名是由.com/">www.163.com啊，这个域名是由.com</a> 区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。”</li>
<li>本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些一级域名，它负责管理二级域名，比如 163.com，所以它能提供一条更清晰的方向。</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到。”</li>
<li>本地 DNS 转向问权威 DNS 服务器：“您好，<a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 对应的 IP 是啥呀？”163.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权限 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503150417333.png" alt="image-20210503150417333" style="zoom:50%;" />

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>站在客户端角度，这是一次<strong>DNS 递归查询过程。</strong>因为本地 DNS 全权为它效劳，它只要坐等结果即可。在这个过程中，DNS 除了可以通过名称映射为 IP 地址，它还可以做另外一件事，就是<strong>负载均衡</strong>。</p>
<p>例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p>
<p><strong>全局负载均衡</strong>：</p>
<p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p>
<h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><h2 id="素质三连-1"><a href="#素质三连-1" class="headerlink" title="素质三连"></a>素质三连</h2><p><strong>是什么</strong>：</p>
<p>一个连接到互联网的计算机的协议软件需要配置的项目包括：</p>
<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>默认路由器的IP地址</li>
<li>域名服务器的IP地址</li>
</ul>
<p>为了省去给计算机配置IP地址的麻烦， 能否在计算机的生产过程中，事先给一台计算机配置好一个唯一的IP地址。（如同每一个以太网适配器拥有一个唯一的硬件的地址）</p>
<p><strong>为什么：</strong></p>
<p><strong>之所以出现了静态IP和动态IP，是因为IP地址不够用。现在需要上网的人太多了，但是现有的技术条件满足不了所有人同时上网</strong></p>
<p><strong>如何做：</strong></p>
<p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段lP地址范围，客户机登录服务器时就可以自动获得服务器分配的lP地址和子网掩码。它提供一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p>
<h2 id="DHCP配置ip流程解析"><a href="#DHCP配置ip流程解析" class="headerlink" title="DHCP配置ip流程解析"></a>DHCP配置ip流程解析</h2><ol>
<li>需要IP地址的主机在启动时就向<strong>DHCP服务器广播发送发现报文（将目的IP设置为全1，即255.255.255.255）</strong>。这时，该主机就成为了DHCP客户。</li>
<li>这台主机因为还没有IP地址，所以将IP数据报的源IP地址设置为全0.这样在本地网络上的所有主机都能接收到这个广播报文，<strong>但只有DHCP服务器才对这广播进行应答</strong></li>
<li>DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息。若找不到，则从服务器的<strong>IP地址池</strong>中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文，表示提供了IP地址等配置信息。</li>
</ol>
<h1 id="CDN内容分发网络"><a href="#CDN内容分发网络" class="headerlink" title="CDN内容分发网络"></a>CDN内容分发网络</h1><h2 id="CDN的就近配送"><a href="#CDN的就近配送" class="headerlink" title="CDN的就近配送"></a>CDN的就近配送</h2><p>全球有这么多的数据中心，无论在哪里上网，临近不远的地方基本上都有数据中心。是不是可以在这些数据中心里部署几台机器，形成一个缓存的集群来缓存部分数据，那么用户访问数据的时候，就可以就近访问了呢？</p>
<p>当然是可以的。这些分布在各个地方的各个数据中心的节点，就称为<strong>边缘节点</strong>。</p>
<p>由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中，这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。</p>
<img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503151942893.png" alt="image-20210503151942893" style="zoom:50%;" />



<h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>CDN 分发网络也是一个分布在多个区域、多个运营商的分布式系统，也可以用相同的思路选择最合适的边缘节点。</p>
<img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503152205309.png" alt="image-20210503152205309" style="zoom:50%;" />

<p><strong>在没有 CDN 的情况下</strong>，用户向浏览器输入 <a target="_blank" rel="noopener" href="http://www.web.com/">www.web.com</a> 这个域名，客户端访问本地DNS 服务器的时候，如果本地 DNS 服务器有缓存，则返回网站的地址；如果没有，递归查询到网站的权威 DNS 服务器，这个权威 DNS 服务器是负责 web.com 的，它会返回网站的 IP 地址。本地 DNS 服务器缓存下 IP 地址，将 IP 地址返回，然后客户端直接访问这个 IP 地址，就访问到了这个网站。</p>
<p>然而<strong>有了 CDN 之后，情况发生了变化</strong>。在 web.com 这个权威 DNS 服务器上，会设置一个 CNAME 别名，指向另外一个域名 <a target="_blank" rel="noopener" href="http://www.web.cdn.com,返回给本地/">www.web.cdn.com，返回给本地</a> DNS 服务器。当本地 DNS 服务器拿到这个新的域名时，需要继续解析这个新的域名。这个时候，再访问的就不是 web.com 的权威 DNS 服务器了，而是 web.cdn.com 的权威 DNS 服务器，这是 CDN 自己的权威 DNS 服务器。在这个服务器上，还是会设置一个 CNAME，指向另外一个域名，也即 CDN 网络的全局负载均衡器。接下来，本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：</p>
<p>根据用户 IP 地址，判断哪一台服务器距用户最近；</p>
<ol>
<li><p>用户所处的运营商；</p>
</li>
<li><p>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</p>
</li>
<li><p>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</p>
</li>
</ol>
<p>基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的 IP 地址。</p>
<p>本地 DNS 服务器缓存这个 IP 地址，然后将 IP 返回给客户端，客户端去访问这个边缘节点，下载资源。缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p>
<h2 id="缓存的内容"><a href="#缓存的内容" class="headerlink" title="缓存的内容"></a>缓存的内容</h2><img src="/Users/shengbinbin/Library/Application%2520Support/typora-user-images/image-20210503152407898.png" alt="image-20210503152407898" style="zoom:50%;" />

<p>还记得这个<strong>接入层缓存的架构</strong>吗？在进入数据中心的时候，我们希望通过最外层接入层的缓存，将大部分静态资源的访问拦在边缘。而 CDN 则更进一步，将这些静态资源缓存到离用户更近的数据中心外。越接近客户，访问性能越好，时延越低。</p>
<p>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链机制。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>计算机网络（一）应用层</p><p><a href="http://example.com/2021/10/06/计算机网络（一）应用层/">http://example.com/2021/10/06/计算机网络（一）应用层/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">计算机网络（二）传输层</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"><span class="level-item">操作系统（二）进程和线程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、概述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-浏览器输入网址，发生哪些过程"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.浏览器输入网址，发生哪些过程</span></span></a></li><li><a class="level is-mobile" href="#2-为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">2.为什么根据IP地址就能找到目标主机，却还需要Mac地址呢？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HTTP协议"><span class="level-left"><span class="level-item">2</span><span class="level-item">HTTP协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本概念"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">基本概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#URL解析"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">URL解析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#请求报文"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">请求报文</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#请求报文三个组成"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">请求报文三个组成</span></span></a></li><li><a class="level is-mobile" href="#不同的HTTP方法"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">不同的HTTP方法</span></span></a></li><li><a class="level is-mobile" href="#Get和Post的区别"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">Get和Post的区别</span></span></a></li><li><a class="level is-mobile" href="#请求报文常见首部字段"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">请求报文常见首部字段</span></span></a></li></ul></li><li><a class="level is-mobile" href="#响应报文"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">响应报文</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#响应报文三个组成"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">响应报文三个组成</span></span></a></li><li><a class="level is-mobile" href="#常见状态码"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">常见状态码</span></span></a></li><li><a class="level is-mobile" href="#响应报文常见首部字段"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">响应报文常见首部字段</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Http1-1的优化"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Http1.1的优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缓存的应用"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">缓存的应用</span></span></a></li><li><a class="level is-mobile" href="#减少请求"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">减少请求</span></span></a></li><li><a class="level is-mobile" href="#减少响应数据大小"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">减少响应数据大小</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Http2-0的优化"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Http2.0的优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#头部压缩"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">头部压缩</span></span></a></li><li><a class="level is-mobile" href="#二进制分帧"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">二进制分帧</span></span></a></li><li><a class="level is-mobile" href="#多路复用"><span class="level-left"><span class="level-item">2.5.3</span><span class="level-item">多路复用</span></span></a></li><li><a class="level is-mobile" href="#服务端推送"><span class="level-left"><span class="level-item">2.5.4</span><span class="level-item">服务端推送</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HTTPS协议"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">HTTPS协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#HTTP的问题"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">HTTP的问题</span></span></a></li><li><a class="level is-mobile" href="#HTTPS的解决方法"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">HTTPS的解决方法</span></span></a></li><li><a class="level is-mobile" href="#对称加密和非对称加密"><span class="level-left"><span class="level-item">2.6.3</span><span class="level-item">对称加密和非对称加密</span></span></a></li><li><a class="level is-mobile" href="#混合加密的工作方式"><span class="level-left"><span class="level-item">2.6.4</span><span class="level-item">混合加密的工作方式</span></span></a></li><li><a class="level is-mobile" href="#摘要算法"><span class="level-left"><span class="level-item">2.6.5</span><span class="level-item">摘要算法</span></span></a></li><li><a class="level is-mobile" href="#数字证书"><span class="level-left"><span class="level-item">2.6.6</span><span class="level-item">数字证书</span></span></a></li><li><a class="level is-mobile" href="#TLS握手过程"><span class="level-left"><span class="level-item">2.6.7</span><span class="level-item">TLS握手过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Cookie和Session"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">Cookie和Session</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DNS协议"><span class="level-left"><span class="level-item">3</span><span class="level-item">DNS协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#素质三连"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">素质三连</span></span></a></li><li><a class="level is-mobile" href="#域名的结构"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">域名的结构</span></span></a></li><li><a class="level is-mobile" href="#域名服务器"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">域名服务器</span></span></a></li><li><a class="level is-mobile" href="#域名查询的两种方式"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">域名查询的两种方式</span></span></a></li><li><a class="level is-mobile" href="#高速缓存加速"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">高速缓存加速</span></span></a></li><li><a class="level is-mobile" href="#DNS解析详细流程"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">DNS解析详细流程</span></span></a></li><li><a class="level is-mobile" href="#负载均衡"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">负载均衡</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态主机配置协议DHCP"><span class="level-left"><span class="level-item">4</span><span class="level-item">动态主机配置协议DHCP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#素质三连-1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">素质三连</span></span></a></li><li><a class="level is-mobile" href="#DHCP配置ip流程解析"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">DHCP配置ip流程解析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CDN内容分发网络"><span class="level-left"><span class="level-item">5</span><span class="level-item">CDN内容分发网络</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CDN的就近配送"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">CDN的就近配送</span></span></a></li><li><a class="level is-mobile" href="#负载均衡-1"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">负载均衡</span></span></a></li><li><a class="level is-mobile" href="#缓存的内容"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">缓存的内容</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">69</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-09T02:02:01.000Z">2021-10-09</time></p><p class="title"><a href="/2021/10/09/%E4%BC%98%E6%83%A0%E5%88%B8%E9%A1%B9%E7%9B%AE/">优惠券项目</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:40:04.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%94%81/">MySQL（十一）锁</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:39:51.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%EF%BC%89%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97/">MySQL（十）回滚日志</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:58.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E4%B9%9D%EF%BC%89%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/">MySQL（九）日志详解</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:41.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/">MySQL（八）事务</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>