<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL（八）事务 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="事务是由一组SQL语句组成的逻辑处理单元，而锁可以保证事务的隔离性。"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL（八）事务"><meta property="og:url" content="http://example.com/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="事务是由一组SQL语句组成的逻辑处理单元，而锁可以保证事务的隔离性。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/MySQL8.jpeg"><meta property="article:published_time" content="2021-10-08T14:05:41.000Z"><meta property="article:modified_time" content="2021-10-08T15:42:56.259Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="MySQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/MySQL8.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/"},"headline":"MySQL（八）事务","image":[],"datePublished":"2021-10-08T14:05:41.000Z","dateModified":"2021-10-08T15:42:56.259Z","author":{"@type":"Person","name":"binshow"},"description":"事务是由一组SQL语句组成的逻辑处理单元，而锁可以保证事务的隔离性。"}</script><link rel="canonical" href="http://example.com/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/MySQL8.jpeg" alt="MySQL（八）事务"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-08T14:05:41.000Z" title="2021/10/8下午10:05:41">2021-10-08</time>发表</span><span class="level-item"><time dateTime="2021-10-08T15:42:56.259Z" title="2021/10/8下午11:42:56">2021-10-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">2 小时读完 (大约16614个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL（八）事务</h1><div class="content"><p>事务是由一组SQL语句组成的逻辑处理单元，而锁可以保证事务的隔离性。</p>
<span id="more"></span>

<h1 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h1><h2 id="事务的起源"><a href="#事务的起源" class="headerlink" title="事务的起源"></a>事务的起源</h2><p>对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个<code>account</code>表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;,</span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>狗哥和猫爷是一对好基友，他们都到银行开一个账户，他们在现实世界中拥有的资产就会体现在数据库世界的<code>account</code>表中。比如现在狗哥有<code>11</code>元，猫爷只有<code>2</code>元，那么现实中的这个情况映射到数据库的<code>account</code>表就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br></pre></td></tr></table></figure>

<p>在某个特定的时刻，狗哥猫爷这些家伙在银行所拥有的资产是一个特定的值，这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态。随着时间的流逝，狗哥和猫爷可能陆续进行向账户中存钱、取钱或者向别人转账等操作，这样他们账户中的余额就可能发生变动，<span style="color:red">每一个操作都相当于现实世界中账户的一次状态转换</span>。数据库世界作为现实世界的一个映射，自然也要进行相应的变动。不变不知道，一变吓一跳，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。比方说有一次猫爷在赌场赌博输了钱，急忙打电话给狗哥要借10块钱，不然那些看场子的就会把自己剁了。现实世界中的狗哥走向了ATM机，输入了猫爷的账号以及10元的转账金额，然后按下确认，狗哥就拔卡走人了。对于数据库世界来说，相当于执行了下边这两条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure>

<p>但是这里头有个问题，上述两条语句只执行了一条时忽然服务器断电了咋办？把狗哥的钱扣了，但是没给猫爷转过去，那猫爷还是逃脱不了被砍死的噩运～  即使对于单独的一条语句，我们前边唠叨<code>Buffer Pool</code>时也说过，在对某个页面进行读写访问时，都会先把这个页面加载到<code>Buffer Pool</code>中，之后如果修改了某个页面，也不会立即把修改同步到磁盘，而只是把这个修改了的页面加到<code>Buffer Pool</code>的<code>flush链表</code>中，在之后的某个时间点才会刷新到磁盘。如果在将修改过的页刷新到磁盘之前系统崩溃了那岂不是猫爷还是要被砍死？或者在刷新磁盘的过程中（只刷新部分数据到磁盘上）系统奔溃了猫爷也会被砍死？</p>
<p>怎么才能保证让可怜的猫爷不被砍死呢？其实再仔细想想，我们只是想<span style="color:red">让某些数据库操作符合现实世界中状态转换的规则</span>而已，设计数据库的大叔们仔细盘算了盘算，现实世界中状态转换的规则有好几条，待我们慢慢道来。</p>
<h2 id="事务的四个基本属性"><a href="#事务的四个基本属性" class="headerlink" title="事务的四个基本属性"></a>事务的四个基本属性</h2><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p>
<p><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</p>
<p><strong>C (Consistency) 一致性</strong>：一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</p>
<p><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</p>
<p><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</p>
<h2 id="并发事务会带来的问题"><a href="#并发事务会带来的问题" class="headerlink" title="并发事务会带来的问题"></a>并发事务会带来的问题</h2><p><strong>更新丢失</strong>（Lost Update)： 事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</p>
<p>**脏读(Dirty Reads)**：读到了其他事务还没有提交的数据。</p>
<p>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p>
<p><strong>幻读（Phantom Reads</strong>)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p><strong>幻读和不可重复读的区别：</strong></p>
<ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<h2 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h2><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，<strong>需要应用程序对要更新的数据加必要的锁来解决</strong>，因此，防止更新丢失应该是应用的责任。</p>
<p>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：</p>
<ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li>
</ul>
<h2 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h2><p><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p>
<p><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p>
<p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>
<p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong></p>
<p>InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生.</p>
<h2 id="介绍一下MVCC"><a href="#介绍一下MVCC" class="headerlink" title="介绍一下MVCC"></a>介绍一下MVCC</h2><p>Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术，MVCC 的实现是<strong>通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。</strong></p>
<h3 id="MVCC在innodb中的实现"><a href="#MVCC在innodb中的实现" class="headerlink" title="MVCC在innodb中的实现"></a>MVCC在innodb中的实现</h3><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现：</p>
<ol>
<li>db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。</li>
<li><strong>db_trx_id</strong>：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。</li>
<li><strong>db_roll_ptr</strong>：回滚指针，也就是指向这个记录的 <strong>Undo Log</strong> 信息。</li>
</ol>
<p><img src="/Users/shengbinbin/Documents/MacBookHexoBlog/blog/source/_posts/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/%2525E5%25258F%2525B6%2525E5%2525AD%252590%2525E7%2525BB%252593%2525E7%252582%2525B9%2525E6%2525AE%2525B5.png" alt="叶子结点段"></p>
<p>InnoDB 将行记录快照保存在了 Undo Log 里，我们可以在回滚段中找到它们：</p>
<p><img src="/Users/shengbinbin/Documents/MacBookHexoBlog/blog/source/_posts/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/undolog.png" alt="undolog段"></p>
<p>从图中你能看到回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id，也是那个时间点操作这个数据的事务 ID。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找</p>
<p>如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 Read View 了，它帮我们解决了行的可见性问题。<strong>Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表</strong></p>
<p><img src="/Users/shengbinbin/Documents/MacBookHexoBlog/blog/source/_posts/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/readview.png" alt="readview"></p>
<p>在 Read VIew 中有几个重要的属性：</p>
<ol>
<li>trx_ids，系统当前正在活跃的事务 ID 集合。</li>
<li>low_limit_id，活跃的事务中最大的事务 ID。</li>
<li>up_limit_id，活跃的事务中最小的事务 ID。</li>
<li>creator_trx_id，创建这个 Read View 的事务 ID。</li>
</ol>
<p>假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id，那么会出现以下几种情况：</p>
<ol>
<li>如果 trx_id &lt; 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。</li>
<li>如果 trx_id &gt; 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。</li>
<li>如果 up_limit_id &lt; trx_id &lt; low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们<strong>需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见</strong></li>
</ol>
<p>总而言之，当我们查询一条记录的时候，系统如何通过多版本并发控制技术找到它：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取 Read View；</li>
<li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 <strong>Undo Log</strong> 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>InnoDB 中，MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。</p>
<blockquote>
<p>在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View</p>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View</p>
</blockquote>
<h3 id="innodb如何解决幻读的问题"><a href="#innodb如何解决幻读的问题" class="headerlink" title="innodb如何解决幻读的问题"></a>innodb如何解决幻读的问题</h3><p><strong>在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。</strong></p>
<h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p>InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p>
<p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p>
<p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p>
<p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p>
<p>事务日志可以帮助提高事务效率：</p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p>
<h2 id="事务的ACID是如何保证实现的"><a href="#事务的ACID是如何保证实现的" class="headerlink" title="事务的ACID是如何保证实现的"></a>事务的ACID是如何保证实现的</h2><p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p>
<p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p>
<ul>
<li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p>
<p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p>
</li>
<li><p><strong>undo log（回滚日志）</strong>  实现一致性</p>
<p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p>
</li>
</ul>
<p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<blockquote>
<p>又引出个问题：你知道MySQL 有多少种日志吗？</p>
</blockquote>
<ul>
<li><p><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</p>
</li>
<li><p><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</p>
</li>
<li><p><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</p>
</li>
<li><p><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</p>
</li>
<li><p><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</p>
</li>
<li><p><strong>事务日志</strong>：重做日志redo和回滚日志undo</p>
</li>
</ul>
<h2 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h2><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734bff37e532a33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="MySQL中事务的语法"><a href="#MySQL中事务的语法" class="headerlink" title="MySQL中事务的语法"></a>MySQL中事务的语法</h2><p>我们说<code>事务</code>的本质其实只是一系列数据库操作，只不过这些数据库操作符合<code>ACID</code>特性而已，那么<code>MySQL</code>中如何将某些操作放到一个事务里去执行的呢？我们下边就来重点唠叨唠叨。</p>
<h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>我们可以使用下边两种语句之一来开启一个事务：</p>
<ul>
<li><p><code>BEGIN [WORK];</code></p>
<p><code>BEGIN</code>语句代表开启一个事务，后边的单词<code>WORK</code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li>
<li><p><code>START TRANSACTION;</code></p>
<p><code>START TRANSACTION</code>语句和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure>

<p>不过比<code>BEGIN</code>语句牛逼一点儿的是，可以在<code>START TRANSACTION</code>语句后边跟随几个<code>修饰符</code>，就是它们几个：</p>
<ul>
<li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
</li>
<li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
</li>
<li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读（先不用关心啥是个一致性读，后边的章节才会唠叨）。</p>
</li>
</ul>
<p>比如我们想开启一个只读事务的话，直接把<code>READ ONLY</code>这个修饰符加在<code>START TRANSACTION</code>语句后边就好，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY;</span><br></pre></td></tr></table></figure>

<p>如果我们想在<code>START TRANSACTION</code>后边跟随多个<code>修饰符</code>的话，可以使用逗号将<code>修饰符</code>分开，比如开启一个只读事务和一致性读，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure>

<p>或者开启一个读写事务和一致性读，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT</span><br></pre></td></tr></table></figure>

<p>不过这里需要大家注意的一点是，<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为<code>只读</code>的也设置为<code>读写</code>的，所以我们不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。</p>
</li>
</ul>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT [WORK]</span><br></pre></td></tr></table></figure>

<p><code>COMMIT</code>语句就代表提交一个事务，后边的<code>WORK</code>可有可无。比如我们上边说狗哥给猫爷转10元钱其实对应<code>MySQL</code>中的两条语句，我们就可以把这两条语句放到一个事务中，完整的过程就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="手动中止事务"><a href="#手动中止事务" class="headerlink" title="手动中止事务"></a>手动中止事务</h3><p>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK]</span><br></pre></td></tr></table></figure>

<p><code>ROLLBACK</code>语句就代表中止并回滚一个事务，后边的<code>WORK</code>可有可无类似的。比如我们在写狗哥给猫爷转账10元钱对应的<code>MySQL</code>语句时，先给狗哥扣了10元，然后一时大意只给猫爷账户上增加了1元，此时就可以使用<code>ROLLBACK</code>语句进行回滚，完整的过程就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line"></span><br><span class="line">我们这里所说的开启、提交、中止事务的语法只是针对使用黑框框时通过mysql客户端程序与服务器进行交互时控制事务的语法，如果大家使用的是别的客户端程序，比如JDBC之类的，那需要参考相应的文档来看看如何控制事务。</span><br></pre></td></tr></table></figure>

<h3 id="支持事务的存储引擎"><a href="#支持事务的存储引擎" class="headerlink" title="支持事务的存储引擎"></a>支持事务的存储引擎</h3><p><code>MySQL</code>中并不是所有存储引擎都支持事务的功能，目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持（NDB存储引擎不是我们的重点），如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。比方说我们有两个表，<code>tbl1</code>使用支持事务的存储引擎<code>InnoDB</code>，<code>tbl2</code>使用不支持事务的存储引擎<code>MyISAM</code>，它们的建表语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl1 (</span><br><span class="line">    i int</span><br><span class="line">) engine=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl2 (</span><br><span class="line">    i int</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>我们看看先开启一个事务，写一条插入语句后再回滚该事务，<code>tbl1</code>和<code>tbl2</code>的表现有什么不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl1 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，对于使用支持事务的存储引擎的<code>tbl1</code>表来说，我们在插入一条记录再回滚后，<code>tbl1</code>就恢复到没有插入记录时的状态了。再看看<code>tbl2</code>表的表现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl2 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">+------+</span><br><span class="line">| i    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然我们使用了<code>ROLLBACK</code>语句来回滚事务，但是插入的那条记录还是留在了<code>tbl2</code>表中。</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到它的默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。假如我们在狗哥向猫爷转账10元时不以<code>START TRANSACTION</code>或者<code>BEGIN</code>语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p>
<ul>
<li><p>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。</p>
<p>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p>
</li>
</ul>
<ul>
<li><p>把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。</p>
</li>
</ul>
<h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>，但是如果我们输入了某些语句之后就会<code>悄悄的</code>提交掉，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p>
<ul>
<li><p>定义或修改数据库对象的数据定义语言（Data definition language，缩写为：<code>DDL</code>）。</p>
<p>所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DELETE</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li>
<li><p>隐式使用或修改<code>mysql</code>数据库中的表</p>
<p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<p>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>

<p>或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前边语句所属的事务。</p>
<p>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句</p>
<p>比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>关于<code>MySQL</code>复制的一些语句</p>
<p>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>其它的一些语句</p>
<p>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line"></span><br><span class="line">上边提到的一些语句，如果你都认识并且知道是干嘛用的那再好不过了，不认识也不要气馁，这里写出来只是为了内容的完整性，把可能会导致事务隐式提交的情况都列举一下，具体每个语句都是干嘛用的等我们遇到了再说哈。</span><br></pre></td></tr></table></figure>

<h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以设计数据库的大叔们提出了一个<code>保存点</code>（英文：<code>savepoint</code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词<code>WORK</code>和<code>SAVEPOINT</code>是可有可无的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br></pre></td></tr></table></figure>

<p>不过如果<code>ROLLBACK</code>语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p>
<p>如果我们想删除某个保存点，可以使用这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>

<p>下边还是以狗哥向猫爷转账10元的例子展示一下<code>保存点</code>的用法，在执行完扣除狗哥账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SAVEPOINT s1;    # 一个保存点</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2; # 更新错了</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK TO s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>











<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列</p>
<blockquote>
<p>row_id 并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含 row_id 列</p>
</blockquote>
<ul>
<li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。</li>
<li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008231412.png" alt="20211008231412" style="zoom:50%;" />



<blockquote>
<p>实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
<p>虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它zhi向的undo日志类型为insert undo。所以我们之后在画图时都会把insert undo给去掉，大家留意一下就好了</p>
</blockquote>
<p>假设现在有两个事务id 分别为 100 、 200 的事务对这条记录进行 UPDATE 操作，操作流程如下：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008231621.png" alt="20211008231621" style="zoom:50%;" />



<blockquote>
<p>小贴士：</p>
<p>能不能在两个事务中交叉更新同一条记录呢？哈哈，这不就是一个事务修改了另一个未提交事务修改过</p>
<p>的数据，沦为了脏写了么？InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某</p>
<p>条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后</p>
<p>才可以继续更新。关于锁的更多细节我们后续的文章中再唠叨哈</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条 undo日志 ，每条 undo日志也都有一个 roll_pointer 属性（ INSERT 操作对应的 undo日志 没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008231736.png" alt="20211008231736" style="zoom:50%;" />



<p>对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 <strong>版本链</strong> ，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的 事务id ，这个信息很重要，我们稍后就会用到。</p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a><strong>ReadView</strong></h2><p>对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，</p>
<p>核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，提出了一个 ReadView 的概念，这个 ReadView 中主要包含4个比较重要的内容:</p>
<ul>
<li>m_ids ：表示在生成 ReadView 时当前系统中<strong>活跃的读写事务的 事务id 列表。</strong></li>
<li>min_trx_id ：表示在生成 ReadView 时当前系统中<strong>活跃的读写事务中最小的 事务id</strong> ，也就是 m_ids 中的最小值。</li>
<li>max_trx_id ：表示生成 ReadView 时系统中应该分配给<strong>下一个事务的 id 值</strong>。</li>
<li>creator_trx_id ：表示生成该 ReadView 的<strong>事务的 事务id</strong> 。</li>
</ul>
<blockquote>
<p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。</p>
<p>比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，</p>
<p>m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p>
</blockquote>
<p>有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ol>
<li>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录</p>
<p>读已提交和可重复读最大的区别就是ReadView生成的时机不同：</p>
<ul>
<li>读已提交：<strong>每次读取数据前都生成一个ReadView</strong></li>
<li>可重复读：<strong>在第一次读取数据时生成一个ReadView</strong></li>
</ul>
<h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>比方说现在系统里有两个 事务id 分别为 100 、 200 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次强调一遍，事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在Transaction 200中更新一些别的表的记录，目的是让它分配事务id。</p>
</blockquote>
<p>此时版本链如下：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008232651.png" alt="20211008232651" style="zoom:50%;" />

<p>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个 SELECT1 的执行过程如下：</p>
<ol>
<li>在执行 SELECT 语句时会先生成一个 ReadView ， ReadView 的 m_ids 列表的内容就是 [100, 200] ，min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 ‘张飞’ ，该版本的trx_id 值为 100 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘关羽’ ，该版本的 trx_id 值也为 100 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘刘备’ ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 ‘刘备’ 的记录。</li>
</ol>
<p>之后，我们把 事务id 为 100 的事务提交一下，事务200中修改了一些记录，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/binshow/img/master/20211008233429.png" alt="20211008233429" style="zoom:50%;" />



<p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 使用READ COMMITTED隔离级别的事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">\# SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"></span><br><span class="line">\# SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张飞&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个 SELECT2 的执行过程如下：</p>
<ol>
<li><p>在执行 SELECT 语句时会又会单独生成一个 ReadView ，该 ReadView 的 m_ids 列表的内容就是 [200] （ 事务id 为 100 的那个事务已经提交了，所以再次生成快照时就没有它了）， min_trx_id 为 200 ，max_trx_id 为 201 ， creator_trx_id 为 0 。</p>
</li>
<li><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 ‘诸葛亮’ ，该版本的trx_id 值为 200 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</p>
</li>
<li><p>下一个版本的列 name 的内容是 ‘赵云’ ，该版本的 trx_id 值为 200 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</p>
</li>
<li><p>下一个版本的列 name 的内容是 ‘张飞’ ，该版本的 trx_id 值为 100 ，小于 ReadView 中的 min_trx_id 值200 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 ‘张飞’ 的记录。</p>
</li>
<li><p>以此类推，如果之后 事务id 为 200 的记录也提交了，再此在使用 READ COMMITTED 隔离级别的事务中查询表hero 中 number 值为 1 的记录时，得到的结果就是 ‘诸葛亮’ 了，具体流程我们就不分析了。</p>
</li>
</ol>
<p>总结一下就是用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>比方说现在系统里有两个 事务id 分别为 100 、 200 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<p>此刻，表 hero 中 number 为 1 的记录得到的版本链表如下所示：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008233902.png" alt="20211008233902" style="zoom:50%;" />

<p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>



<p>这个 SELECT1 的执行过程如下：</p>
<ol>
<li>在执行 SELECT 语句时会先生成一个 ReadView ， ReadView 的 m_ids 列表的内容就是 [100, 200] ，min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 ‘张飞’ ，该版本的trx_id 值为 100 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘关羽’ ，该版本的 trx_id 值也为 100 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘刘备’ ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 ‘刘备’ 的记录。</li>
</ol>
<p>之后，我们把 事务id 为 100 的事务提交一下，事务200修改一下记录，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表 hero 中 number 为 1 的记录的版本链就长这样：</p>
<img src="https://raw.githubusercontent.com/binshow/img/master/20211008234116.png" alt="20211008234116" style="zoom:50%;" />

<p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>



<p>这个 SELECT2 的执行过程如下：</p>
<ol>
<li>因为当前事务的隔离级别为 REPEATABLE READ ，而之前在执行 SELECT1 时已经生成过 ReadView 了，所以此时直接复用之前的 ReadView ，之前的 ReadView 的 m_ids 列表的内容就是 [100, 200] ， min_trx_id 为100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 ‘诸葛亮’ ，该版本的trx_id 值为 200 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘赵云’ ，该版本的 trx_id 值为 200 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘张飞’ ，该版本的 trx_id 值为 100 ，而 m_ids 列表中是包含值为 100 的事务id 的，所以该版本也不符合要求，同理下一个列 name 的内容是 ‘关羽’ 的版本也不符合要求。继续跳到下一个版本。</li>
<li>下一个版本的列 name 的内容是 ‘刘备’ ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 c 为 ‘刘备’ 的记录。也就是说两次 SELECT 查询得到的结果是重复的，记录的列 c 值都是 ‘刘备’ ，这就是 可重复读 的含义。</li>
<li>如果我们之后再把 事务id 为 200 的记录提交了，然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 number 为 1 的记录，得到的结果还是 ‘刘备’ ，具体执行过程大家可以自己分析一下。</li>
</ol>
<h2 id="MVCC小结"><a href="#MVCC小结" class="headerlink" title="MVCC小结"></a>MVCC小结</h2><p> MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<p> READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：<strong>生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</strong></p>
<h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="从对数据操作的粒度分类："><a href="#从对数据操作的粒度分类：" class="headerlink" title="从对数据操作的粒度分类："></a><strong>从对数据操作的粒度分类</strong>：</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h3 id="从对数据操作的类型分类："><a href="#从对数据操作的类型分类：" class="headerlink" title="从对数据操作的类型分类："></a><strong>从对数据操作的类型分类</strong>：</h3><ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> dept read;  <span class="operator">/</span><span class="operator">/</span>加上读锁</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span> deptno <span class="operator">|</span> deptname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> tech     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span> sale     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span> fin      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span> hr       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> update dept <span class="keyword">set</span> deptno <span class="operator">=</span> <span class="number">6</span> <span class="keyword">where</span> deptname <span class="operator">=</span> <span class="string">&#x27;tech&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>不能修改了</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;dept&#x27;</span> was locked <span class="keyword">with</span> a READ lock <span class="keyword">and</span> can<span class="string">&#x27;t be updated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; unlock table; //解锁</span></span><br><span class="line"><span class="string">Query OK, 0 rows affected (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>





<p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p>
<h2 id="解释一下悲观锁和乐观锁"><a href="#解释一下悲观锁和乐观锁" class="headerlink" title="解释一下悲观锁和乐观锁"></a>解释一下悲观锁和乐观锁</h2><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p>
<p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p>
<h3 id="乐观锁的版本号机制"><a href="#乐观锁的版本号机制" class="headerlink" title="乐观锁的版本号机制"></a>乐观锁的版本号机制</h3><p>在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p>这种方式类似我们熟悉的 SVN、CVS 版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p>
<p>从这两种锁的设计思想中，你能看出乐观锁和悲观锁的适用场景：</p>
<ol>
<li>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。</li>
</ol>
<h2 id="InnoDB锁的模式"><a href="#InnoDB锁的模式" class="headerlink" title="InnoDB锁的模式"></a>InnoDB锁的模式</h2><p> InnoDB 三种行锁的方式</p>
<p>**记录锁(Record Locks)**： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p>
<p>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SET age = 50 WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p><strong>间隙锁（Gap Locks）</strong>： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。</p>
<p>InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p>
<p>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p>
<p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p>
<p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</p>
<p><strong>临键锁(Next-key Locks)<strong>： <strong>临键锁</strong>，是</strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)</p>
<p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p>
<p>对于行的查询，都是采用该方法，主要目的是解决幻读的问题</p>
<h2 id="死锁该如何解决"><a href="#死锁该如何解决" class="headerlink" title="死锁该如何解决"></a>死锁该如何解决</h2><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li>
</ul>
<p><strong>InnoDB避免死锁</strong>：</p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
</ul>
<p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<p>我们都不希望出现死锁的情况，可以采取一些方法避免死锁的发生：</p>
<ol>
<li>如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；</li>
<li>如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；</li>
<li>不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/Users/shengbinbin/Documents/MacBookHexoBlog/blog/source/_posts/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/MySQL%2525EF%2525BC%252588%2525E5%25259B%25259B%2525EF%2525BC%252589%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581/%2525E4%2525BA%25258B%2525E5%25258A%2525A1%2525E5%252592%25258C%2525E9%252594%252581%2525E6%252580%2525BB%2525E7%2525BB%252593.png" alt="事务和锁总结"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MySQL（八）事务</p><p><a href="http://example.com/2021/10/08/MySQL（八）事务/">http://example.com/2021/10/08/MySQL（八）事务/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MySQL/">MySQL</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/08/MySQL%EF%BC%88%E4%B9%9D%EF%BC%89%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL（九）日志详解</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/08/MySQL%EF%BC%88%E4%B8%83%EF%BC%89explain%E8%AF%A6%E8%A7%A3/"><span class="level-item">MySQL（七）explain详解</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">94</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">19</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#事务简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">事务简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事务的起源"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">事务的起源</span></span></a></li><li><a class="level is-mobile" href="#事务的四个基本属性"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">事务的四个基本属性</span></span></a></li><li><a class="level is-mobile" href="#并发事务会带来的问题"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">并发事务会带来的问题</span></span></a></li><li><a class="level is-mobile" href="#如何解决这些问题"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">如何解决这些问题</span></span></a></li><li><a class="level is-mobile" href="#事务的四种隔离级别"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">事务的四种隔离级别</span></span></a></li><li><a class="level is-mobile" href="#介绍一下MVCC"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">介绍一下MVCC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MVCC在innodb中的实现"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">MVCC在innodb中的实现</span></span></a></li><li><a class="level is-mobile" href="#innodb如何解决幻读的问题"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">innodb如何解决幻读的问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务日志"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">事务日志</span></span></a></li><li><a class="level is-mobile" href="#事务的ACID是如何保证实现的"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">事务的ACID是如何保证实现的</span></span></a></li><li><a class="level is-mobile" href="#MySQL对分布式事务的支持"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">MySQL对分布式事务的支持</span></span></a></li><li><a class="level is-mobile" href="#MySQL中事务的语法"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">MySQL中事务的语法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#开启事务"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">开启事务</span></span></a></li><li><a class="level is-mobile" href="#提交事务"><span class="level-left"><span class="level-item">1.10.2</span><span class="level-item">提交事务</span></span></a></li><li><a class="level is-mobile" href="#手动中止事务"><span class="level-left"><span class="level-item">1.10.3</span><span class="level-item">手动中止事务</span></span></a></li><li><a class="level is-mobile" href="#支持事务的存储引擎"><span class="level-left"><span class="level-item">1.10.4</span><span class="level-item">支持事务的存储引擎</span></span></a></li><li><a class="level is-mobile" href="#自动提交"><span class="level-left"><span class="level-item">1.10.5</span><span class="level-item">自动提交</span></span></a></li><li><a class="level is-mobile" href="#隐式提交"><span class="level-left"><span class="level-item">1.10.6</span><span class="level-item">隐式提交</span></span></a></li><li><a class="level is-mobile" href="#保存点"><span class="level-left"><span class="level-item">1.10.7</span><span class="level-item">保存点</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#事务的隔离级别"><span class="level-left"><span class="level-item">2</span><span class="level-item">事务的隔离级别</span></span></a></li><li><a class="level is-mobile" href="#MVCC原理"><span class="level-left"><span class="level-item">3</span><span class="level-item">MVCC原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#版本链"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">版本链</span></span></a></li><li><a class="level is-mobile" href="#ReadView"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">ReadView</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#读已提交"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">读已提交</span></span></a></li><li><a class="level is-mobile" href="#可重复读"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">可重复读</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MVCC小结"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">MVCC小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL中的锁"><span class="level-left"><span class="level-item">4</span><span class="level-item">MySQL中的锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#锁的分类"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">锁的分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#从对数据操作的粒度分类："><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">从对数据操作的粒度分类：</span></span></a></li><li><a class="level is-mobile" href="#从对数据操作的类型分类："><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">从对数据操作的类型分类：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#解释一下悲观锁和乐观锁"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">解释一下悲观锁和乐观锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#乐观锁的版本号机制"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">乐观锁的版本号机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#InnoDB锁的模式"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">InnoDB锁的模式</span></span></a></li><li><a class="level is-mobile" href="#死锁该如何解决"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">死锁该如何解决</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">5</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">86</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-15T16:26:26.000Z">2021-12-16</time></p><p class="title"><a href="/2021/12/16/Go-Learning%EF%BC%88%E5%85%AB%EF%BC%89%E6%A0%87%E5%87%86%E5%BA%93/">Go-Learning（八）标准库</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-13T01:59:46.000Z">2021-11-13</time></p><p class="title"><a href="/2021/11/13/Go-Learning%EF%BC%88%E4%B8%83%EF%BC%89%E5%8F%8D%E5%B0%84/">Go_Learning（七）反射</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-13T01:59:35.000Z">2021-11-13</time></p><p class="title"><a href="/2021/11/13/Go-Learning%EF%BC%88%E5%85%AD%EF%BC%89%E5%B9%B6%E5%8F%91/">Go_Learning（六）并发</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-13T01:59:15.000Z">2021-11-13</time></p><p class="title"><a href="/2021/11/13/Go-Learning%EF%BC%88%E4%BA%94%EF%BC%89%E6%8E%A5%E5%8F%A3/">Go_Learning（四）接口</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-13T01:59:15.000Z">2021-11-13</time></p><p class="title"><a href="/2021/11/13/Go-Learning%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%B9%E6%B3%95/">Go_Learning（四）方法</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>