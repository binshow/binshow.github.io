<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL（七）explain详解 - 漫漫转码路</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="漫漫转码路"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="漫漫转码路"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="explain详解~"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL（七）explain详解"><meta property="og:url" content="http://example.com/2021/10/08/MySQL%EF%BC%88%E4%B8%83%EF%BC%89explain%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="漫漫转码路"><meta property="og:description" content="explain详解~"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/MySQL2.jpeg"><meta property="article:published_time" content="2021-10-08T12:59:23.000Z"><meta property="article:modified_time" content="2021-10-08T14:04:11.714Z"><meta property="article:author" content="binshow"><meta property="article:tag" content="MySQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/MySQL2.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/08/MySQL%EF%BC%88%E4%B8%83%EF%BC%89explain%E8%AF%A6%E8%A7%A3/"},"headline":"MySQL（七）explain详解","image":[],"datePublished":"2021-10-08T12:59:23.000Z","dateModified":"2021-10-08T14:04:11.714Z","author":{"@type":"Person","name":"binshow"},"description":"explain详解~"}</script><link rel="canonical" href="http://example.com/2021/10/08/MySQL%EF%BC%88%E4%B8%83%EF%BC%89explain%E8%AF%A6%E8%A7%A3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/MySQL2.jpeg" alt="MySQL（七）explain详解"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-08T12:59:23.000Z" title="2021/10/8下午8:59:23">2021-10-08</time>发表</span><span class="level-item"><time dateTime="2021-10-08T14:04:11.714Z" title="2021/10/8下午10:04:11">2021-10-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">2 小时读完 (大约17002个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL（七）explain详解</h1><div class="content"><p>explain详解~</p>
<span id="more"></span>

<h1 id="Explain-详解（上）"><a href="#Explain-详解（上）" class="headerlink" title="Explain 详解（上）"></a>Explain 详解（上）</h1><p>前文说过：<strong>一条查询语句经过MySQL查询优化器的各种基于成本和规则的优化之后会生成一个执行计划</strong>。</p>
<p>这个执行计划就是具体执行查询的方式：比如多表连接的顺序、对每个表采用什么访问方案等。这些执行计划可以通过explain来查看：</p>
<p><img src="https://raw.githubusercontent.com/binshow/img/master/20211003102353.png" alt="20211003102353"></p>
<blockquote>
<p>除了 select开头的sql语句，其余的delete、insert和update等语句前面都可以加上explain这个词。</p>
</blockquote>
<p><code>EXPLAIN</code>语句输出的各个列的作用先大致罗列一下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>id</code></td>
<td align="left">在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td>
</tr>
<tr>
<td align="center"><code>select_type</code></td>
<td align="left"><code>SELECT</code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td align="center"><code>table</code></td>
<td align="left">表名</td>
</tr>
<tr>
<td align="center"><code>partitions</code></td>
<td align="left">匹配的分区信息</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="left">针对单表的访问方法</td>
</tr>
<tr>
<td align="center"><code>possible_keys</code></td>
<td align="left">可能用到的索引</td>
</tr>
<tr>
<td align="center"><code>key</code></td>
<td align="left">实际上使用的索引</td>
</tr>
<tr>
<td align="center"><code>key_len</code></td>
<td align="left">实际使用到的索引长度</td>
</tr>
<tr>
<td align="center"><code>ref</code></td>
<td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td align="center"><code>rows</code></td>
<td align="left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td align="center"><code>filtered</code></td>
<td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td align="center"><code>Extra</code></td>
<td align="left">一些额外的信息</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>我们仍然假设有两个和<code>single_table</code>表构造一模一样的<code>s1</code>、<code>s2</code>表，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。为了让大家有比较好的阅读体验，我们下边并不准备严格按照<code>EXPLAIN</code>输出列的顺序来介绍这些列分别是干嘛的，大家注意一下就好了。</p>
<h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以设计<code>MySQL</code>的大叔规定<span style="color:red">EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名</span>。所以我们看一条比较简单的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9688</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这个查询语句只涉及对<code>s1</code>表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的<code>table</code>列的值是<code>s1</code>，表明这条记录是用来说明对<code>s1</code>表的单表访问方法的。</p>
<p>下边我们看一下一个连接查询的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9688</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9954</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的<code>table</code>列分别是<code>s1</code>和<code>s2</code>，这两条记录用来分别说明对<code>s1</code>表和<code>s2</code>表的访问方法是什么。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>我们知道我们写的查询语句一般都以<code>SELECT</code>关键字开头，比较简单的查询语句里只有一个<code>SELECT</code>关键字，比如下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的连接查询中也只有一个<code>SELECT</code>关键字，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p>但是下边两种情况下在一条查询语句中会出现多个<code>SELECT</code>关键字：</p>
<ul>
<li><p>查询中包含子查询的情况</p>
<p>比如下边这个查询语句中就包含2个<code>SELECT</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT * FROM s2);</span><br></pre></td></tr></table></figure></li>
<li><p>查询中包含<code>UNION</code>语句的情况</p>
<p>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1  UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查询语句中每出现一个<code>SELECT</code>关键字，设计<code>MySQL</code>的大叔就会为它分配一个唯一的<code>id</code>值。这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，<span style="color:red">每个表都会对应一条记录，但是这些记录的id值都是相同的</span>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  ||  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，上述连接查询中参与连接的<code>s1</code>和<code>s2</code>表分别对应一条记录，但是这两条记录对应的<code>id</code>值都是<code>1</code>。这里需要大家记住的是，<span style="color:red">在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</span>。所以从上边的<code>EXPLAIN</code>输出中我们可以看出，查询优化器准备让<code>s1</code>表作为驱动表，让<code>s2</code>表作为被驱动表来执行查询。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where ||  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>从输出结果中我们可以看到，<code>s1</code>表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是<code>1</code>，<code>s2</code>表在子查询中，子查询有一个独立的<code>SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p>
<p>但是这里大家需要特别注意，<span style="color:red">查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</span>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#x27;a&#x27;);+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary ||  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中<code>s1</code>和<code>s2</code>表对应的记录的<code>id</code>值全部是<code>1</code>，这就表明了<span style="color:red">查询优化器将子查询转换为了连接查询</span>。</p>
<p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            ||  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这个语句的执行计划的第三条记录是个什么鬼？为毛<code>id</code>值是<code>NULL</code>，而且<code>table</code>列长的也怪怪的？大家别忘了<code>UNION</code>子句是干嘛用的，它会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？<code>MySQL</code>使用的是内部的临时表。正如上边的查询计划中所示，<code>UNION</code>子句是为了把<code>id</code>为<code>1</code>的查询和<code>id</code>为<code>2</code>的查询的结果集合并起来并去重，所以在内部创建了一个名为<code>&lt;union1, 2&gt;</code>的临时表（就是执行计划第三条记录的<code>table</code>列的名称），<code>id</code>为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟<code>UNION</code>对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个<code>id</code>为<code>NULL</code>的记录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  ||  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p>
<p>设计<code>MySQL</code>的大叔为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，口说无凭，我们还是先来见识见识这个<code>select_type</code>都能取哪些值（为了精确起见，我们直接使用文档中的英文做简要描述，随后会进行详细解释的）：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SIMPLE</code></td>
<td align="left">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td align="center"><code>PRIMARY</code></td>
<td align="left">Outermost SELECT</td>
</tr>
<tr>
<td align="center"><code>UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td align="center"><code>UNION RESULT</code></td>
<td align="left">Result of a UNION</td>
</tr>
<tr>
<td align="center"><code>SUBQUERY</code></td>
<td align="left">First SELECT in subquery</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT SUBQUERY</code></td>
<td align="left">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DERIVED</code></td>
<td align="left">Derived table</td>
</tr>
<tr>
<td align="center"><code>MATERIALIZED</code></td>
<td align="left">Materialized subquery</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE SUBQUERY</code></td>
<td align="left">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE UNION</code></td>
<td align="left">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<p>英文描述太简单，不知道说了啥？来详细瞅瞅里边儿的每个值都是干啥吃的：</p>
<ul>
<li><p><code>SIMPLE</code></p>
<p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询的<code>select_type</code>的值就是<code>SIMPLE</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>当然，连接查询也算是<code>SIMPLE</code>类型，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  ||  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>PRIMARY</code>    </p>
<p>对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;<span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            ||  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。</p>
</li>
<li><p><code>UNION</code></p>
<p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。</p>
</li>
<li><p><code>UNION RESULT</code></p>
<p><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上边有，就不赘述了。</p>
</li>
<li><p><code>SUBQUERY</code></p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where ||  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+2 rows in set, 1 warning (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。需要大家注意的是，<span style="color:red">由于select_type为SUBQUERY的子查询由于会被物化，所以只需要执行一遍</span>。</p>
</li>
<li><p><code>DEPENDENT SUBQUERY</code></p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+| id | select_type        | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra       |+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+|  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where ||  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key2,idx_key1 | idx_key2 | 5       | xiaohaizi.s1.key2 |    1 |    10.00 | Using where |+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>需要大家注意的是，<span style="color:red">select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</span>。</p>
</li>
<li><p><code>DEPENDENT UNION</code>    </p>
<p>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。说的有些绕哈，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9688 |   100.00 | Using where              ||  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |   12 |   100.00 | Using where; Using index ||  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using where; Using index || NULL | UNION RESULT       | &lt;union2,3&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。</p>
</li>
<li><p><code>DERIVED</code></p>
<p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9688 |    33.33 | Using where ||  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，大家注意看它的<code>table</code>列显示的是<code>&lt;derived2&gt;</code>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象，大家可以试试哈～</span><br></pre></td></tr></table></figure></li>
<li><p><code>MATERIALIZED</code></p>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref               | rows | filtered | Extra       |+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL              | 9688 |   100.00 | Using where ||  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        ||  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL              | 9954 |   100.00 | Using index |+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+3 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是<code>&lt;subquery2&gt;</code>，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。</p>
</li>
<li><p><code>UNCACHEABLE SUBQUERY</code></p>
<p>不常用，就不多唠叨了。</p>
</li>
<li><p><code>UNCACHEABLE UNION</code></p>
<p>不常用，就不多唠叨了。</p>
</li>
</ul>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>由于我们压根儿就没唠叨过分区是个啥，所以这个输出列我们也就不说了哈，一般情况下我们的查询语句的执行计划的<code>partitions</code>列的值都是<code>NULL</code>。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>我们前边说过执行计划的一条记录就代表着<code>MySQL</code>对某个表的执行查询时的访问方法，其中的<code>type</code>列就表明了这个访问方法是个啥，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。但是我们之前只唠叨过对使用<code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。当然我们还要详细唠叨一下哈：</p>
<ul>
<li><p><code>system</code></p>
<p>当表中只有一条记录并且<span style="color:red">该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory</span>，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;Query OK, 0 rows affected (0.05 sec)mysql&gt; INSERT INTO t VALUES(1);Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>然后我们看一下查询这个表的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | t     | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>type</code>列的值就是<code>system</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：你可以把表改成使用InnoDB存储引擎，试试看执行计划的type列是什么。</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code></p>
<p>这个我们前边唠叨过，就是当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 5;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>eq_ref</code></p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  ||  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。</p>
</li>
<li><p><code>ref</code></p>
<p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就<span style="color:red">可能</span>是<code>ref</code>，最开始举过例子了，就不重复举例了。</p>
</li>
<li><p><code>fulltext</code></p>
<p>全文索引，我们没有细讲过，跳过～</p>
</li>
<li><p><code>ref_or_null</code></p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就<span style="color:red">可能</span>是<code>ref_or_null</code>，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    9 |   100.00 | Using index condition |+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>index_merge</code></p>
<p>一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可以使用<code>Intersection</code>、<code>Union</code>、<code>Sort-Union</code>这三种索引合并的方式来执行查询，忘掉的回去补一下哈，我们看一下执行计划中是怎么体现<code>MySQL</code>使用索引合并的方式来对某个表执行查询的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |   14 |   100.00 | Using union(idx_key1,idx_key3); Using where |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，<code>MySQL</code>打算使用索引合并的方式来执行对<code>s1</code>表的查询。</p>
</li>
<li><p><code>unique_subquery</code></p>
<p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+| id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9688 |   100.00 | Using where ||  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。</p>
</li>
<li><p><code>index_subquery</code></p>
<p><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+| id | select_type        | table | partitions | type           | possible_keys     | key      | key_len | ref  | rows | filtered | Extra       |+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3          | NULL     | NULL    | NULL | 9688 |   100.00 | Using where ||  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key1,idx_key3 | idx_key3 | 303     | func |    1 |    10.00 | Using where |+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+2 rows in set, 2 warnings (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>range</code></p>
<p>如果使用索引获取某些<code>范围区间</code>的记录，那么就<span style="color:red">可能</span>使用到<code>range</code>访问方法，比如下边的这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |   27 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  294 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>index</code></p>
<p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</span><br></pre></td></tr></table></figure></li>
<li><p><code>ALL</code></p>
<p>最熟悉的全表扫描，就不多唠叨了，直接看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p>
<h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>在<code>EXPLAIN</code>语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    6 |     2.75 | Using where |+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p>
<p>不过有一点比较特别，就是在使用<code>index</code>访问方法来查询某个表时，<code>possible_keys</code>列是空的，而<code>key</code>列展示的是实际使用到的索引，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>另外需要注意的一点是，<span style="color:red">possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引</span>。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li><p>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</p>
</li>
<li><p>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</p>
</li>
<li><p>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</p>
</li>
</ul>
<p>比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 5;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>由于<code>id</code>列的类型是<code>INT</code>，并且不可以存储<code>NULL</code>值，所以在使用该列的索引时<code>key_len</code>大小就是<code>4</code>。当索引列可以存储<code>NULL</code>值时，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 5;+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>key_len</code>列就变成了<code>5</code>，比使用<code>id</code>列的索引时多了<code>1</code>。</p>
<p>对于可变长度的索引列来说，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由于<code>key1</code>列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是<code>300</code>字节，又因为该列允许存储<code>NULL</code>值，所以<code>key_len</code>需要加<code>1</code>，又因为该列是可变长度列，所以<code>key_len</code>需要加<code>2</code>，所以最后<code>ken_len</code>的值就是<code>303</code>。</p>
<p>有的同学可能有疑问：你在前边唠叨<code>InnoDB</code>行格式的时候不是说，存储变长字段的实际长度不是可能占用1个字节或者2个字节么？为什么现在不管三七二十一都用了<code>2</code>个字节？这里需要强调的一点是，执行计划的生成是在<code>MySQL server</code>层中的功能，并不是针对具体某个存储引擎的功能，设计<code>MySQL</code>的大叔在执行计划中输出<code>key_len</code>列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。比方说下边这个使用到联合索引<code>idx_key_part</code>的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |   12 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们可以从执行计划的<code>key_len</code>列中看到值是<code>303</code>，这意味着<code>MySQL</code>在执行上述查询中只能用到<code>idx_key_part</code>索引的一个索引列，而下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 606     | const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>这个查询的执行计划的<code>ken_len</code>列的值是<code>606</code>，说明执行这个查询的时候可以用到联合索引<code>idx_key_part</code>的两个索引列。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。大家看下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  ||  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到对被驱动表<code>s2</code>的访问方法是<code>eq_ref</code>，而对应的<code>ref</code>列的值是<code>xiaohaizi.s1.id</code>，这说明在对被驱动表进行访问时会用到<code>PRIMARY</code>索引，也就是聚簇索引与一个列进行等值匹配的条件，于<code>s2</code>表的<code>id</code>作等值匹配的对象就是<code>xiaohaizi.s1.id</code>列（注意这里把数据库名也写出来了）。</p>
<p>有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9688 |   100.00 | NULL                  ||  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们看执行计划的第二条记录，可以看到对<code>s2</code>表采用<code>ref</code>访问方法执行查询，然后在查询计划的<code>ref</code>列里输出的是<code>func</code>，说明与<code>s2</code>表的<code>key1</code>列进行等值匹配的对象是一个函数。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27;;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们看到执行计划的<code>rows</code>列的值是<code>266</code>，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;z&#39;</code>这个条件的记录只有<code>266</code>条。</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>之前在分析连接查询的成本时提出过一个<code>condition filtering</code>的概念，就是<code>MySQL</code>在计算驱动表扇出时采用的一个策略：</p>
<ul>
<li><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</p>
</li>
<li><p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
</li>
</ul>
<p>比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |    10.00 | Using index condition; Using where |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划的<code>key</code>列中可以看出来，该查询使用<code>idx_key1</code>索引来执行查询，从<code>rows</code>列可以看出满足<code>key1 &gt; &#39;z&#39;</code>的记录有<code>266</code>条。执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>266</code>条记录中，有多少条记录满足其余的搜索条件，也就是<code>common_field = &#39;a&#39;</code>这个条件的百分比。此处<code>filtered</code>列的值是<code>10.00</code>，说明查询优化器预测在<code>266</code>条记录中有<code>10.00%</code>的记录满足<code>common_field = &#39;a&#39;</code>这个条件。</p>
<p>对于单表查询来说，这个<code>filtered</code>列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 9688 |    10.00 | Using where ||  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>， <code>filtered</code>列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 × 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p>
<h1 id="Explain-详解（下）"><a href="#Explain-详解（下）" class="headerlink" title="Explain 详解（下）"></a>Explain 详解（下）</h1><h2 id="执行计划输出中各列详解-1"><a href="#执行计划输出中各列详解-1" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。<code>MySQL</code>提供的额外信息有好几十个，我们就不一个一个介绍了（都介绍了感觉我们的文章就跟文档差不多了～），所以我们只挑一些平时常见的或者比较重要的额外信息介绍给大家哈。</p>
<ul>
<li><p><code>No tables used</code></p>
<p>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Impossible WHERE</code></p>
<p>查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息，比方说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>No matching min/max row</code></p>
<p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息，比方说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;abcdefg&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using index</code></p>
<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using index condition</code></p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下边步骤来执行这个查询的：</p>
<ul>
<li><p>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</p>
</li>
<li><p>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</p>
</li>
</ul>
<p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以设计<code>MySQL</code>的大叔把上边的步骤改进了一下：</p>
<ul>
<li><p>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</p>
</li>
<li><p>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</p>
</li>
<li><p>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</p>
</li>
</ul>
<p>我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计<code>MySQL</code>的大叔们把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。</p>
<p>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code>，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%b&#x27;;  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+  | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+  |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+  1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using where</code></p>
<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还有包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND common_field = &#x27;a&#x27;;+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using join buffer (Block Nested Loop)</code></p>
<p>在连接查询执行过程过，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>，比如下边这个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                               ||  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |    10.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+2 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>可以在对<code>s2</code>表的执行计划的<code>Extra</code>列显示了两个提示：</p>
<ul>
<li><p><code>Using join buffer (Block Nested Loop)</code>：这是因为对表<code>s2</code>的访问不能有效利用索引，只好退而求其次，使用<code>join buffer</code>来减少对<code>s2</code>表的访问次数，从而提高性能。</p>
</li>
<li><p><code>Using where</code>：可以看到查询语句中有一个<code>s1.common_field = s2.common_field</code>条件，因为<code>s1</code>是驱动表，<code>s2</code>是被驱动表，所以在访问<code>s2</code>表时，<code>s1.common_field</code>的值已经确定下来了，所以实际上查询<code>s2</code>表的条件就是<code>s2.common_field = 一个常数</code>，所以提示了<code>Using where</code>额外信息。</p>
</li>
</ul>
</li>
<li><p><code>Not exists</code></p>
<p>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                   |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              | 9688 |   100.00 | NULL                    ||  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |    10.00 | Using where; Not exists |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上述查询中<code>s1</code>表是驱动表，<code>s2</code>表是被驱动表，<code>s2.id</code>列是不允许存储<code>NULL</code>值的，而<code>WHERE</code>子句中又包含<code>s2.id IS NULL</code>的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配<code>ON</code>子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合<code>ON</code>子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们<span style="color:red">没有必要到被驱动表中找到全部符合ON子句条件的记录</span>，这样可以稍微节省一点性能。</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code></p>
<p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。比如这个查询的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;a&#x27;;+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                           |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key3,idx_key1 | 303,303 | NULL |    1 |   100.00 | Using intersect(idx_key3,idx_key1); Using where |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>其中<code>Extra</code>列就显示了<code>Using intersect(idx_key3,idx_key1)</code>，表明<code>MySQL</code>即将使用<code>idx_key3</code>和<code>idx_key1</code>这两个索引进行<code>Intersect</code>索引合并的方式执行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：剩下两种类型的索引合并的Extra列信息就不一一举例子了，自己写个查询瞅瞅呗～</span><br></pre></td></tr></table></figure></li>
<li><p><code>Zero limit</code></p>
<p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra      |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Zero limit |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using filesort</code></p>
<p>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计<code>MySQL</code>的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用<code>文件排序</code>的执行方式改为使用索引进行排序。</p>
</li>
<li><p><code>Using temporary</code></p>
<p>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary; Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>不知道大家注意到没有，上述执行计划的<code>Extra</code>列不仅仅包含<code>Using temporary</code>提示，还包含<code>Using filesort</code>提示，可是我们的查询语句中明明没有写<code>ORDER BY</code>子句呀？这是因为<code>MySQL</code>会在包含<code>GROUP BY</code>子句的查询中默认添加上<code>ORDER BY</code>子句，也就是说上述查询其实和下边这个查询等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;</span><br></pre></td></tr></table></figure>

<p>如果我们并不想为包含<code>GROUP BY</code>子句的查询进行排序，需要我们显式的写上<code>ORDER BY NULL</code>，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY NULL;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这回执行计划中就没有<code>Using filesort</code>的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。</p>
<p>另外，执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从<code>Extra</code>的<code>Using index</code>的提示里我们可以看出，上述查询只需要扫描<code>idx_key1</code>索引就可以搞定了，不再需要临时表了。</p>
</li>
</ul>
<ul>
<li><p><code>Start temporary, End temporary</code></p>
<p>我们前边唠叨子查询的时候说过，查询优化器会优先尝试将<code>IN</code>子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#x27;a&#x27;);+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary ||  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>LooseScan</code></p>
<p>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#x27;z&#x27;);+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref               | rows | filtered | Extra                               |+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+|  1 | SIMPLE      | s2    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL              |  270 |   100.00 | Using where; Using index; LooseScan ||  1 | SIMPLE      | s1    | NULL       | ref   | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key1 |    1 |   100.00 | NULL                                |+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>FirstMatch(tbl_name)</code></p>
<p>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key1 FROM s2 where s1.key3 = s2.key3);+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra                       |+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where                 ||  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | xiaohaizi.s1.key3 |    1 |     4.87 | Using where; FirstMatch(s1) |+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h2><p>我们上边介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性 —— <span style="color:red">成本</span>。不过设计<code>MySQL</code>的大叔贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p>
<ul>
<li>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。</li>
</ul>
<p>这样我们就可以得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G*************************** 1. row ***************************EXPLAIN: &#123;  &quot;query_block&quot;: &#123;    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1    &quot;cost_info&quot;: &#123;      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16    &#125;,    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行        # 以下是参与嵌套循环连接算法的各个表的信息      &#123;        &quot;table&quot;: &#123;          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问          &quot;possible_keys&quot;: [    # 可能使用的索引            &quot;idx_key1&quot;          ],          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比          &quot;cost_info&quot;: &#123;            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量          &#125;,          &quot;used_columns&quot;: [     # 执行查询中涉及到的列            &quot;id&quot;,            &quot;key1&quot;,            &quot;key2&quot;,            &quot;key3&quot;,            &quot;key_part1&quot;,            &quot;key_part2&quot;,            &quot;key_part3&quot;,            &quot;common_field&quot;          ],                    # 对s1表访问时针对单表查询的条件          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;        &#125;      &#125;,      &#123;        &quot;table&quot;: &#123;          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问          &quot;possible_keys&quot;: [    # 可能使用的索引            &quot;idx_key2&quot;          ],          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引          &quot;used_key_parts&quot;: [   # 使用到的索引列            &quot;key2&quot;          ],          &quot;key_length&quot;: &quot;5&quot;,    # key_len          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象            &quot;xiaohaizi.s1.key1&quot;          ],          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比                    # s2表使用索引进行查询的搜索条件          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,          &quot;cost_info&quot;: &#123;            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量          &#125;,          &quot;used_columns&quot;: [     # 执行查询中涉及到的列            &quot;id&quot;,            &quot;key1&quot;,            &quot;key2&quot;,            &quot;key3&quot;,            &quot;key_part1&quot;,            &quot;key_part2&quot;,            &quot;key_part3&quot;,            &quot;common_field&quot;          ]        &#125;      &#125;    ]  &#125;&#125;1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们使用<code>#</code>后边跟随注释的形式为大家解释了<code>EXPLAIN FORMAT=JSON</code>语句的输出内容，但是大家可能有疑问<code>&quot;cost_info&quot;</code>里边的成本看着怪怪的，它们是怎么计算出来的？先看<code>s1</code>表的<code>&quot;cost_info&quot;</code>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;    &quot;read_cost&quot;: &quot;1840.84&quot;,    &quot;eval_cost&quot;: &quot;193.76&quot;,    &quot;prefix_cost&quot;: &quot;2034.60&quot;,    &quot;data_read_per_join&quot;: &quot;1M&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>read_cost</code>是由下边这两部分组成的：</p>
<ul>
<li><code>IO</code>成本</li>
<li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</span><br></pre></td></tr></table></figure></li>
<li><p><code>eval_cost</code>是这样计算的：</p>
<p>检测 <code>rows × filter</code>条记录的成本。</p>
</li>
<li><p><code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：</p>
<p><code>read_cost + eval_cost</code> </p>
</li>
<li><p><code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：大家其实没必要关注MySQL为啥使用这么古怪的方式计算出read_cost和eval_cost，关注prefix_cost是查询s1表的成本就好了。</span><br></pre></td></tr></table></figure>

<p>对于<code>s2</code>表的<code>&quot;cost_info&quot;</code>部分是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;    &quot;read_cost&quot;: &quot;968.80&quot;,    &quot;eval_cost&quot;: &quot;193.76&quot;,    &quot;prefix_cost&quot;: &quot;3197.16&quot;,    &quot;data_read_per_join&quot;: &quot;1M&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，大家主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure>

<h2 id="Extented-EXPLAIN"><a href="#Extented-EXPLAIN" class="headerlink" title="Extented EXPLAIN"></a>Extented EXPLAIN</h2><p>最后，设计<code>MySQL</code>的大叔还为我们留了个彩蛋，在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 9954 |    90.00 | Using where ||  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key1 |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+2 rows in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\G*************************** 1. row ***************************  Level: Note   Code: 1003Message: /* select#1 */ select `xiaohaizi`.`s1`.`key1` AS `key1`,`xiaohaizi`.`s2`.`key1` AS `key1` from `xiaohaizi`.`s1` join `xiaohaizi`.`s2` where ((`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key1`) and (`xiaohaizi`.`s2`.`common_field` is not null))1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个<code>s2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的<code>LEFT JOIN</code>已经变成了<code>JOIN</code>。</p>
<p>但是大家一定要注意，我们说<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p>
<h1 id="otpimizer-trace-表的神奇功效"><a href="#otpimizer-trace-表的神奇功效" class="headerlink" title="otpimizer trace 表的神奇功效"></a>otpimizer trace 表的神奇功效</h1><p>在<code>MySQL 5.6</code>以及之后的版本中，设计<code>MySQL</code>的大叔贴心的为这部分小伙伴提出了一个<code>optimizer trace</code>的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量<code>optimizer_trace</code>决定，我们看一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;optimizer_trace&#x27;</span>;<span class="operator">+</span><span class="comment">-----------------+--------------------------+| Variable_name   | Value                    |+-----------------+--------------------------+| optimizer_trace | enabled=off,one_line=off |+-----------------+--------------------------+1 row in set (0.02 sec)</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>enabled</code>值为<code>off</code>，表明这个功能默认是关闭的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：one_line的值是控制输出格式的，如果为on那么所有输出都将在一行中展示，不适合人阅读，所以我们就保持其默认值为off吧。</span><br></pre></td></tr></table></figure>

<p>如果想打开这个功能，必须首先把<code>enabled</code>的值改为<code>on</code>，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。这个<code>OPTIMIZER_TRACE</code>表有4个列，分别是：</p>
<ul>
<li><p><code>QUERY</code>：表示我们的查询语句。</p>
</li>
<li><p><code>TRACE</code>：表示优化过程的JSON格式文本。</p>
</li>
<li><p><code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</p>
</li>
<li><p><code>INSUFFICIENT_PRIVILEGES</code>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<code>1</code>，我们暂时不关心这个字段的值。</p>
</li>
</ul>
<p>完整的使用<code>optimizer trace</code>功能的步骤总结如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 1. 打开optimizer trace功能 (默认情况下它是关闭的):SET optimizer_trace=&quot;enabled=on&quot;;# 2. 这里输入你自己的查询语句SELECT ...; # 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程SELECT * FROM information_schema.OPTIMIZER_TRACE;# 4. 可能你还要观察其他语句执行的优化过程，重复上边的第2、3步...# 5. 当你停止查看语句的优化过程时，把optimizer trace功能关闭SET optimizer_trace=&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure>

<p>现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE    -&gt;     key1 &gt; &#x27;z&#x27; AND    -&gt;     key2 &lt; 1000000 AND    -&gt;     key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND    -&gt;     common_field = &#x27;abc&#x27;;+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+| id | select_type | table | partitions | type  | possible_keys              | key      | key_len | ref  | rows | filtered | Extra                              |+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+|  1 | SIMPLE      | s1    | NULL       | range | idx_key2,idx_key1,idx_key3 | idx_key2 | 5       | NULL |   12 |     0.42 | Using index condition; Using where |+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到该查询可能使用到的索引有3个，那么为什么优化器最终选择了<code>idx_key2</code>而不选择其他的索引或者直接全表扫描呢？这时候就可以通过<code>otpimzer trace</code>功能来查看优化器的具体工作过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;SELECT * FROM s1 WHERE     key1 &gt; &#x27;z&#x27; AND     key2 &lt; 1000000 AND     key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND     common_field = &#x27;abc&#x27;;    SELECT * FROM information_schema.OPTIMIZER_TRACE\G    </span><br></pre></td></tr></table></figure>

<p>我们直接看一下通过查询<code>OPTIMIZER_TRACE</code>表得到的输出（我使用<code>#</code>后跟随注释的形式为大家解释了优化过程中的一些比较重要的点，大家重点关注一下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************# 分析的查询语句是什么QUERY: SELECT * FROM s1 WHERE    key1 &gt; &#x27;z&#x27; AND    key2 &lt; 1000000 AND    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND    common_field = &#x27;abc&#x27;# 优化的具体过程TRACE: &#123;  &quot;steps&quot;: [    &#123;      &quot;join_preparation&quot;: &#123;     # prepare阶段        &quot;select#&quot;: 1,        &quot;steps&quot;: [          &#123;            &quot;IN_uses_bisection&quot;: true          &#125;,          &#123;            &quot;expanded_query&quot;: &quot;/* select#1 */ select `s1`.`id` AS `id`,`s1`.`key1` AS `key1`,`s1`.`key2` AS `key2`,`s1`.`key3` AS `key3`,`s1`.`key_part1` AS `key_part1`,`s1`.`key_part2` AS `key_part2`,`s1`.`key_part3` AS `key_part3`,`s1`.`common_field` AS `common_field` from `s1` where ((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;          &#125;        ] /* steps */      &#125; /* join_preparation */    &#125;,    &#123;      &quot;join_optimization&quot;: &#123;    # optimize阶段        &quot;select#&quot;: 1,        &quot;steps&quot;: [          &#123;            &quot;condition_processing&quot;: &#123;   # 处理搜索条件              &quot;condition&quot;: &quot;WHERE&quot;,              # 原始搜索条件              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,              &quot;steps&quot;: [                &#123;                  # 等值传递转换                  &quot;transformation&quot;: &quot;equality_propagation&quot;,                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;                &#125;,                &#123;                  # 常量传递转换                      &quot;transformation&quot;: &quot;constant_propagation&quot;,                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;                &#125;,                &#123;                  # 去除没用的条件                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;                &#125;              ] /* steps */            &#125; /* condition_processing */          &#125;,          &#123;            # 替换虚拟生成列            &quot;substitute_generated_columns&quot;: &#123;            &#125; /* substitute_generated_columns */          &#125;,          &#123;            # 表的依赖信息            &quot;table_dependencies&quot;: [              &#123;                &quot;table&quot;: &quot;`s1`&quot;,                &quot;row_may_be_null&quot;: false,                &quot;map_bit&quot;: 0,                &quot;depends_on_map_bits&quot;: [                ] /* depends_on_map_bits */              &#125;            ] /* table_dependencies */          &#125;,          &#123;            &quot;ref_optimizer_key_uses&quot;: [            ] /* ref_optimizer_key_uses */          &#125;,          &#123;                      # 预估不同单表访问方法的访问成本            &quot;rows_estimation&quot;: [              &#123;                &quot;table&quot;: &quot;`s1`&quot;,                &quot;range_analysis&quot;: &#123;                  &quot;table_scan&quot;: &#123;   # 全表扫描的行数以及成本                    &quot;rows&quot;: 9688,                    &quot;cost&quot;: 2036.7                  &#125; /* table_scan */,                                    # 分析可能使用的索引                  &quot;potential_range_indexes&quot;: [                    &#123;                      &quot;index&quot;: &quot;PRIMARY&quot;,   # 主键不可用                      &quot;usable&quot;: false,                      &quot;cause&quot;: &quot;not_applicable&quot;                    &#125;,                    &#123;                      &quot;index&quot;: &quot;idx_key2&quot;,  # idx_key2可能被使用                      &quot;usable&quot;: true,                      &quot;key_parts&quot;: [                        &quot;key2&quot;                      ] /* key_parts */                    &#125;,                    &#123;                      &quot;index&quot;: &quot;idx_key1&quot;,  # idx_key1可能被使用                      &quot;usable&quot;: true,                      &quot;key_parts&quot;: [                        &quot;key1&quot;,                        &quot;id&quot;                      ] /* key_parts */                    &#125;,                    &#123;                      &quot;index&quot;: &quot;idx_key3&quot;,  # idx_key3可能被使用                      &quot;usable&quot;: true,                      &quot;key_parts&quot;: [                        &quot;key3&quot;,                        &quot;id&quot;                      ] /* key_parts */                    &#125;,                    &#123;                      &quot;index&quot;: &quot;idx_key_part&quot;,  # idx_keypart不可用                      &quot;usable&quot;: false,                      &quot;cause&quot;: &quot;not_applicable&quot;                    &#125;                  ] /* potential_range_indexes */,                  &quot;setup_range_conditions&quot;: [                  ] /* setup_range_conditions */,                  &quot;group_index_range&quot;: &#123;                    &quot;chosen&quot;: false,                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;                  &#125; /* group_index_range */,                                    # 分析各种可能使用的索引的成本                  &quot;analyzing_range_alternatives&quot;: &#123;                    &quot;range_scan_alternatives&quot;: [                      &#123;                        # 使用idx_key2的成本分析                        &quot;index&quot;: &quot;idx_key2&quot;,                        # 使用idx_key2的范围区间                        &quot;ranges&quot;: [                          &quot;NULL &lt; key2 &lt; 1000000&quot;                        ] /* ranges */,                        &quot;index_dives_for_eq_ranges&quot;: true,   # 是否使用index dive                        &quot;rowid_ordered&quot;: false,     # 使用该索引获取的记录是否按照主键排序                        &quot;using_mrr&quot;: false,     # 是否使用mrr                        &quot;index_only&quot;: false,    # 是否是索引覆盖访问                        &quot;rows&quot;: 12,     # 使用该索引获取的记录条数                        &quot;cost&quot;: 15.41,  # 使用该索引的成本                        &quot;chosen&quot;: true  # 是否选择该索引                      &#125;,                      &#123;                        # 使用idx_key1的成本分析                        &quot;index&quot;: &quot;idx_key1&quot;,                        # 使用idx_key1的范围区间                        &quot;ranges&quot;: [                          &quot;z &lt; key1&quot;                        ] /* ranges */,                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上                        &quot;rowid_ordered&quot;: false,   # 同上                        &quot;using_mrr&quot;: false,   # 同上                        &quot;index_only&quot;: false,   # 同上                        &quot;rows&quot;: 266,   # 同上                        &quot;cost&quot;: 320.21,   # 同上                        &quot;chosen&quot;: false,   # 同上                        &quot;cause&quot;: &quot;cost&quot;   # 因为成本太大所以不选择该索引                      &#125;,                      &#123;                        # 使用idx_key3的成本分析                        &quot;index&quot;: &quot;idx_key3&quot;,                        # 使用idx_key3的范围区间                        &quot;ranges&quot;: [                          &quot;a &lt;= key3 &lt;= a&quot;,                          &quot;b &lt;= key3 &lt;= b&quot;,                          &quot;c &lt;= key3 &lt;= c&quot;                        ] /* ranges */,                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上                        &quot;rowid_ordered&quot;: false,   # 同上                        &quot;using_mrr&quot;: false,   # 同上                        &quot;index_only&quot;: false,   # 同上                        &quot;rows&quot;: 21,   # 同上                        &quot;cost&quot;: 28.21,   # 同上                        &quot;chosen&quot;: false,   # 同上                        &quot;cause&quot;: &quot;cost&quot;   # 同上                      &#125;                    ] /* range_scan_alternatives */,                                        # 分析使用索引合并的成本                    &quot;analyzing_roworder_intersect&quot;: &#123;                      &quot;usable&quot;: false,                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;                    &#125; /* analyzing_roworder_intersect */                  &#125; /* analyzing_range_alternatives */,                                    # 对于上述单表查询s1最优的访问方法                  &quot;chosen_range_access_summary&quot;: &#123;                    &quot;range_access_plan&quot;: &#123;                      &quot;type&quot;: &quot;range_scan&quot;,                      &quot;index&quot;: &quot;idx_key2&quot;,                      &quot;rows&quot;: 12,                      &quot;ranges&quot;: [                        &quot;NULL &lt; key2 &lt; 1000000&quot;                      ] /* ranges */                    &#125; /* range_access_plan */,                    &quot;rows_for_plan&quot;: 12,                    &quot;cost_for_plan&quot;: 15.41,                    &quot;chosen&quot;: true                  &#125; /* chosen_range_access_summary */                &#125; /* range_analysis */              &#125;            ] /* rows_estimation */          &#125;,          &#123;                        # 分析各种可能的执行计划            #（对多表查询这可能有很多种不同的方案，单表查询的方案上边已经分析过了，直接选取idx_key2就好）            &quot;considered_execution_plans&quot;: [              &#123;                &quot;plan_prefix&quot;: [                ] /* plan_prefix */,                &quot;table&quot;: &quot;`s1`&quot;,                &quot;best_access_path&quot;: &#123;                  &quot;considered_access_paths&quot;: [                    &#123;                      &quot;rows_to_scan&quot;: 12,                      &quot;access_type&quot;: &quot;range&quot;,                      &quot;range_details&quot;: &#123;                        &quot;used_index&quot;: &quot;idx_key2&quot;                      &#125; /* range_details */,                      &quot;resulting_rows&quot;: 12,                      &quot;cost&quot;: 17.81,                      &quot;chosen&quot;: true                    &#125;                  ] /* considered_access_paths */                &#125; /* best_access_path */,                &quot;condition_filtering_pct&quot;: 100,                &quot;rows_for_plan&quot;: 12,                &quot;cost_for_plan&quot;: 17.81,                &quot;chosen&quot;: true              &#125;            ] /* considered_execution_plans */          &#125;,          &#123;            # 尝试给查询添加一些其他的查询条件            &quot;attaching_conditions_to_tables&quot;: &#123;              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,              &quot;attached_conditions_computation&quot;: [              ] /* attached_conditions_computation */,              &quot;attached_conditions_summary&quot;: [                &#123;                  &quot;table&quot;: &quot;`s1`&quot;,                  &quot;attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;                &#125;              ] /* attached_conditions_summary */            &#125; /* attaching_conditions_to_tables */          &#125;,          &#123;            # 再稍稍的改进一下执行计划            &quot;refine_plan&quot;: [              &#123;                &quot;table&quot;: &quot;`s1`&quot;,                &quot;pushed_index_condition&quot;: &quot;(`s1`.`key2` &lt; 1000000)&quot;,                &quot;table_condition_attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;              &#125;            ] /* refine_plan */          &#125;        ] /* steps */      &#125; /* join_optimization */    &#125;,    &#123;      &quot;join_execution&quot;: &#123;    # execute阶段        &quot;select#&quot;: 1,        &quot;steps&quot;: [        ] /* steps */      &#125; /* join_execution */    &#125;  ] /* steps */&#125;# 因优化过程文本太多而丢弃的文本字节大小，值为0时表示并没有丢弃MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0# 权限字段INSUFFICIENT_PRIVILEGES: 01 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>大家看到这个输出的第一感觉就是这文本也太多了点儿吧，其实这只是优化器执行过程中的一小部分，设计<code>MySQL</code>的大叔可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：</p>
<ul>
<li><p><code>prepare</code>阶段</p>
</li>
<li><p><code>optimize</code>阶段</p>
</li>
<li><p><code>execute</code>阶段</p>
</li>
</ul>
<p>我们所说的基于成本的优化主要集中在<code>optimize</code>阶段，对于单表查询来说，我们主要关注<code>optimize</code>阶段的<code>&quot;rows_estimation&quot;</code>这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注<code>&quot;considered_execution_plans&quot;</code>这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用<code>EXPLAIN</code>语句所展现出的那种方案。</p>
<p>如果有小伙伴对使用<code>EXPLAIN</code>语句展示出的对某个查询的执行计划很不理解，大家可以尝试使用<code>optimizer trace</code>功能来详细了解每一种执行方案对应的成本，相信这个功能能让大家更深入的了解<code>MySQL</code>查询优化器。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MySQL（七）explain详解</p><p><a href="http://example.com/2021/10/08/MySQL（七）explain详解/">http://example.com/2021/10/08/MySQL（七）explain详解/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>binshow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MySQL/">MySQL</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL（八）事务</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/08/MySQL%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96/"><span class="level-item">MySQL（六）内部优化</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="binshow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">binshow</p><p class="is-size-6 is-block">后台开发工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>安徽</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">77</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Explain-详解（上）"><span class="level-left"><span class="level-item">1</span><span class="level-item">Explain 详解（上）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#执行计划输出中各列详解"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">执行计划输出中各列详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#table"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">table</span></span></a></li><li><a class="level is-mobile" href="#id"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">id</span></span></a></li><li><a class="level is-mobile" href="#select-type"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">select_type</span></span></a></li><li><a class="level is-mobile" href="#partitions"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">partitions</span></span></a></li><li><a class="level is-mobile" href="#type"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">type</span></span></a></li><li><a class="level is-mobile" href="#possible-keys和key"><span class="level-left"><span class="level-item">1.1.6</span><span class="level-item">possible_keys和key</span></span></a></li><li><a class="level is-mobile" href="#key-len"><span class="level-left"><span class="level-item">1.1.7</span><span class="level-item">key_len</span></span></a></li><li><a class="level is-mobile" href="#ref"><span class="level-left"><span class="level-item">1.1.8</span><span class="level-item">ref</span></span></a></li><li><a class="level is-mobile" href="#rows"><span class="level-left"><span class="level-item">1.1.9</span><span class="level-item">rows</span></span></a></li><li><a class="level is-mobile" href="#filtered"><span class="level-left"><span class="level-item">1.1.10</span><span class="level-item">filtered</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Explain-详解（下）"><span class="level-left"><span class="level-item">2</span><span class="level-item">Explain 详解（下）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#执行计划输出中各列详解-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">执行计划输出中各列详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Extra"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Extra</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Json格式的执行计划"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Json格式的执行计划</span></span></a></li><li><a class="level is-mobile" href="#Extented-EXPLAIN"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Extented EXPLAIN</span></span></a></li></ul></li><li><a class="level is-mobile" href="#otpimizer-trace-表的神奇功效"><span class="level-left"><span class="level-item">3</span><span class="level-item">otpimizer trace 表的神奇功效</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">68</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:40:04.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%94%81/">MySQL（十一）锁</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:39:51.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%8D%81%EF%BC%89%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97/">MySQL（十）回滚日志</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:58.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E4%B9%9D%EF%BC%89%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/">MySQL（九）日志详解</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T14:05:41.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%E4%BA%8B%E5%8A%A1/">MySQL（八）事务</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T12:59:23.000Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/MySQL%EF%BC%88%E4%B8%83%EF%BC%89explain%E8%AF%A6%E8%A7%A3/">MySQL（七）explain详解</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="漫漫转码路" height="28"></a><p class="is-size-7"><span>&copy; 2021 binshow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>